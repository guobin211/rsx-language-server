"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports2.Message = Message = {}));
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports2.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports2.Disposable = Disposable = {}));
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports2.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports2.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports2.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger2 = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger2.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger2.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger2.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger2.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger2.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger2.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger2.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger2.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger2.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger2.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger2.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger2.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger2.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger2.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger2.error("Received empty message.");
          return;
        }
        logger2.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger2.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger2.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger2.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger2.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path3 = require("path");
    var os2 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar2(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path3.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path3.join(os2.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server2 = (0, net_1.createServer)((socket) => {
          server2.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server2.on("error", reject);
        server2.listen(pipeName, () => {
          server2.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server2 = (0, net_1.createServer)((socket) => {
          server2.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server2.on("error", reject);
        server2.listen(port, "127.0.0.1", () => {
          server2.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger2, options) {
      if (!logger2) {
        logger2 = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger2, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    "use strict";
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlineCompletionContext = exports3.SelectedCompletionInfo = exports3.InlineCompletionTriggerKind = exports3.InlineCompletionList = exports3.InlineCompletionItem = exports3.StringValue = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports3.DocumentUri = DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI || (exports3.URI = URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (exports3.integer = integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports3.uinteger = uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position || (exports3.Position = Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range || (exports3.Range = Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports3.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports3.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports3.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports3.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports3.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports3.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports3.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity || (exports3.DiagnosticSeverity = DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports3.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports3.CodeDescription = CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (exports3.Diagnostic = Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command || (exports3.Command = Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit || (exports3.TextEdit = TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports3.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports3.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports3.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports3.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports3.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports3.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (exports3.WorkspaceEdit = WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        (function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        })()
      );
      var ChangeAnnotations = (
        /** @class */
        (function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        })()
      );
      var WorkspaceChange = (
        /** @class */
        (function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        })()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (exports3.TextDocumentIdentifier = TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports3.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind2;
      (function(MarkupKind3) {
        MarkupKind3.PlainText = "plaintext";
        MarkupKind3.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind3.PlainText || candidate === MarkupKind3.Markdown;
        }
        MarkupKind3.is = is;
      })(MarkupKind2 || (exports3.MarkupKind = MarkupKind2 = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind2.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports3.MarkupContent = MarkupContent = {}));
      var CompletionItemKind2;
      (function(CompletionItemKind3) {
        CompletionItemKind3.Text = 1;
        CompletionItemKind3.Method = 2;
        CompletionItemKind3.Function = 3;
        CompletionItemKind3.Constructor = 4;
        CompletionItemKind3.Field = 5;
        CompletionItemKind3.Variable = 6;
        CompletionItemKind3.Class = 7;
        CompletionItemKind3.Interface = 8;
        CompletionItemKind3.Module = 9;
        CompletionItemKind3.Property = 10;
        CompletionItemKind3.Unit = 11;
        CompletionItemKind3.Value = 12;
        CompletionItemKind3.Enum = 13;
        CompletionItemKind3.Keyword = 14;
        CompletionItemKind3.Snippet = 15;
        CompletionItemKind3.Color = 16;
        CompletionItemKind3.File = 17;
        CompletionItemKind3.Reference = 18;
        CompletionItemKind3.Folder = 19;
        CompletionItemKind3.EnumMember = 20;
        CompletionItemKind3.Constant = 21;
        CompletionItemKind3.Struct = 22;
        CompletionItemKind3.Event = 23;
        CompletionItemKind3.Operator = 24;
        CompletionItemKind3.TypeParameter = 25;
      })(CompletionItemKind2 || (exports3.CompletionItemKind = CompletionItemKind2 = {}));
      var InsertTextFormat2;
      (function(InsertTextFormat3) {
        InsertTextFormat3.PlainText = 1;
        InsertTextFormat3.Snippet = 2;
      })(InsertTextFormat2 || (exports3.InsertTextFormat = InsertTextFormat2 = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports3.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports3.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports3.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (exports3.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (exports3.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports3.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (exports3.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (exports3.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (exports3.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports3.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (exports3.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports3.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports3.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (exports3.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (exports3.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports3.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (exports3.CodeActionKind = CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports3.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports3.CodeActionContext = CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction || (exports3.CodeAction = CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports3.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports3.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports3.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports3.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports3.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports3.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports3.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports3.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports3.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports3.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports3.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports3.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports3.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports3.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (exports3.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (exports3.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports3.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (exports3.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (exports3.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (exports3.WorkspaceFolder = WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument2;
      (function(TextDocument3) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument2(uri, languageId, version, content);
        }
        TextDocument3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument3.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort2(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument3.applyEdits = applyEdits;
        function mergeSort2(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort2(left, compare);
          mergeSort2(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument2 || (exports3.TextDocument = TextDocument2 = {}));
      var FullTextDocument2 = (
        /** @class */
        (function() {
          function FullTextDocument3(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument3.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument3.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument3.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument3.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument3.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument3.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument3;
        })()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports2.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind || (exports2.TextDocumentSyncKind = TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports2.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports2.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger2, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger2, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar2(require_main(), exports2);
    __exportStar2(require_main2(), exports2);
    __exportStar2(require_messages2(), exports2);
    __exportStar2(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports2.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_12 = require_node();
    __exportStar2(require_node(), exports2);
    __exportStar2(require_api2(), exports2);
    function createProtocolConnection(input, output, logger2, options) {
      return (0, node_12.createMessageConnection)(input, output, logger2, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection2, token) {
        super(connection2, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection2, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection2, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection2, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection2, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FoldingRangeFeature = (Base) => {
      return class extends Base {
        get foldingRange() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection2.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection2.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection2.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var foldingRange_1 = require_foldingRange();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      debug(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration || (exports2.BulkRegistration = BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration || (exports2.BulkUnregistration = BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection3(connectionFactory, watchDog, factories) {
      const logger2 = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection2 = connectionFactory(logger2);
      logger2.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger2, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type, ...params) => connection2.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection2.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          return connection2.sendNotification(method, param);
        },
        onNotification: (type, handler) => connection2.onNotification(type, handler),
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger2;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection3;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/files.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveModulePath = exports2.FileSystem = exports2.resolveGlobalYarnPath = exports2.resolveGlobalNodePath = exports2.resolve = exports2.uriToFilePath = void 0;
    var url = require("url");
    var path3 = require("path");
    var fs2 = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path3.normalize(segments.join("/"));
    }
    exports2.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs2.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path3.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports2.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path3.join(prefix, "node_modules");
          } else {
            return path3.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path3.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs2.existsSync(__filename.toUpperCase()) || !fs2.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path3.normalize(child).indexOf(path3.normalize(parent)) === 0;
        } else {
          return path3.normalize(child).toLowerCase().indexOf(path3.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem || (exports2.FileSystem = FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path3.isAbsolute(nodePath)) {
          nodePath = path3.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports2.resolveModulePath = resolveModulePath;
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineCompletionFeature = (Base) => {
      return class extends Base {
        get inlineCompletion() {
          return {
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineCompletionFeature = InlineCompletionFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    var ic = require_inlineCompletion_proposed();
    __exportStar2(require_main3(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar2(require_server(), exports2);
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features",
        languages: ic.InlineCompletionFeature
      };
    })(ProposedFeatures || (exports2.ProposedFeatures = ProposedFeatures = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.Files = void 0;
    var node_util_1 = require("node:util");
    var Is = require_is();
    var server_12 = require_server();
    var fm = require_files();
    var node_12 = require_node2();
    __exportStar2(require_node2(), exports2);
    __exportStar2(require_api3(), exports2);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files || (exports2.Files = Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection3(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_12.ConnectionStrategy.is(arg1) || node_12.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports2.createConnection = createConnection3;
    function _createConnection(input, output, options, factories) {
      let stdio = false;
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_12.IPCMessageReader(process);
            output = new node_12.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            stdio = true;
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = (0, node_12.createServerSocketTransport)(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_12.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger2) => {
        const result = (0, node_12.createProtocolConnection)(input, output, logger2, options);
        if (stdio) {
          patchConsole(logger2);
        }
        return result;
      };
      return (0, server_12.createConnection)(connectionFactory, watchDog, factories);
    }
    function patchConsole(logger2) {
      function serialize(args) {
        return args.map((arg) => typeof arg === "string" ? arg : (0, node_util_1.inspect)(arg)).join(" ");
      }
      const counters = /* @__PURE__ */ new Map();
      console.assert = function assert(assertion, ...args) {
        if (assertion) {
          return;
        }
        if (args.length === 0) {
          logger2.error("Assertion failed");
        } else {
          const [message, ...rest] = args;
          logger2.error(`Assertion failed: ${message} ${serialize(rest)}`);
        }
      };
      console.count = function count(label = "default") {
        const message = String(label);
        let counter = counters.get(message) ?? 0;
        counter += 1;
        counters.set(message, counter);
        logger2.log(`${message}: ${message}`);
      };
      console.countReset = function countReset(label) {
        if (label === void 0) {
          counters.clear();
        } else {
          counters.delete(String(label));
        }
      };
      console.debug = function debug(...args) {
        logger2.log(serialize(args));
      };
      console.dir = function dir(arg, options) {
        logger2.log((0, node_util_1.inspect)(arg, options));
      };
      console.log = function log(...args) {
        logger2.log(serialize(args));
      };
      console.error = function error(...args) {
        logger2.error(serialize(args));
      };
      console.trace = function trace(...args) {
        const stack = new Error().stack.replace(/(.+\n){2}/, "");
        let message = "Trace";
        if (args.length !== 0) {
          message += `: ${serialize(args)}`;
        }
        logger2.log(`${message}
${stack}`);
      };
      console.warn = function warn(...args) {
        logger2.warn(serialize(args));
      };
    }
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// node_modules/.pnpm/@volar+source-map@2.4.26/node_modules/@volar/source-map/lib/binarySearch.js
var require_binarySearch = __commonJS({
  "node_modules/.pnpm/@volar+source-map@2.4.26/node_modules/@volar/source-map/lib/binarySearch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.binarySearch = binarySearch;
    function binarySearch(values, searchValue) {
      let low = 0;
      let high = values.length - 1;
      let match;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const midValue = values[mid];
        if (midValue < searchValue) {
          low = mid + 1;
        } else if (midValue > searchValue) {
          high = mid - 1;
        } else {
          low = mid;
          high = mid;
          match = mid;
          break;
        }
      }
      const finalLow = Math.max(Math.min(low, high, values.length - 1), 0);
      const finalHigh = Math.min(Math.max(low, high, 0), values.length - 1);
      return { low: finalLow, high: finalHigh, match };
    }
  }
});

// node_modules/.pnpm/@volar+source-map@2.4.26/node_modules/@volar/source-map/lib/translateOffset.js
var require_translateOffset = __commonJS({
  "node_modules/.pnpm/@volar+source-map@2.4.26/node_modules/@volar/source-map/lib/translateOffset.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.translateOffset = translateOffset;
    var warned = false;
    function translateOffset(start, fromOffsets, toOffsets, fromLengths, toLengths = fromLengths) {
      const isSorted = fromOffsets.every((value, index) => index === 0 || fromOffsets[index - 1] <= value);
      if (!isSorted) {
        for (let i = 0; i < fromOffsets.length; i++) {
          const fromOffset = fromOffsets[i];
          const fromLength = fromLengths[i];
          if (start >= fromOffset && start <= fromOffset + fromLength) {
            const toLength = toLengths[i];
            const toOffset = toOffsets[i];
            let rangeOffset = Math.min(start - fromOffset, toLength);
            return toOffset + rangeOffset;
          }
        }
        if (!warned) {
          warned = true;
          console.warn("fromOffsets should be sorted in ascending order");
        }
      }
      let low = 0;
      let high = fromOffsets.length - 1;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const fromOffset = fromOffsets[mid];
        const fromLength = fromLengths[mid];
        if (start >= fromOffset && start <= fromOffset + fromLength) {
          const toLength = toLengths[mid];
          const toOffset = toOffsets[mid];
          let rangeOffset = Math.min(start - fromOffset, toLength);
          return toOffset + rangeOffset;
        } else if (start < fromOffset) {
          high = mid - 1;
        } else {
          low = mid + 1;
        }
      }
    }
  }
});

// node_modules/.pnpm/@volar+source-map@2.4.26/node_modules/@volar/source-map/lib/sourceMap.js
var require_sourceMap = __commonJS({
  "node_modules/.pnpm/@volar+source-map@2.4.26/node_modules/@volar/source-map/lib/sourceMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SourceMap = void 0;
    var binarySearch_1 = require_binarySearch();
    var translateOffset_1 = require_translateOffset();
    var SourceMap = class {
      constructor(mappings) {
        this.mappings = mappings;
      }
      toSourceRange(generatedStart, generatedEnd, fallbackToAnyMatch, filter) {
        return this.findMatchingStartEnd(generatedStart, generatedEnd, fallbackToAnyMatch, "generatedOffsets", filter);
      }
      toGeneratedRange(sourceStart, sourceEnd, fallbackToAnyMatch, filter) {
        return this.findMatchingStartEnd(sourceStart, sourceEnd, fallbackToAnyMatch, "sourceOffsets", filter);
      }
      toSourceLocation(generatedOffset, filter) {
        return this.findMatchingOffsets(generatedOffset, "generatedOffsets", filter);
      }
      toGeneratedLocation(sourceOffset, filter) {
        return this.findMatchingOffsets(sourceOffset, "sourceOffsets", filter);
      }
      *findMatchingOffsets(offset, fromRange, filter) {
        const memo = this.getMemoBasedOnRange(fromRange);
        if (memo.offsets.length === 0) {
          return;
        }
        const { low: start, high: end } = (0, binarySearch_1.binarySearch)(memo.offsets, offset);
        const skip = /* @__PURE__ */ new Set();
        const toRange = fromRange === "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
        for (let i = start; i <= end; i++) {
          for (const mapping of memo.mappings[i]) {
            if (skip.has(mapping)) {
              continue;
            }
            skip.add(mapping);
            if (filter && !filter(mapping.data)) {
              continue;
            }
            const mapped = (0, translateOffset_1.translateOffset)(offset, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
            if (mapped !== void 0) {
              yield [mapped, mapping];
            }
          }
        }
      }
      *findMatchingStartEnd(start, end, fallbackToAnyMatch, fromRange, filter) {
        const toRange = fromRange === "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
        const mappedStarts = [];
        let hadMatch = false;
        for (const [mappedStart, mapping] of this.findMatchingOffsets(start, fromRange)) {
          if (filter && !filter(mapping.data)) {
            continue;
          }
          mappedStarts.push([mappedStart, mapping]);
          const mappedEnd = (0, translateOffset_1.translateOffset)(end, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
          if (mappedEnd !== void 0) {
            hadMatch = true;
            yield [mappedStart, mappedEnd, mapping, mapping];
          }
        }
        if (!hadMatch && fallbackToAnyMatch) {
          for (const [mappedStart, mappingStart] of mappedStarts) {
            for (const [mappedEnd, mappingEnd] of this.findMatchingOffsets(end, fromRange)) {
              if (filter && !filter(mappingEnd.data) || mappedEnd < mappedStart) {
                continue;
              }
              yield [mappedStart, mappedEnd, mappingStart, mappingEnd];
              break;
            }
          }
        }
      }
      getMemoBasedOnRange(fromRange) {
        return fromRange === "sourceOffsets" ? this.sourceCodeOffsetsMemo ??= this.createMemo("sourceOffsets") : this.generatedCodeOffsetsMemo ??= this.createMemo("generatedOffsets");
      }
      createMemo(key) {
        const offsetsSet = /* @__PURE__ */ new Set();
        for (const mapping of this.mappings) {
          for (let i = 0; i < mapping[key].length; i++) {
            offsetsSet.add(mapping[key][i]);
            offsetsSet.add(mapping[key][i] + getLengths(mapping, key)[i]);
          }
        }
        const offsets = [...offsetsSet].sort((a, b) => a - b);
        const mappings = offsets.map(() => /* @__PURE__ */ new Set());
        for (const mapping of this.mappings) {
          for (let i = 0; i < mapping[key].length; i++) {
            const startIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i]).match;
            const endIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i] + getLengths(mapping, key)[i]).match;
            for (let i2 = startIndex; i2 <= endIndex; i2++) {
              mappings[i2].add(mapping);
            }
          }
        }
        return { offsets, mappings };
      }
    };
    exports2.SourceMap = SourceMap;
    function getLengths(mapping, key) {
      return key === "sourceOffsets" ? mapping.lengths : mapping.generatedLengths ?? mapping.lengths;
    }
  }
});

// node_modules/.pnpm/@volar+source-map@2.4.26/node_modules/@volar/source-map/index.js
var require_source_map = __commonJS({
  "node_modules/.pnpm/@volar+source-map@2.4.26/node_modules/@volar/source-map/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_sourceMap(), exports2);
    __exportStar2(require_translateOffset(), exports2);
  }
});

// node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/lib/editor.js
var require_editor = __commonJS({
  "node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/lib/editor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHoverEnabled = isHoverEnabled;
    exports2.isInlayHintsEnabled = isInlayHintsEnabled;
    exports2.isCodeLensEnabled = isCodeLensEnabled;
    exports2.isMonikerEnabled = isMonikerEnabled;
    exports2.isInlineValueEnabled = isInlineValueEnabled;
    exports2.isSemanticTokensEnabled = isSemanticTokensEnabled;
    exports2.isCallHierarchyEnabled = isCallHierarchyEnabled;
    exports2.isTypeHierarchyEnabled = isTypeHierarchyEnabled;
    exports2.isRenameEnabled = isRenameEnabled;
    exports2.isDefinitionEnabled = isDefinitionEnabled;
    exports2.isTypeDefinitionEnabled = isTypeDefinitionEnabled;
    exports2.isReferencesEnabled = isReferencesEnabled;
    exports2.isImplementationEnabled = isImplementationEnabled;
    exports2.isHighlightEnabled = isHighlightEnabled;
    exports2.isSymbolsEnabled = isSymbolsEnabled;
    exports2.isFoldingRangesEnabled = isFoldingRangesEnabled;
    exports2.isSelectionRangesEnabled = isSelectionRangesEnabled;
    exports2.isLinkedEditingEnabled = isLinkedEditingEnabled;
    exports2.isColorEnabled = isColorEnabled;
    exports2.isDocumentLinkEnabled = isDocumentLinkEnabled;
    exports2.isDiagnosticsEnabled = isDiagnosticsEnabled;
    exports2.isCodeActionsEnabled = isCodeActionsEnabled;
    exports2.isFormattingEnabled = isFormattingEnabled;
    exports2.isCompletionEnabled = isCompletionEnabled;
    exports2.isAutoInsertEnabled = isAutoInsertEnabled;
    exports2.isSignatureHelpEnabled = isSignatureHelpEnabled;
    exports2.shouldReportDiagnostics = shouldReportDiagnostics;
    exports2.resolveRenameNewName = resolveRenameNewName;
    exports2.resolveRenameEditText = resolveRenameEditText;
    exports2.findOverlapCodeRange = findOverlapCodeRange;
    function isHoverEnabled(info) {
      return !!info.semantic;
    }
    function isInlayHintsEnabled(info) {
      return !!info.semantic;
    }
    function isCodeLensEnabled(info) {
      return !!info.semantic;
    }
    function isMonikerEnabled(info) {
      return !!info.semantic;
    }
    function isInlineValueEnabled(info) {
      return !!info.semantic;
    }
    function isSemanticTokensEnabled(info) {
      return typeof info.semantic === "object" ? info.semantic.shouldHighlight?.() ?? true : !!info.semantic;
    }
    function isCallHierarchyEnabled(info) {
      return !!info.navigation;
    }
    function isTypeHierarchyEnabled(info) {
      return !!info.navigation;
    }
    function isRenameEnabled(info) {
      return typeof info.navigation === "object" ? info.navigation.shouldRename?.() ?? true : !!info.navigation;
    }
    function isDefinitionEnabled(info) {
      return !!info.navigation;
    }
    function isTypeDefinitionEnabled(info) {
      return !!info.navigation;
    }
    function isReferencesEnabled(info) {
      return !!info.navigation;
    }
    function isImplementationEnabled(info) {
      return !!info.navigation;
    }
    function isHighlightEnabled(info) {
      return typeof info.navigation === "object" ? info.navigation.shouldHighlight?.() ?? true : !!info.navigation;
    }
    function isSymbolsEnabled(info) {
      return !!info.structure;
    }
    function isFoldingRangesEnabled(info) {
      return !!info.structure;
    }
    function isSelectionRangesEnabled(info) {
      return !!info.structure;
    }
    function isLinkedEditingEnabled(info) {
      return !!info.structure;
    }
    function isColorEnabled(info) {
      return !!info.structure;
    }
    function isDocumentLinkEnabled(info) {
      return !!info.structure;
    }
    function isDiagnosticsEnabled(info) {
      return !!info.verification;
    }
    function isCodeActionsEnabled(info) {
      return !!info.verification;
    }
    function isFormattingEnabled(info) {
      return !!info.format;
    }
    function isCompletionEnabled(info) {
      return !!info.completion;
    }
    function isAutoInsertEnabled(info) {
      return !!info.completion;
    }
    function isSignatureHelpEnabled(info) {
      return !!info.completion;
    }
    function shouldReportDiagnostics(info, source, code) {
      return typeof info.verification === "object" ? info.verification.shouldReport?.(source, code) ?? true : !!info.verification;
    }
    function resolveRenameNewName(newName, info) {
      return typeof info.navigation === "object" ? info.navigation.resolveRenameNewName?.(newName) ?? newName : newName;
    }
    function resolveRenameEditText(text, info) {
      return typeof info.navigation === "object" ? info.navigation.resolveRenameEditText?.(text) ?? text : text;
    }
    function findOverlapCodeRange(start, end, map, filter) {
      let mappedStart;
      let mappedEnd;
      for (const [mapped, mapping] of map.toGeneratedLocation(start)) {
        if (filter(mapping.data)) {
          mappedStart = mapped;
          break;
        }
      }
      for (const [mapped, mapping] of map.toGeneratedLocation(end)) {
        if (filter(mapping.data)) {
          mappedEnd = mapped;
          break;
        }
      }
      if (mappedStart === void 0 || mappedEnd === void 0) {
        for (const mapping of map.mappings) {
          if (filter(mapping.data)) {
            const mappingStart = mapping.sourceOffsets[0];
            const mappingEnd = mapping.sourceOffsets[mapping.sourceOffsets.length - 1] + mapping.lengths[mapping.lengths.length - 1];
            const overlap = getOverlapRange(start, end, mappingStart, mappingEnd);
            if (overlap) {
              const curMappedStart = overlap.start - mappingStart + mapping.generatedOffsets[0];
              const lastGeneratedLength = (mapping.generatedLengths ?? mapping.lengths)[mapping.generatedOffsets.length - 1];
              const curMappedEndOffset = Math.min(overlap.end - mapping.sourceOffsets[mapping.sourceOffsets.length - 1], lastGeneratedLength);
              const curMappedEnd = mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + curMappedEndOffset;
              mappedStart = mappedStart === void 0 ? curMappedStart : Math.min(mappedStart, curMappedStart);
              mappedEnd = mappedEnd === void 0 ? curMappedEnd : Math.max(mappedEnd, curMappedEnd);
            }
          }
        }
      }
      if (mappedStart !== void 0 && mappedEnd !== void 0) {
        return {
          start: mappedStart,
          end: mappedEnd
        };
      }
    }
    function getOverlapRange(range1Start, range1End, range2Start, range2End) {
      const start = Math.max(range1Start, range2Start);
      const end = Math.min(range1End, range2End);
      if (start > end) {
        return void 0;
      }
      return {
        start,
        end
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/lib/linkedCodeMap.js
var require_linkedCodeMap = __commonJS({
  "node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/lib/linkedCodeMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedCodeMap = void 0;
    var source_map_1 = require_source_map();
    var LinkedCodeMap = class extends source_map_1.SourceMap {
      *getLinkedOffsets(start) {
        for (const mapped of this.toGeneratedLocation(start)) {
          yield mapped[0];
        }
        for (const mapped of this.toSourceLocation(start)) {
          yield mapped[0];
        }
      }
    };
    exports2.LinkedCodeMap = LinkedCodeMap;
  }
});

// node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/lib/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileMap = void 0;
    var FileMap = class extends Map {
      constructor(caseSensitive) {
        super();
        this.caseSensitive = caseSensitive;
        this.originalFileNames = /* @__PURE__ */ new Map();
      }
      keys() {
        return this.originalFileNames.values();
      }
      get(key) {
        return super.get(this.normalizeId(key));
      }
      has(key) {
        return super.has(this.normalizeId(key));
      }
      set(key, value) {
        this.originalFileNames.set(this.normalizeId(key), key);
        return super.set(this.normalizeId(key), value);
      }
      delete(key) {
        this.originalFileNames.delete(this.normalizeId(key));
        return super.delete(this.normalizeId(key));
      }
      clear() {
        this.originalFileNames.clear();
        return super.clear();
      }
      normalizeId(id) {
        return this.caseSensitive ? id : id.toLowerCase();
      }
    };
    exports2.FileMap = FileMap;
  }
});

// node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/index.js
var require_language_core = __commonJS({
  "node_modules/.pnpm/@volar+language-core@2.4.26/node_modules/@volar/language-core/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultMapperFactory = exports2.SourceMap = void 0;
    exports2.createLanguage = createLanguage;
    exports2.forEachEmbeddedCode = forEachEmbeddedCode;
    var source_map_1 = require_source_map();
    Object.defineProperty(exports2, "SourceMap", { enumerable: true, get: function() {
      return source_map_1.SourceMap;
    } });
    __exportStar2(require_editor(), exports2);
    __exportStar2(require_linkedCodeMap(), exports2);
    __exportStar2(require_types(), exports2);
    __exportStar2(require_utils(), exports2);
    var source_map_2 = require_source_map();
    var linkedCodeMap_1 = require_linkedCodeMap();
    var defaultMapperFactory = (mappings) => new source_map_2.SourceMap(mappings);
    exports2.defaultMapperFactory = defaultMapperFactory;
    function createLanguage(plugins, scriptRegistry, sync, onAssociationDirty) {
      const virtualCodeToSourceScriptMap = /* @__PURE__ */ new WeakMap();
      const virtualCodeToSourceMap = /* @__PURE__ */ new WeakMap();
      const virtualCodeToLinkedCodeMap = /* @__PURE__ */ new WeakMap();
      const language = {
        mapperFactory: exports2.defaultMapperFactory,
        plugins,
        scripts: {
          fromVirtualCode(virtualCode) {
            return virtualCodeToSourceScriptMap.get(virtualCode);
          },
          get(id, includeFsFiles = true, shouldRegister = false) {
            sync(id, includeFsFiles, shouldRegister);
            const result = scriptRegistry.get(id);
            if (result?.isAssociationDirty) {
              this.set(id, result.snapshot, result.languageId);
            }
            return scriptRegistry.get(id);
          },
          set(id, snapshot, languageId, _plugins = plugins) {
            if (!languageId) {
              for (const plugin of plugins) {
                languageId = plugin.getLanguageId?.(id);
                if (languageId) {
                  break;
                }
              }
            }
            if (!languageId) {
              console.warn(`languageId not found for ${String(id)}`);
              return;
            }
            let associatedOnly = false;
            for (const plugin of plugins) {
              if (plugin.isAssociatedFileOnly?.(id, languageId)) {
                associatedOnly = true;
                break;
              }
            }
            if (scriptRegistry.has(id)) {
              const sourceScript = scriptRegistry.get(id);
              if (sourceScript.languageId !== languageId || sourceScript.associatedOnly !== associatedOnly) {
                this.delete(id);
                triggerTargetsDirty(sourceScript);
                return this.set(id, snapshot, languageId);
              } else if (associatedOnly) {
                if (sourceScript.snapshot !== snapshot) {
                  sourceScript.snapshot = snapshot;
                  triggerTargetsDirty(sourceScript);
                }
              } else if (sourceScript.isAssociationDirty || sourceScript.snapshot !== snapshot) {
                if (sourceScript.snapshot !== snapshot) {
                  sourceScript.snapshot = snapshot;
                  triggerTargetsDirty(sourceScript);
                }
                const codegenCtx = prepareCreateVirtualCode(sourceScript);
                if (sourceScript.generated) {
                  const { updateVirtualCode, createVirtualCode } = sourceScript.generated.languagePlugin;
                  const newVirtualCode = updateVirtualCode ? updateVirtualCode(id, sourceScript.generated.root, snapshot, codegenCtx) : createVirtualCode?.(id, languageId, snapshot, codegenCtx);
                  if (newVirtualCode) {
                    sourceScript.generated.root = newVirtualCode;
                    sourceScript.generated.embeddedCodes.clear();
                    for (const code of forEachEmbeddedCode(sourceScript.generated.root)) {
                      virtualCodeToSourceScriptMap.set(code, sourceScript);
                      sourceScript.generated.embeddedCodes.set(code.id, code);
                    }
                    return sourceScript;
                  } else {
                    this.delete(id);
                    return;
                  }
                }
              } else {
                return sourceScript;
              }
            } else {
              const sourceScript = {
                id,
                languageId,
                snapshot,
                associatedIds: /* @__PURE__ */ new Set(),
                targetIds: /* @__PURE__ */ new Set(),
                associatedOnly
              };
              scriptRegistry.set(id, sourceScript);
              if (associatedOnly) {
                return sourceScript;
              }
              for (const languagePlugin of _plugins) {
                const virtualCode = languagePlugin.createVirtualCode?.(id, languageId, snapshot, prepareCreateVirtualCode(sourceScript));
                if (virtualCode) {
                  sourceScript.generated = {
                    root: virtualCode,
                    languagePlugin,
                    embeddedCodes: /* @__PURE__ */ new Map()
                  };
                  for (const code of forEachEmbeddedCode(virtualCode)) {
                    virtualCodeToSourceScriptMap.set(code, sourceScript);
                    sourceScript.generated.embeddedCodes.set(code.id, code);
                  }
                  break;
                }
              }
              return sourceScript;
            }
          },
          delete(id) {
            const sourceScript = scriptRegistry.get(id);
            if (sourceScript) {
              sourceScript.generated?.languagePlugin.disposeVirtualCode?.(id, sourceScript.generated.root);
              scriptRegistry.delete(id);
              triggerTargetsDirty(sourceScript);
            }
          }
        },
        maps: {
          get(virtualCode, sourceScript) {
            let mapCache = virtualCodeToSourceMap.get(virtualCode.snapshot);
            if (!mapCache) {
              virtualCodeToSourceMap.set(virtualCode.snapshot, mapCache = /* @__PURE__ */ new WeakMap());
            }
            if (!mapCache.has(sourceScript.snapshot)) {
              const mappings = virtualCode.associatedScriptMappings?.get(sourceScript.id) ?? virtualCode.mappings;
              mapCache.set(sourceScript.snapshot, language.mapperFactory(mappings));
            }
            return mapCache.get(sourceScript.snapshot);
          },
          *forEach(virtualCode) {
            const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
            yield [
              sourceScript,
              this.get(virtualCode, sourceScript)
            ];
            if (virtualCode.associatedScriptMappings) {
              for (const [relatedScriptId] of virtualCode.associatedScriptMappings) {
                const relatedSourceScript = scriptRegistry.get(relatedScriptId);
                if (relatedSourceScript) {
                  yield [
                    relatedSourceScript,
                    this.get(virtualCode, relatedSourceScript)
                  ];
                }
              }
            }
          }
        },
        linkedCodeMaps: {
          get(virtualCode) {
            const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
            let mapCache = virtualCodeToLinkedCodeMap.get(virtualCode.snapshot);
            if (mapCache?.[0] !== sourceScript.snapshot) {
              virtualCodeToLinkedCodeMap.set(virtualCode.snapshot, mapCache = [
                sourceScript.snapshot,
                virtualCode.linkedCodeMappings ? new linkedCodeMap_1.LinkedCodeMap(virtualCode.linkedCodeMappings) : void 0
              ]);
            }
            return mapCache[1];
          }
        }
      };
      return language;
      function triggerTargetsDirty(sourceScript) {
        sourceScript.targetIds.forEach((id) => {
          const sourceScript2 = scriptRegistry.get(id);
          if (sourceScript2) {
            sourceScript2.isAssociationDirty = true;
            onAssociationDirty?.(sourceScript2.id);
          }
        });
      }
      function prepareCreateVirtualCode(sourceScript) {
        for (const id of sourceScript.associatedIds) {
          scriptRegistry.get(id)?.targetIds.delete(sourceScript.id);
        }
        sourceScript.associatedIds.clear();
        sourceScript.isAssociationDirty = false;
        return {
          getAssociatedScript(id) {
            sync(id, true, true);
            const relatedSourceScript = scriptRegistry.get(id);
            if (relatedSourceScript) {
              relatedSourceScript.targetIds.add(sourceScript.id);
              sourceScript.associatedIds.add(relatedSourceScript.id);
            }
            return relatedSourceScript;
          }
        };
      }
    }
    function* forEachEmbeddedCode(virtualCode) {
      yield virtualCode;
      if (virtualCode.embeddedCodes) {
        for (const embeddedCode of virtualCode.embeddedCodes) {
          yield* forEachEmbeddedCode(embeddedCode);
        }
      }
    }
  }
});

// node_modules/.pnpm/vscode-uri@3.1.0/node_modules/vscode-uri/lib/umd/index.js
var require_umd = __commonJS({
  "node_modules/.pnpm/vscode-uri@3.1.0/node_modules/vscode-uri/lib/umd/index.js"(exports2, module2) {
    "use strict";
    !(function(t, e) {
      if ("object" == typeof exports2 && "object" == typeof module2) module2.exports = e();
      else if ("function" == typeof define && define.amd) define([], e);
      else {
        var r = e();
        for (var n in r) ("object" == typeof exports2 ? exports2 : t)[n] = r[n];
      }
    })(exports2, (() => (() => {
      "use strict";
      var t = { 975: (t2) => {
        function e2(t3) {
          if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n3 = "", i = 0, o = -1, s = 0, a = 0; a <= t3.length; ++a) {
            if (a < t3.length) r3 = t3.charCodeAt(a);
            else {
              if (47 === r3) break;
              r3 = 47;
            }
            if (47 === r3) {
              if (o === a - 1 || 1 === s) ;
              else if (o !== a - 1 && 2 === s) {
                if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                  if (n3.length > 2) {
                    var h = n3.lastIndexOf("/");
                    if (h !== n3.length - 1) {
                      -1 === h ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, h)).length - 1 - n3.lastIndexOf("/"), o = a, s = 0;
                      continue;
                    }
                  } else if (2 === n3.length || 1 === n3.length) {
                    n3 = "", i = 0, o = a, s = 0;
                    continue;
                  }
                }
                e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
              } else n3.length > 0 ? n3 += "/" + t3.slice(o + 1, a) : n3 = t3.slice(o + 1, a), i = a - o - 1;
              o = a, s = 0;
            } else 46 === r3 && -1 !== s ? ++s : s = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
            var s;
            o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
          }
          return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(t3) {
          if (e2(t3), 0 === t3.length) return ".";
          var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
          return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length) return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var i = arguments[r3];
            e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
          }
          return void 0 === t3 ? "." : n2.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3) return "";
          if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
          for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i) ;
          for (var o = t3.length, s = o - i, a = 1; a < r3.length && 47 === r3.charCodeAt(a); ++a) ;
          for (var h = r3.length - a, c = s < h ? s : h, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (h > c) {
                if (47 === r3.charCodeAt(a + u)) return r3.slice(a + u + 1);
                if (0 === u) return r3.slice(a + u);
              } else s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
              break;
            }
            var l = t3.charCodeAt(i + u);
            if (l !== r3.charCodeAt(a + u)) break;
            47 === l && (f = u);
          }
          var d = "";
          for (u = i + f + 1; u <= o; ++u) u !== o && 47 !== t3.charCodeAt(u) || (0 === d.length ? d += ".." : d += "/..");
          return d.length > 0 ? d + r3.slice(a + f) : (a += f, 47 === r3.charCodeAt(a) && ++a, r3.slice(a));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), 0 === t3.length) return ".";
          for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s) if (47 === (r3 = t3.charCodeAt(s))) {
            if (!o) {
              i = s;
              break;
            }
          } else o = false;
          return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
        }, basename: function(t3, r3) {
          if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n3, i = 0, o = -1, s = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3) return "";
            var a = r3.length - 1, h = -1;
            for (n3 = t3.length - 1; n3 >= 0; --n3) {
              var c = t3.charCodeAt(n3);
              if (47 === c) {
                if (!s) {
                  i = n3 + 1;
                  break;
                }
              } else -1 === h && (s = false, h = n3 + 1), a >= 0 && (c === r3.charCodeAt(a) ? -1 == --a && (o = n3) : (a = -1, o = h));
            }
            return i === o ? o = h : -1 === o && (o = t3.length), t3.slice(i, o);
          }
          for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else -1 === o && (s = false, o = n3 + 1);
          return -1 === o ? "" : t3.slice(i, o);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, a = t3.length - 1; a >= 0; --a) {
            var h = t3.charCodeAt(a);
            if (47 !== h) -1 === i && (o = false, i = a + 1), 46 === h ? -1 === r3 ? r3 = a : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
            else if (!o) {
              n3 = a + 1;
              break;
            }
          }
          return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
        }, format: function(t3) {
          if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return (function(t4, e3) {
            var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
          })(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t3.length) return r3;
          var n3, i = t3.charCodeAt(0), o = 47 === i;
          o ? (r3.root = "/", n3 = 1) : n3 = 0;
          for (var s = -1, a = 0, h = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f) if (47 !== (i = t3.charCodeAt(f))) -1 === h && (c = false, h = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
          else if (!c) {
            a = f + 1;
            break;
          }
          return -1 === s || -1 === h || 0 === u || 1 === u && s === h - 1 && s === a + 1 ? -1 !== h && (r3.base = r3.name = 0 === a && o ? t3.slice(1, h) : t3.slice(a, h)) : (0 === a && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, h)) : (r3.name = t3.slice(a, s), r3.base = t3.slice(a, h)), r3.ext = t3.slice(s, h)), a > 0 ? r3.dir = t3.slice(0, a - 1) : o && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, t2.exports = n2;
      }, 70: (t2, e2) => {
        if (Object.defineProperty(e2, "__esModule", { value: true }), e2.isWindows = void 0, "object" == typeof process) e2.isWindows = "win32" === process.platform;
        else if ("object" == typeof navigator) {
          let t3 = navigator.userAgent;
          e2.isWindows = t3.indexOf("Windows") >= 0;
        }
      }, 231: (t2, e2, r2) => {
        Object.defineProperty(e2, "__esModule", { value: true }), e2.uriToFsPath = e2.URI = void 0;
        const n2 = r2(70), i = /^\w[\w\d+.-]*$/, o = /^\//, s = /^\/\//;
        function a(t3, e3) {
          if (!t3.scheme && e3) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
          if (t3.scheme && !i.test(t3.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!o.test(t3.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (s.test(t3.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        const h = "", c = "/", f = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
        class u {
          static isUri(t3) {
            return t3 instanceof u || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
          }
          scheme;
          authority;
          path;
          query;
          fragment;
          constructor(t3, e3, r3, n3, i2, o2 = false) {
            "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ (function(t4, e4) {
              return t4 || e4 ? t4 : "file";
            })(t3, o2), this.authority = e3 || h, this.path = (function(t4, e4) {
              switch (t4) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== c && (e4 = c + e4) : e4 = c;
              }
              return e4;
            })(this.scheme, r3 || h), this.query = n3 || h, this.fragment = i2 || h, a(this, o2));
          }
          get fsPath() {
            return v(this, false);
          }
          with(t3) {
            if (!t3) return this;
            let { scheme: e3, authority: r3, path: n3, query: i2, fragment: o2 } = t3;
            return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r3 ? r3 = this.authority : null === r3 && (r3 = h), void 0 === n3 ? n3 = this.path : null === n3 && (n3 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r3 === this.authority && n3 === this.path && i2 === this.query && o2 === this.fragment ? this : new d(e3, r3, n3, i2, o2);
          }
          static parse(t3, e3 = false) {
            const r3 = f.exec(t3);
            return r3 ? new d(r3[2] || h, w(r3[4] || h), w(r3[5] || h), w(r3[7] || h), w(r3[9] || h), e3) : new d(h, h, h, h, h);
          }
          static file(t3) {
            let e3 = h;
            if (n2.isWindows && (t3 = t3.replace(/\\/g, c)), t3[0] === c && t3[1] === c) {
              const r3 = t3.indexOf(c, 2);
              -1 === r3 ? (e3 = t3.substring(2), t3 = c) : (e3 = t3.substring(2, r3), t3 = t3.substring(r3) || c);
            }
            return new d("file", e3, t3, h, h);
          }
          static from(t3) {
            const e3 = new d(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
            return a(e3, true), e3;
          }
          toString(t3 = false) {
            return y(this, t3);
          }
          toJSON() {
            return this;
          }
          static revive(t3) {
            if (t3) {
              if (t3 instanceof u) return t3;
              {
                const e3 = new d(t3);
                return e3._formatted = t3.external, e3._fsPath = t3._sep === l ? t3.fsPath : null, e3;
              }
            }
            return t3;
          }
        }
        e2.URI = u;
        const l = n2.isWindows ? 1 : void 0;
        class d extends u {
          _formatted = null;
          _fsPath = null;
          get fsPath() {
            return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
          }
          toString(t3 = false) {
            return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
          }
          toJSON() {
            const t3 = { $mid: 1 };
            return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = l), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
          }
        }
        const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
        function g(t3, e3, r3) {
          let n3, i2 = -1;
          for (let o2 = 0; o2 < t3.length; o2++) {
            const s2 = t3.charCodeAt(o2);
            if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r3 && 91 === s2 || r3 && 93 === s2 || r3 && 58 === s2) -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n3 && (n3 += t3.charAt(o2));
            else {
              void 0 === n3 && (n3 = t3.substr(0, o2));
              const e4 = p[s2];
              void 0 !== e4 ? (-1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n3 += e4) : -1 === i2 && (i2 = o2);
            }
          }
          return -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2))), void 0 !== n3 ? n3 : t3;
        }
        function m(t3) {
          let e3;
          for (let r3 = 0; r3 < t3.length; r3++) {
            const n3 = t3.charCodeAt(r3);
            35 === n3 || 63 === n3 ? (void 0 === e3 && (e3 = t3.substr(0, r3)), e3 += p[n3]) : void 0 !== e3 && (e3 += t3[r3]);
          }
          return void 0 !== e3 ? e3 : t3;
        }
        function v(t3, e3) {
          let r3;
          return r3 = t3.authority && t3.path.length > 1 && "file" === t3.scheme ? `//${t3.authority}${t3.path}` : 47 === t3.path.charCodeAt(0) && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n2.isWindows && (r3 = r3.replace(/\//g, "\\")), r3;
        }
        function y(t3, e3) {
          const r3 = e3 ? m : g;
          let n3 = "", { scheme: i2, authority: o2, path: s2, query: a2, fragment: h2 } = t3;
          if (i2 && (n3 += i2, n3 += ":"), (o2 || "file" === i2) && (n3 += c, n3 += c), o2) {
            let t4 = o2.indexOf("@");
            if (-1 !== t4) {
              const e4 = o2.substr(0, t4);
              o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n3 += r3(e4, false, false) : (n3 += r3(e4.substr(0, t4), false, false), n3 += ":", n3 += r3(e4.substr(t4 + 1), false, true)), n3 += "@";
            }
            o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n3 += r3(o2, false, true) : (n3 += r3(o2.substr(0, t4), false, true), n3 += o2.substr(t4));
          }
          if (s2) {
            if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
              const t4 = s2.charCodeAt(1);
              t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
            } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
              const t4 = s2.charCodeAt(0);
              t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
            }
            n3 += r3(s2, true, false);
          }
          return a2 && (n3 += "?", n3 += r3(a2, false, false)), h2 && (n3 += "#", n3 += e3 ? h2 : g(h2, false, false)), n3;
        }
        function b(t3) {
          try {
            return decodeURIComponent(t3);
          } catch {
            return t3.length > 3 ? t3.substr(0, 3) + b(t3.substr(3)) : t3;
          }
        }
        e2.uriToFsPath = v;
        const C = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function w(t3) {
          return t3.match(C) ? t3.replace(C, ((t4) => b(t4))) : t3;
        }
      }, 552: function(t2, e2, r2) {
        var n2 = this && this.__createBinding || (Object.create ? function(t3, e3, r3, n3) {
          void 0 === n3 && (n3 = r3);
          var i2 = Object.getOwnPropertyDescriptor(e3, r3);
          i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return e3[r3];
          } }), Object.defineProperty(t3, n3, i2);
        } : function(t3, e3, r3, n3) {
          void 0 === n3 && (n3 = r3), t3[n3] = e3[r3];
        }), i = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
          Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
        } : function(t3, e3) {
          t3.default = e3;
        }), o = this && this.__importStar || function(t3) {
          if (t3 && t3.__esModule) return t3;
          var e3 = {};
          if (null != t3) for (var r3 in t3) "default" !== r3 && Object.prototype.hasOwnProperty.call(t3, r3) && n2(e3, t3, r3);
          return i(e3, t3), e3;
        };
        Object.defineProperty(e2, "__esModule", { value: true }), e2.Utils = void 0;
        const s = o(r2(975)), a = s.posix || s, h = "/";
        var c;
        !(function(t3) {
          t3.joinPath = function(t4, ...e3) {
            return t4.with({ path: a.join(t4.path, ...e3) });
          }, t3.resolvePath = function(t4, ...e3) {
            let r3 = t4.path, n3 = false;
            r3[0] !== h && (r3 = h + r3, n3 = true);
            let i2 = a.resolve(r3, ...e3);
            return n3 && i2[0] === h && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
          }, t3.dirname = function(t4) {
            if (0 === t4.path.length || t4.path === h) return t4;
            let e3 = a.dirname(t4.path);
            return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
          }, t3.basename = function(t4) {
            return a.basename(t4.path);
          }, t3.extname = function(t4) {
            return a.extname(t4.path);
          };
        })(c || (e2.Utils = c = {}));
      } }, e = {};
      function r(n2) {
        var i = e[n2];
        if (void 0 !== i) return i.exports;
        var o = e[n2] = { exports: {} };
        return t[n2].call(o.exports, o, o.exports, r), o.exports;
      }
      var n = {};
      return (() => {
        var t2 = n;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Utils = t2.URI = void 0;
        const e2 = r(231);
        Object.defineProperty(t2, "URI", { enumerable: true, get: function() {
          return e2.URI;
        } });
        const i = r(552);
        Object.defineProperty(t2, "Utils", { enumerable: true, get: function() {
          return i.Utils;
        } });
      })(), n;
    })()));
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/cancellation.js
var require_cancellation2 = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoneCancellationToken = void 0;
    exports2.NoneCancellationToken = {
      isCancellationRequested: false,
      onCancellationRequested: () => ({ dispose: () => {
      } })
    };
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/dedupe.js
var require_dedupe = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/dedupe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLocationSet = createLocationSet;
    exports2.withCodeAction = withCodeAction;
    exports2.withTextEdits = withTextEdits;
    exports2.withDocumentChanges = withDocumentChanges;
    exports2.withDiagnostics = withDiagnostics;
    exports2.withLocations = withLocations;
    exports2.withLocationLinks = withLocationLinks;
    exports2.withCallHierarchyIncomingCalls = withCallHierarchyIncomingCalls;
    exports2.withCallHierarchyOutgoingCalls = withCallHierarchyOutgoingCalls;
    exports2.withRanges = withRanges;
    function createLocationSet() {
      const set = /* @__PURE__ */ new Set();
      return {
        add,
        has
      };
      function add(item) {
        if (has(item)) {
          return false;
        }
        set.add(getKey(item));
        return true;
      }
      function has(item) {
        return set.has(getKey(item));
      }
      function getKey(item) {
        return [
          item.uri,
          item.range.start.line,
          item.range.start.character,
          item.range.end.line,
          item.range.end.character
        ].join(":");
      }
    }
    function withCodeAction(items) {
      return dedupe(items, (item) => [
        item.title
      ].join(":"));
    }
    function withTextEdits(items) {
      return dedupe(items, (item) => [
        item.range.start.line,
        item.range.start.character,
        item.range.end.line,
        item.range.end.character,
        item.newText
      ].join(":"));
    }
    function withDocumentChanges(items) {
      return dedupe(items, (item) => JSON.stringify(item));
    }
    function withDiagnostics(items) {
      return dedupe(items, (item) => [
        item.range.start.line,
        item.range.start.character,
        item.range.end.line,
        item.range.end.character,
        item.source,
        item.code,
        item.severity,
        item.message
      ].join(":"));
    }
    function withLocations(items) {
      return dedupe(items, (item) => [
        item.uri,
        item.range.start.line,
        item.range.start.character,
        item.range.end.line,
        item.range.end.character
      ].join(":"));
    }
    function withLocationLinks(items) {
      return dedupe(items, (item) => [
        item.targetUri,
        item.targetSelectionRange.start.line,
        item.targetSelectionRange.start.character,
        item.targetSelectionRange.end.line,
        item.targetSelectionRange.end.character
        // ignore difference targetRange
      ].join(":"));
    }
    function withCallHierarchyIncomingCalls(items) {
      return dedupe(items, (item) => [
        item.from.uri,
        item.from.range.start.line,
        item.from.range.start.character,
        item.from.range.end.line,
        item.from.range.end.character
      ].join(":"));
    }
    function withCallHierarchyOutgoingCalls(items) {
      return dedupe(items, (item) => [
        item.to.uri,
        item.to.range.start.line,
        item.to.range.start.character,
        item.to.range.end.line,
        item.to.range.end.character
      ].join(":"));
    }
    function withRanges(items) {
      return dedupe(items, (item) => [
        item.start.line,
        item.start.character,
        item.end.line,
        item.end.character
      ].join(":"));
    }
    function dedupe(items, getKey) {
      const map = /* @__PURE__ */ new Map();
      for (const item of items.reverse()) {
        map.set(getKey(item), item);
      }
      return [...map.values()];
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/featureWorkers.js
var require_featureWorkers = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/featureWorkers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.documentFeatureWorker = documentFeatureWorker;
    exports2.languageFeatureWorker = languageFeatureWorker;
    exports2.safeCall = safeCall;
    exports2.forEachEmbeddedDocument = forEachEmbeddedDocument;
    exports2.getSourceRange = getSourceRange;
    exports2.getGeneratedRange = getGeneratedRange;
    exports2.getSourceRanges = getSourceRanges;
    exports2.getGeneratedRanges = getGeneratedRanges;
    exports2.getSourcePositions = getSourcePositions;
    exports2.getGeneratedPositions = getGeneratedPositions;
    exports2.getLinkedCodePositions = getLinkedCodePositions;
    function documentFeatureWorker(context, uri, valid, worker, transformResult, combineResult) {
      return languageFeatureWorker(context, uri, () => void 0, function* (map) {
        if (valid(map)) {
          yield;
        }
      }, worker, transformResult, combineResult);
    }
    async function languageFeatureWorker(context, uri, getRealDocParams, eachVirtualDocParams, worker, transformResult, combineResult) {
      let sourceScript;
      const decoded = context.decodeEmbeddedDocumentUri(uri);
      if (decoded) {
        sourceScript = context.language.scripts.get(decoded[0]);
      } else {
        sourceScript = context.language.scripts.get(uri);
      }
      if (!sourceScript) {
        return;
      }
      let results = [];
      if (decoded) {
        const virtualCode = sourceScript.generated?.embeddedCodes.get(decoded[1]);
        if (virtualCode) {
          const docs = [
            context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot),
            context.documents.get(uri, virtualCode.languageId, virtualCode.snapshot),
            context.language.maps.get(virtualCode, sourceScript)
          ];
          await docsWorker(docs, false);
        }
      } else if (sourceScript.generated) {
        for (const docs of forEachEmbeddedDocument(context, sourceScript, sourceScript.generated.root)) {
          if (results.length && !combineResult) {
            continue;
          }
          await docsWorker(docs, true);
        }
      } else {
        const document = context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
        const params = getRealDocParams();
        for (const [pluginIndex, plugin] of Object.entries(context.plugins)) {
          if (context.disabledServicePlugins.has(plugin[1])) {
            continue;
          }
          const embeddedResult = await safeCall(() => worker(plugin, document, params, void 0), `Language service plugin "${plugin[0].name}" (${pluginIndex}) failed to provide document feature for ${document.uri}.`);
          if (!embeddedResult) {
            continue;
          }
          const result = transformResult(embeddedResult, void 0);
          if (!result) {
            continue;
          }
          results.push(result);
          if (!combineResult) {
            break;
          }
        }
      }
      if (combineResult && results.length > 0) {
        const combined = combineResult(results);
        return combined;
      } else if (results.length > 0) {
        return results[0];
      }
      async function docsWorker(docs, transform) {
        for (const mappedArg of eachVirtualDocParams(docs)) {
          if (results.length && !combineResult) {
            continue;
          }
          for (const [pluginIndex, plugin] of Object.entries(context.plugins)) {
            if (context.disabledServicePlugins.has(plugin[1])) {
              continue;
            }
            if (results.length && !combineResult) {
              continue;
            }
            const embeddedResult = await safeCall(() => worker(plugin, docs[1], mappedArg, docs), `Language service plugin "${plugin[0].name}" (${pluginIndex}) failed to provide document feature for ${docs[1].uri}.`);
            if (!embeddedResult) {
              continue;
            }
            if (transform) {
              const mappedResult = transformResult(embeddedResult, docs);
              if (mappedResult) {
                results.push(mappedResult);
              }
            } else {
              results.push(embeddedResult);
            }
          }
        }
      }
    }
    async function safeCall(cb, errorMsg) {
      try {
        return await cb();
      } catch (err) {
        console.warn(errorMsg, err);
      }
    }
    function* forEachEmbeddedDocument(context, sourceScript, current) {
      if (current.embeddedCodes) {
        for (const embeddedCode of current.embeddedCodes) {
          yield* forEachEmbeddedDocument(context, sourceScript, embeddedCode);
        }
      }
      const embeddedDocumentUri = context.encodeEmbeddedDocumentUri(sourceScript.id, current.id);
      if (!context.disabledEmbeddedDocumentUris.get(embeddedDocumentUri)) {
        yield [
          context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot),
          context.documents.get(embeddedDocumentUri, current.languageId, current.snapshot),
          context.language.maps.get(current, sourceScript)
        ];
      }
    }
    function getSourceRange(docs, range, filter) {
      for (const result of getSourceRanges(docs, range, filter)) {
        return result;
      }
    }
    function getGeneratedRange(docs, range, filter) {
      for (const result of getGeneratedRanges(docs, range, filter)) {
        return result;
      }
    }
    function* getSourceRanges([sourceDocument, embeddedDocument, map], range, filter) {
      for (const [mappedStart, mappedEnd] of map.toSourceRange(embeddedDocument.offsetAt(range.start), embeddedDocument.offsetAt(range.end), true, filter)) {
        yield { start: sourceDocument.positionAt(mappedStart), end: sourceDocument.positionAt(mappedEnd) };
      }
    }
    function* getGeneratedRanges([sourceDocument, embeddedDocument, map], range, filter) {
      for (const [mappedStart, mappedEnd] of map.toGeneratedRange(sourceDocument.offsetAt(range.start), sourceDocument.offsetAt(range.end), true, filter)) {
        yield { start: embeddedDocument.positionAt(mappedStart), end: embeddedDocument.positionAt(mappedEnd) };
      }
    }
    function* getSourcePositions([sourceDocument, embeddedDocument, map], position, filter = () => true) {
      for (const mapped of map.toSourceLocation(embeddedDocument.offsetAt(position), filter)) {
        yield sourceDocument.positionAt(mapped[0]);
      }
    }
    function* getGeneratedPositions([sourceDocument, embeddedDocument, map], position, filter = () => true) {
      for (const mapped of map.toGeneratedLocation(sourceDocument.offsetAt(position), filter)) {
        yield embeddedDocument.positionAt(mapped[0]);
      }
    }
    function* getLinkedCodePositions(document, linkedMap, posotion) {
      for (const linkedPosition of linkedMap.getLinkedOffsets(document.offsetAt(posotion))) {
        yield document.positionAt(linkedPosition);
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/transform.js
var require_transform = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/transform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transformDocumentLinkTarget = transformDocumentLinkTarget;
    exports2.transformMarkdown = transformMarkdown;
    exports2.transformCompletionItem = transformCompletionItem;
    exports2.transformCompletionList = transformCompletionList;
    exports2.transformDocumentSymbol = transformDocumentSymbol;
    exports2.transformFoldingRanges = transformFoldingRanges;
    exports2.transformHover = transformHover;
    exports2.transformLocation = transformLocation;
    exports2.transformLocations = transformLocations;
    exports2.transformSelectionRange = transformSelectionRange;
    exports2.transformSelectionRanges = transformSelectionRanges;
    exports2.transformTextEdit = transformTextEdit;
    exports2.transformWorkspaceSymbol = transformWorkspaceSymbol;
    exports2.transformWorkspaceEdit = transformWorkspaceEdit;
    exports2.pushEditToDocumentChanges = pushEditToDocumentChanges;
    var language_core_1 = require_language_core();
    var vscode_uri_1 = require_umd();
    var featureWorkers_1 = require_featureWorkers();
    function transformDocumentLinkTarget(_target, context) {
      let target = vscode_uri_1.URI.parse(_target);
      const decoded = context.decodeEmbeddedDocumentUri(target);
      if (!decoded) {
        return target;
      }
      const embeddedRange = target.fragment.match(/^L(\d+)(,(\d+))?(-L(\d+)(,(\d+))?)?$/);
      const sourceScript = context.language.scripts.get(decoded[0]);
      const virtualCode = sourceScript?.generated?.embeddedCodes.get(decoded[1]);
      target = decoded[0];
      if (embeddedRange && sourceScript && virtualCode) {
        const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
        for (const [sourceScript2, map] of context.language.maps.forEach(virtualCode)) {
          if (!map.mappings.some((mapping) => (0, language_core_1.isDocumentLinkEnabled)(mapping.data))) {
            continue;
          }
          const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
          const docs = [sourceDocument, embeddedDocument, map];
          const startLine = Number(embeddedRange[1]) - 1;
          const startCharacter = Number(embeddedRange[3] ?? 1) - 1;
          if (embeddedRange[5] !== void 0) {
            const endLine = Number(embeddedRange[5]) - 1;
            const endCharacter = Number(embeddedRange[7] ?? 1) - 1;
            const sourceRange = (0, featureWorkers_1.getSourceRange)(docs, {
              start: { line: startLine, character: startCharacter },
              end: { line: endLine, character: endCharacter }
            });
            if (sourceRange) {
              target = target.with({
                fragment: "L" + (sourceRange.start.line + 1) + "," + (sourceRange.start.character + 1) + "-L" + (sourceRange.end.line + 1) + "," + (sourceRange.end.character + 1)
              });
              break;
            }
          } else {
            let mapped = false;
            for (const sourcePos of (0, featureWorkers_1.getSourcePositions)(docs, { line: startLine, character: startCharacter })) {
              mapped = true;
              target = target.with({
                fragment: "L" + (sourcePos.line + 1) + "," + (sourcePos.character + 1)
              });
              break;
            }
            if (mapped) {
              break;
            }
          }
        }
      }
      return target;
    }
    function transformMarkdown(content, context) {
      return content.replace(/(?!\()volar-embedded-content:\/\/\w+\/[^)]+/g, (match) => {
        const segments = match.split("|");
        segments[0] = transformDocumentLinkTarget(segments[0], context).toString();
        return segments.join("|");
      });
    }
    function transformCompletionItem(item, getOtherRange, document, context) {
      return {
        ...item,
        additionalTextEdits: item.additionalTextEdits?.map((edit) => transformTextEdit(edit, getOtherRange, document)).filter((edit) => !!edit),
        textEdit: item.textEdit ? transformTextEdit(item.textEdit, getOtherRange, document) : void 0,
        documentation: item.documentation ? typeof item.documentation === "string" ? transformMarkdown(item.documentation, context) : item.documentation.kind === "markdown" ? { kind: "markdown", value: transformMarkdown(item.documentation.value, context) } : item.documentation : void 0
      };
    }
    function transformCompletionList(completionList, getOtherRange, document, context) {
      return {
        isIncomplete: completionList.isIncomplete,
        itemDefaults: completionList.itemDefaults ? {
          ...completionList.itemDefaults,
          editRange: completionList.itemDefaults.editRange ? "replace" in completionList.itemDefaults.editRange ? {
            insert: getOtherRange(completionList.itemDefaults.editRange.insert),
            replace: getOtherRange(completionList.itemDefaults.editRange.replace)
          } : getOtherRange(completionList.itemDefaults.editRange) : void 0
        } : void 0,
        items: completionList.items.map((item) => transformCompletionItem(item, getOtherRange, document, context))
      };
    }
    function transformDocumentSymbol(symbol, getOtherRange) {
      const range = getOtherRange(symbol.range);
      if (!range) {
        return;
      }
      const selectionRange = getOtherRange(symbol.selectionRange);
      if (!selectionRange) {
        return;
      }
      return {
        ...symbol,
        range,
        selectionRange,
        children: symbol.children?.map((child) => transformDocumentSymbol(child, getOtherRange)).filter((child) => !!child)
      };
    }
    function transformFoldingRanges(ranges, getOtherRange) {
      const result = [];
      for (const range of ranges) {
        const otherRange = getOtherRange({
          start: { line: range.startLine, character: range.startCharacter ?? 0 },
          end: { line: range.endLine, character: range.endCharacter ?? 0 }
        });
        if (otherRange) {
          range.startLine = otherRange.start.line;
          range.endLine = otherRange.end.line;
          if (range.startCharacter !== void 0) {
            range.startCharacter = otherRange.start.character;
          }
          if (range.endCharacter !== void 0) {
            range.endCharacter = otherRange.end.character;
          }
          result.push(range);
        }
      }
      return result;
    }
    function transformHover(hover, getOtherRange) {
      if (!hover?.range) {
        return hover;
      }
      const range = getOtherRange(hover.range);
      if (!range) {
        return;
      }
      return {
        ...hover,
        range
      };
    }
    function transformLocation(location, getOtherRange) {
      const range = getOtherRange(location.range);
      if (!range) {
        return;
      }
      return {
        ...location,
        range
      };
    }
    function transformLocations(locations, getOtherRange) {
      return locations.map((location) => transformLocation(location, getOtherRange)).filter((location) => !!location);
    }
    function transformSelectionRange(location, getOtherRange) {
      const range = getOtherRange(location.range);
      if (!range) {
        return;
      }
      const parent = location.parent ? transformSelectionRange(location.parent, getOtherRange) : void 0;
      return {
        range,
        parent
      };
    }
    function transformSelectionRanges(locations, getOtherRange) {
      return locations.map((location) => transformSelectionRange(location, getOtherRange)).filter((location) => !!location);
    }
    function transformTextEdit(textEdit, getOtherRange, document) {
      if ("range" in textEdit) {
        let range = getOtherRange(textEdit.range);
        if (range) {
          return {
            ...textEdit,
            range
          };
        }
        const cover = tryRecoverTextEdit(getOtherRange, textEdit.range, textEdit.newText, document);
        if (cover) {
          return {
            ...textEdit,
            range: cover.range,
            newText: cover.newText
          };
        }
      } else if ("replace" in textEdit && "insert" in textEdit) {
        const insert = getOtherRange(textEdit.insert);
        const replace = insert ? getOtherRange(textEdit.replace) : void 0;
        if (insert && replace) {
          return {
            ...textEdit,
            insert,
            replace
          };
        }
        const recoverInsert = tryRecoverTextEdit(getOtherRange, textEdit.insert, textEdit.newText, document);
        const recoverReplace = recoverInsert ? tryRecoverTextEdit(getOtherRange, textEdit.replace, textEdit.newText, document) : void 0;
        if (recoverInsert && recoverReplace && recoverInsert.newText === recoverReplace.newText) {
          return {
            ...textEdit,
            insert: recoverInsert.range,
            replace: recoverReplace.range,
            newText: recoverInsert.newText
          };
        }
      }
    }
    function tryRecoverTextEdit(getOtherRange, replaceRange, newText, document) {
      if (replaceRange.start.line === replaceRange.end.line && replaceRange.end.character > replaceRange.start.character) {
        let character = replaceRange.start.character;
        while (newText.length && replaceRange.end.character > character) {
          const newStart = { line: replaceRange.start.line, character: replaceRange.start.character + 1 };
          if (document.getText({ start: replaceRange.start, end: newStart }) === newText[0]) {
            newText = newText.slice(1);
            character++;
            const otherRange = getOtherRange({ start: newStart, end: replaceRange.end });
            if (otherRange) {
              return {
                newText,
                range: otherRange
              };
            }
          } else {
            break;
          }
        }
      }
    }
    function transformWorkspaceSymbol(symbol, getOtherLocation) {
      if (!("range" in symbol.location)) {
        return symbol;
      }
      const loc = getOtherLocation(symbol.location);
      if (!loc) {
        return;
      }
      return {
        ...symbol,
        location: loc
      };
    }
    function transformWorkspaceEdit(edit, context, mode, versions = {}) {
      const sourceResult = {};
      let hasResult = false;
      for (const tsUri in edit.changeAnnotations) {
        sourceResult.changeAnnotations ??= {};
        const tsAnno = edit.changeAnnotations[tsUri];
        const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsUri));
        const sourceScript = decoded && context.language.scripts.get(decoded[0]);
        const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
        if (sourceScript && virtualCode) {
          for (const [sourceScript2] of context.language.maps.forEach(virtualCode)) {
            const uri = sourceScript2.id.toString();
            sourceResult.changeAnnotations[uri] = tsAnno;
            break;
          }
        } else {
          sourceResult.changeAnnotations[tsUri] = tsAnno;
        }
      }
      for (const tsUri in edit.changes) {
        sourceResult.changes ??= {};
        const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsUri));
        const sourceScript = decoded && context.language.scripts.get(decoded[0]);
        const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
        if (sourceScript && virtualCode) {
          const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
          for (const [sourceScript2, map] of context.language.maps.forEach(virtualCode)) {
            const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
            const docs = [sourceDocument, embeddedDocument, map];
            const tsEdits = edit.changes[tsUri];
            for (const tsEdit of tsEdits) {
              if (mode === "rename" || mode === "fileName" || mode === "codeAction") {
                let _data;
                const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range, (data) => {
                  _data = data;
                  return (0, language_core_1.isRenameEnabled)(data);
                });
                if (range) {
                  sourceResult.changes[sourceDocument.uri] ??= [];
                  sourceResult.changes[sourceDocument.uri].push({
                    newText: (0, language_core_1.resolveRenameEditText)(tsEdit.newText, _data),
                    range
                  });
                  hasResult = true;
                }
              } else {
                const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range);
                if (range) {
                  sourceResult.changes[sourceDocument.uri] ??= [];
                  sourceResult.changes[sourceDocument.uri].push({ newText: tsEdit.newText, range });
                  hasResult = true;
                }
              }
            }
          }
        } else {
          sourceResult.changes[tsUri] = edit.changes[tsUri];
          hasResult = true;
        }
      }
      if (edit.documentChanges) {
        for (const tsDocEdit of edit.documentChanges) {
          sourceResult.documentChanges ??= [];
          let sourceEdit;
          if ("textDocument" in tsDocEdit) {
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsDocEdit.textDocument.uri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (sourceScript && virtualCode) {
              const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
              for (const [sourceScript2, map] of context.language.maps.forEach(virtualCode)) {
                const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
                const docs = [sourceDocument, embeddedDocument, map];
                sourceEdit = {
                  textDocument: {
                    uri: sourceDocument.uri,
                    version: versions[sourceDocument.uri] ?? null
                  },
                  edits: []
                };
                for (const tsEdit of tsDocEdit.edits) {
                  if (mode === "rename" || mode === "fileName" || mode === "codeAction") {
                    let _data;
                    const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range, (data) => {
                      _data = data;
                      return (0, language_core_1.isRenameEnabled)(data);
                    });
                    if (range) {
                      sourceEdit.edits.push({
                        annotationId: "annotationId" in tsEdit ? tsEdit.annotationId : void 0,
                        newText: (0, language_core_1.resolveRenameEditText)(tsEdit.newText, _data),
                        range
                      });
                    }
                  } else {
                    const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range);
                    if (range) {
                      sourceEdit.edits.push({
                        annotationId: "annotationId" in tsEdit ? tsEdit.annotationId : void 0,
                        newText: tsEdit.newText,
                        range
                      });
                    }
                  }
                }
                if (!sourceEdit.edits.length) {
                  sourceEdit = void 0;
                }
              }
            } else {
              sourceEdit = tsDocEdit;
            }
          } else if (tsDocEdit.kind === "create") {
            sourceEdit = tsDocEdit;
          } else if (tsDocEdit.kind === "rename") {
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsDocEdit.oldUri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (virtualCode) {
              for (const [sourceScript2] of context.language.maps.forEach(virtualCode)) {
                sourceEdit = {
                  kind: "rename",
                  oldUri: sourceScript2.id.toString(),
                  newUri: tsDocEdit.newUri,
                  /* TODO: remove .ts? */
                  options: tsDocEdit.options,
                  annotationId: tsDocEdit.annotationId
                };
              }
            } else {
              sourceEdit = tsDocEdit;
            }
          } else if (tsDocEdit.kind === "delete") {
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsDocEdit.uri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (virtualCode) {
              for (const [sourceScript2] of context.language.maps.forEach(virtualCode)) {
                sourceEdit = {
                  kind: "delete",
                  uri: sourceScript2.id.toString(),
                  options: tsDocEdit.options,
                  annotationId: tsDocEdit.annotationId
                };
              }
            } else {
              sourceEdit = tsDocEdit;
            }
          }
          if (sourceEdit) {
            pushEditToDocumentChanges(sourceResult.documentChanges, sourceEdit);
            hasResult = true;
          }
        }
      }
      if (hasResult) {
        return sourceResult;
      }
    }
    function pushEditToDocumentChanges(arr, item) {
      const current = arr.find((edit) => "textDocument" in edit && "textDocument" in item && edit.textDocument.uri === item.textDocument.uri);
      if (current) {
        current.edits.push(...item.edits);
      } else {
        arr.push(item);
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideRenameEdits.js
var require_provideRenameEdits = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideRenameEdits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    exports2.mergeWorkspaceEdits = mergeWorkspaceEdits;
    var language_core_1 = require_language_core();
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var dedupe = require_dedupe();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return (uri, position, newName, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => ({ position, newName }), function* (docs) {
          let _data;
          for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position, (data) => {
            _data = data;
            return (0, language_core_1.isRenameEnabled)(data);
          })) {
            yield {
              position: mappedPosition,
              newName: (0, language_core_1.resolveRenameNewName)(newName, _data)
            };
          }
        }, async (plugin, document, params) => {
          if (token.isCancellationRequested) {
            return;
          }
          const recursiveChecker = dedupe.createLocationSet();
          let result;
          await withLinkedCode(document, params.position, params.newName);
          return result;
          async function withLinkedCode(document2, position2, newName2) {
            if (!plugin[1].provideRenameEdits) {
              return;
            }
            if (recursiveChecker.has({ uri: document2.uri, range: { start: position2, end: position2 } })) {
              return;
            }
            recursiveChecker.add({ uri: document2.uri, range: { start: position2, end: position2 } });
            const workspaceEdit = await plugin[1].provideRenameEdits(document2, position2, newName2, token);
            if (!workspaceEdit) {
              return;
            }
            if (!result) {
              result = {};
            }
            if (workspaceEdit.changes) {
              for (const editUri in workspaceEdit.changes) {
                const textEdits = workspaceEdit.changes[editUri];
                for (const textEdit of textEdits) {
                  let foundMirrorPosition = false;
                  recursiveChecker.add({
                    uri: editUri,
                    range: { start: textEdit.range.start, end: textEdit.range.start }
                  });
                  const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(editUri));
                  const sourceScript = decoded && context.language.scripts.get(decoded[0]);
                  const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                  const linkedCodeMap = virtualCode && sourceScript ? context.language.linkedCodeMaps.get(virtualCode) : void 0;
                  if (sourceScript && virtualCode && linkedCodeMap) {
                    const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                    for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, textEdit.range.start)) {
                      if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
                        continue;
                      }
                      foundMirrorPosition = true;
                      await withLinkedCode(embeddedDocument, linkedPos, newName2);
                    }
                  }
                  if (!foundMirrorPosition) {
                    if (!result.changes) {
                      result.changes = {};
                    }
                    if (!result.changes[editUri]) {
                      result.changes[editUri] = [];
                    }
                    result.changes[editUri].push(textEdit);
                  }
                }
              }
            }
            if (workspaceEdit.changeAnnotations) {
              for (const uri2 in workspaceEdit.changeAnnotations) {
                if (!result.changeAnnotations) {
                  result.changeAnnotations = {};
                }
                result.changeAnnotations[uri2] = workspaceEdit.changeAnnotations[uri2];
              }
            }
            if (workspaceEdit.documentChanges) {
              if (!result.documentChanges) {
                result.documentChanges = [];
              }
              result.documentChanges = result.documentChanges.concat(workspaceEdit.documentChanges);
            }
          }
        }, (data) => {
          return (0, transform_1.transformWorkspaceEdit)(data, context, "rename");
        }, (workspaceEdits) => {
          const mainEdit = workspaceEdits[0];
          const otherEdits = workspaceEdits.slice(1);
          mergeWorkspaceEdits(mainEdit, ...otherEdits);
          if (mainEdit.changes) {
            for (const uri2 in mainEdit.changes) {
              mainEdit.changes[uri2] = dedupe.withTextEdits(mainEdit.changes[uri2]);
            }
          }
          return workspaceEdits[0];
        });
      };
    }
    function mergeWorkspaceEdits(original, ...others) {
      for (const other of others) {
        for (const uri in other.changeAnnotations) {
          if (!original.changeAnnotations) {
            original.changeAnnotations = {};
          }
          original.changeAnnotations[uri] = other.changeAnnotations[uri];
        }
        for (const uri in other.changes) {
          if (!original.changes) {
            original.changes = {};
          }
          if (!original.changes[uri]) {
            original.changes[uri] = [];
          }
          const edits = other.changes[uri];
          original.changes[uri] = original.changes[uri].concat(edits);
        }
        if (other.documentChanges) {
          if (!original.documentChanges) {
            original.documentChanges = [];
          }
          for (const docChange of other.documentChanges) {
            (0, transform_1.pushEditToDocumentChanges)(original.documentChanges, docChange);
          }
        }
      }
    }
  }
});

// node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  TextDocument: () => TextDocument
});
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}
var FullTextDocument, TextDocument;
var init_main = __esm({
  "node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    FullTextDocument = class _FullTextDocument {
      constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range) {
        if (range) {
          const start = this.offsetAt(range.start);
          const end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(changes, version) {
        for (const change of changes) {
          if (_FullTextDocument.isIncremental(change)) {
            const range = getWellformedRange(change.range);
            const startOffset = this.offsetAt(range.start);
            const endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            const startLine = Math.max(range.start.line, 0);
            const endLine = Math.max(range.end.line, 0);
            let lineOffsets = this._lineOffsets;
            const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            const diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (_FullTextDocument.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        const lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          const mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        const line = low - 1;
        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        const lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        const lineOffset = lineOffsets[position.line];
        if (position.character <= 0) {
          return lineOffset;
        }
        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        const offset = Math.min(lineOffset + position.character, nextLineOffset);
        return this.ensureBeforeEOL(offset, lineOffset);
      }
      ensureBeforeEOL(offset, lineOffset) {
        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
          offset--;
        }
        return offset;
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
      static isIncremental(event) {
        const candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      static isFull(event) {
        const candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
    };
    (function(TextDocument2) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
      }
      TextDocument2.create = create;
      function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
          document.update(changes, version);
          return document;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument2.update = update;
      function applyEdits(document, edits) {
        const text = document.getText();
        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
          const diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
          const startOffset = document.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument2.applyEdits = applyEdits;
    })(TextDocument || (TextDocument = {}));
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideAutoInsertSnippet.js
var require_provideAutoInsertSnippet = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideAutoInsertSnippet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, selection, change, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => ({ selection, change }), function* (docs) {
          for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, selection, language_core_1.isAutoInsertEnabled)) {
            for (const mapped of docs[2].toGeneratedLocation(change.rangeOffset)) {
              yield {
                selection: mappedPosition,
                change: {
                  text: change.text,
                  rangeOffset: mapped[0],
                  rangeLength: change.rangeLength
                }
              };
              break;
            }
          }
        }, (plugin, document, args) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideAutoInsertSnippet?.(document, args.selection, args.change, token);
        }, (snippet) => snippet);
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideCallHierarchyItems.js
var require_provideCallHierarchyItems = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideCallHierarchyItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var dedupe = require_dedupe();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return {
        getCallHierarchyItems(uri, position, token = cancellation_1.NoneCancellationToken) {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isCallHierarchyEnabled), async (plugin, document, position2, map) => {
            if (token.isCancellationRequested) {
              return;
            }
            const items = await plugin[1].provideCallHierarchyItems?.(document, position2, token);
            items?.forEach((item) => {
              item.data = {
                uri: uri.toString(),
                original: {
                  data: item.data
                },
                pluginIndex: context.plugins.indexOf(plugin),
                embeddedDocumentUri: map?.[1].uri
              };
            });
            return items;
          }, (data, map) => {
            if (!map) {
              return data;
            }
            return data.map((item) => transformHierarchyItem(item, [])?.[0]).filter((item) => !!item);
          }, (arr) => dedupe.withLocations(arr.flat()));
        },
        getTypeHierarchyItems(uri, position, token = cancellation_1.NoneCancellationToken) {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isTypeHierarchyEnabled), async (plugin, document, position2, map) => {
            if (token.isCancellationRequested) {
              return;
            }
            const items = await plugin[1].provideTypeHierarchyItems?.(document, position2, token);
            items?.forEach((item) => {
              item.data = {
                uri: uri.toString(),
                original: {
                  data: item.data
                },
                pluginIndex: context.plugins.indexOf(plugin),
                embeddedDocumentUri: map?.[1].uri
              };
            });
            return items;
          }, (data, map) => {
            if (!map) {
              return data;
            }
            return data.map((item) => transformHierarchyItem(item, [])?.[0]).filter((item) => !!item);
          }, (arr) => dedupe.withLocations(arr.flat()));
        },
        async getCallHierarchyIncomingCalls(item, token) {
          const data = item.data;
          let incomingItems = [];
          if (data) {
            const plugin = context.plugins[data.pluginIndex];
            if (!plugin[1].provideCallHierarchyIncomingCalls) {
              return incomingItems;
            }
            Object.assign(item, data.original);
            if (data.embeddedDocumentUri) {
              const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
              if (isEmbeddedContent) {
                const _calls = await plugin[1].provideCallHierarchyIncomingCalls(item, token);
                for (const _call of _calls) {
                  const calls = transformHierarchyItem(_call.from, _call.fromRanges);
                  if (!calls) {
                    continue;
                  }
                  incomingItems.push({
                    from: calls[0],
                    fromRanges: calls[1]
                  });
                }
              }
            } else {
              const _calls = await plugin[1].provideCallHierarchyIncomingCalls(item, token);
              for (const _call of _calls) {
                const calls = transformHierarchyItem(_call.from, _call.fromRanges);
                if (!calls) {
                  continue;
                }
                incomingItems.push({
                  from: calls[0],
                  fromRanges: calls[1]
                });
              }
            }
          }
          return dedupe.withCallHierarchyIncomingCalls(incomingItems);
        },
        async getCallHierarchyOutgoingCalls(item, token) {
          const data = item.data;
          let items = [];
          if (data) {
            const plugin = context.plugins[data.pluginIndex];
            if (!plugin[1].provideCallHierarchyOutgoingCalls) {
              return items;
            }
            Object.assign(item, data.original);
            if (data.embeddedDocumentUri) {
              const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
              if (isEmbeddedContent) {
                const _calls = await plugin[1].provideCallHierarchyOutgoingCalls(item, token);
                for (const call of _calls) {
                  const calls = transformHierarchyItem(call.to, call.fromRanges);
                  if (!calls) {
                    continue;
                  }
                  items.push({
                    to: calls[0],
                    fromRanges: calls[1]
                  });
                }
              }
            } else {
              const _calls = await plugin[1].provideCallHierarchyOutgoingCalls(item, token);
              for (const call of _calls) {
                const calls = transformHierarchyItem(call.to, call.fromRanges);
                if (!calls) {
                  continue;
                }
                items.push({
                  to: calls[0],
                  fromRanges: calls[1]
                });
              }
            }
          }
          return dedupe.withCallHierarchyOutgoingCalls(items);
        },
        async getTypeHierarchySupertypes(item, token) {
          const data = item.data;
          if (data) {
            const plugin = context.plugins[data.pluginIndex];
            if (!plugin[1].provideTypeHierarchySupertypes) {
              return [];
            }
            Object.assign(item, data.original);
            if (data.embeddedDocumentUri) {
              const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
              if (isEmbeddedContent) {
                const items = await plugin[1].provideTypeHierarchySupertypes(item, token);
                return items.map((item2) => transformHierarchyItem(item2, [])?.[0]).filter((item2) => !!item2);
              }
            } else {
              const items = await plugin[1].provideTypeHierarchySupertypes(item, token);
              return items.map((item2) => transformHierarchyItem(item2, [])?.[0]).filter((item2) => !!item2);
            }
          }
        },
        async getTypeHierarchySubtypes(item, token) {
          const data = item.data;
          if (data) {
            const plugin = context.plugins[data.pluginIndex];
            if (!plugin[1].provideTypeHierarchySubtypes) {
              return [];
            }
            Object.assign(item, data.original);
            if (data.embeddedDocumentUri) {
              const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
              if (isEmbeddedContent) {
                const items = await plugin[1].provideTypeHierarchySubtypes(item, token);
                return items.map((item2) => transformHierarchyItem(item2, [])?.[0]).filter((item2) => !!item2);
              }
            } else {
              const items = await plugin[1].provideTypeHierarchySubtypes(item, token);
              return items.map((item2) => transformHierarchyItem(item2, [])?.[0]).filter((item2) => !!item2);
            }
          }
        }
      };
      function transformHierarchyItem(tsItem, tsRanges) {
        const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsItem.uri));
        const sourceScript = decoded && context.language.scripts.get(decoded[0]);
        const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
        if (!sourceScript || !virtualCode) {
          return [tsItem, tsRanges];
        }
        const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
        for (const [sourceScript2, map] of context.language.maps.forEach(virtualCode)) {
          const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
          const docs = [sourceDocument, embeddedDocument, map];
          let range = (0, featureWorkers_1.getSourceRange)(docs, tsItem.range);
          if (!range) {
            range = {
              start: sourceDocument.positionAt(0),
              end: sourceDocument.positionAt(sourceDocument.getText().length)
            };
          }
          const selectionRange = (0, featureWorkers_1.getSourceRange)(docs, tsItem.selectionRange);
          if (!selectionRange) {
            continue;
          }
          const vueRanges = tsRanges.map((tsRange) => (0, featureWorkers_1.getSourceRange)(docs, tsRange)).filter((range2) => !!range2);
          const vueItem = {
            ...tsItem,
            name: tsItem.name === embeddedDocument.uri.substring(embeddedDocument.uri.lastIndexOf("/") + 1) ? sourceDocument.uri.substring(sourceDocument.uri.lastIndexOf("/") + 1) : tsItem.name,
            uri: sourceDocument.uri,
            // TS Bug: `range: range` not works
            range: {
              start: range.start,
              end: range.end
            },
            selectionRange: {
              start: selectionRange.start,
              end: selectionRange.end
            }
          };
          return [vueItem, vueRanges];
        }
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideCodeActions.js
var require_provideCodeActions = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideCodeActions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var dedupe = require_dedupe();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return async (uri, range, codeActionContext, token = cancellation_1.NoneCancellationToken) => {
        const sourceScript = context.language.scripts.get(uri);
        if (!sourceScript) {
          return;
        }
        const transformedCodeActions = /* @__PURE__ */ new WeakSet();
        return await (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => ({ range, codeActionContext }), function* (docs) {
          const _codeActionContext = {
            diagnostics: (0, transform_1.transformLocations)(codeActionContext.diagnostics, (range2) => (0, featureWorkers_1.getGeneratedRange)(docs, range2)),
            only: codeActionContext.only
          };
          const mapped = (0, language_core_1.findOverlapCodeRange)(docs[0].offsetAt(range.start), docs[0].offsetAt(range.end), docs[2], language_core_1.isCodeActionsEnabled);
          if (mapped) {
            yield {
              range: {
                start: docs[1].positionAt(mapped.start),
                end: docs[1].positionAt(mapped.end)
              },
              codeActionContext: _codeActionContext
            };
          }
        }, async (plugin, document, { range: range2, codeActionContext: codeActionContext2 }) => {
          if (token.isCancellationRequested) {
            return;
          }
          const pluginIndex = context.plugins.indexOf(plugin);
          const diagnostics = codeActionContext2.diagnostics.filter((diagnostic) => {
            const data = diagnostic.data;
            if (data && data.version !== document.version) {
              return false;
            }
            return data?.pluginIndex === pluginIndex;
          }).map((diagnostic) => {
            const data = diagnostic.data;
            return {
              ...diagnostic,
              ...data.original
            };
          });
          const codeActions = await plugin[1].provideCodeActions?.(document, range2, {
            ...codeActionContext2,
            diagnostics
          }, token);
          codeActions?.forEach((codeAction) => {
            if (plugin[1].resolveCodeAction) {
              codeAction.data = {
                uri: uri.toString(),
                version: document.version,
                original: {
                  data: codeAction.data,
                  edit: codeAction.edit
                },
                pluginIndex: context.plugins.indexOf(plugin)
              };
            } else {
              delete codeAction.data;
            }
          });
          if (codeActions && plugin[1].transformCodeAction) {
            for (let i = 0; i < codeActions.length; i++) {
              const transformed = plugin[1].transformCodeAction(codeActions[i]);
              if (transformed) {
                codeActions[i] = transformed;
                transformedCodeActions.add(transformed);
              }
            }
          }
          return codeActions;
        }, (actions) => actions.map((action) => {
          if (transformedCodeActions.has(action)) {
            return action;
          }
          if (action.edit) {
            const edit = (0, transform_1.transformWorkspaceEdit)(action.edit, context, "codeAction");
            if (!edit) {
              return;
            }
            action.edit = edit;
          }
          return action;
        }).filter((action) => !!action), (arr) => dedupe.withCodeAction(arr.flat()));
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideCodeLenses.js
var require_provideCodeLenses = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideCodeLenses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return async (uri, token = cancellation_1.NoneCancellationToken) => {
        return await (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isCodeLensEnabled)(mapping.data)), async (plugin, document) => {
          if (token.isCancellationRequested) {
            return;
          }
          let codeLens = await plugin[1].provideCodeLenses?.(document, token);
          const pluginIndex = context.plugins.indexOf(plugin);
          codeLens?.forEach((codeLens2) => {
            if (plugin[1].resolveCodeLens) {
              codeLens2.data = {
                kind: "normal",
                uri: uri.toString(),
                original: {
                  data: codeLens2.data
                },
                pluginIndex
              };
            } else {
              delete codeLens2.data;
            }
          });
          const ranges = await plugin[1].provideReferencesCodeLensRanges?.(document, token);
          const referencesCodeLens = ranges?.map((range) => ({
            range,
            data: {
              kind: "references",
              sourceFileUri: uri.toString(),
              workerFileUri: document.uri,
              workerFileRange: range,
              pluginIndex
            }
          }));
          codeLens = [
            ...codeLens ?? [],
            ...referencesCodeLens ?? []
          ];
          return codeLens;
        }, (data, docs) => {
          if (!docs) {
            return data;
          }
          return data.map((codeLens) => {
            const range = (0, featureWorkers_1.getSourceRange)(docs, codeLens.range, language_core_1.isCodeLensEnabled);
            if (range) {
              return {
                ...codeLens,
                range
              };
            }
          }).filter((codeLens) => !!codeLens);
        }, (arr) => arr.flat()) ?? [];
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideColorPresentations.js
var require_provideColorPresentations = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideColorPresentations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, color, range, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, function* (docs) {
          for (const mappedRange of (0, featureWorkers_1.getGeneratedRanges)(docs, range, language_core_1.isColorEnabled)) {
            yield mappedRange;
          }
        }, (plugin, document, range2) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideColorPresentations?.(document, color, range2, token);
        }, (data, docs) => {
          if (!docs) {
            return data;
          }
          return data.map((colorPresentation) => {
            if (colorPresentation.textEdit) {
              const range2 = (0, featureWorkers_1.getSourceRange)(docs, colorPresentation.textEdit.range);
              if (!range2) {
                return void 0;
              }
              colorPresentation.textEdit.range = range2;
            }
            if (colorPresentation.additionalTextEdits) {
              for (const textEdit of colorPresentation.additionalTextEdits) {
                const range2 = (0, featureWorkers_1.getSourceRange)(docs, textEdit.range);
                if (!range2) {
                  return void 0;
                }
                textEdit.range = range2;
              }
            }
            return colorPresentation;
          }).filter((colorPresentation) => !!colorPresentation);
        });
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideCompletionItems.js
var require_provideCompletionItems = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideCompletionItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      let lastResult;
      return async (uri, position, completionContext = {
        triggerKind: 1
      }, token = cancellation_1.NoneCancellationToken) => {
        let langaugeIdAndSnapshot;
        let sourceScript;
        const decoded = context.decodeEmbeddedDocumentUri(uri);
        if (decoded) {
          langaugeIdAndSnapshot = context.language.scripts.get(decoded[0])?.generated?.embeddedCodes.get(decoded[1]);
        } else {
          sourceScript = context.language.scripts.get(uri);
          langaugeIdAndSnapshot = sourceScript;
        }
        if (!langaugeIdAndSnapshot) {
          return {
            isIncomplete: false,
            items: []
          };
        }
        if (completionContext?.triggerKind === 3 && lastResult?.uri.toString() === uri.toString()) {
          for (const cacheData of lastResult.results) {
            if (!cacheData.list?.isIncomplete) {
              continue;
            }
            const pluginIndex = context.plugins.findIndex((plugin) => plugin[1] === cacheData.plugin);
            if (cacheData.embeddedDocumentUri) {
              const decoded2 = context.decodeEmbeddedDocumentUri(cacheData.embeddedDocumentUri);
              const sourceScript2 = decoded2 && context.language.scripts.get(decoded2[0]);
              const virtualCode = decoded2 && sourceScript2?.generated?.embeddedCodes.get(decoded2[1]);
              if (!sourceScript2 || !virtualCode) {
                continue;
              }
              const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript2.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
              for (const [sourceScript3, map] of context.language.maps.forEach(virtualCode)) {
                const sourceDocument = context.documents.get(sourceScript3.id, sourceScript3.languageId, sourceScript3.snapshot);
                const docs = [sourceDocument, embeddedDocument, map];
                for (const mapped of (0, featureWorkers_1.getGeneratedPositions)(docs, position, (data) => (0, language_core_1.isCompletionEnabled)(data))) {
                  if (!cacheData.plugin.provideCompletionItems) {
                    continue;
                  }
                  cacheData.list = await cacheData.plugin.provideCompletionItems(embeddedDocument, mapped, completionContext, token);
                  if (!cacheData.list) {
                    continue;
                  }
                  for (const item of cacheData.list.items) {
                    if (cacheData.plugin.resolveCompletionItem) {
                      item.data = {
                        uri: uri.toString(),
                        original: {
                          additionalTextEdits: item.additionalTextEdits,
                          textEdit: item.textEdit,
                          data: item.data
                        },
                        pluginIndex,
                        embeddedDocumentUri: embeddedDocument.uri
                      };
                    } else {
                      delete item.data;
                    }
                  }
                  cacheData.list = (0, transform_1.transformCompletionList)(cacheData.list, (range) => (0, featureWorkers_1.getSourceRange)(docs, range), embeddedDocument, context);
                }
              }
            } else {
              if (!cacheData.plugin.provideCompletionItems) {
                continue;
              }
              const document = context.documents.get(uri, langaugeIdAndSnapshot.languageId, langaugeIdAndSnapshot.snapshot);
              cacheData.list = await cacheData.plugin.provideCompletionItems(document, position, completionContext, token);
              if (!cacheData.list) {
                continue;
              }
              for (const item of cacheData.list.items) {
                if (cacheData.plugin.resolveCompletionItem) {
                  item.data = {
                    uri: uri.toString(),
                    original: {
                      additionalTextEdits: item.additionalTextEdits,
                      textEdit: item.textEdit,
                      data: item.data
                    },
                    pluginIndex,
                    embeddedDocumentUri: void 0
                  };
                } else {
                  delete item.data;
                }
              }
            }
          }
        } else {
          lastResult = {
            uri,
            results: []
          };
          let isFirstMapping = true;
          let mainCompletionUri;
          const sortedPlugins = [...context.plugins].filter((plugin) => !context.disabledServicePlugins.has(plugin[1])).sort((a, b) => sortServices(a[1], b[1]));
          const worker = async (document, position2, docs, codeInfo) => {
            for (const plugin of sortedPlugins) {
              if (token.isCancellationRequested) {
                break;
              }
              if (!plugin[1].provideCompletionItems) {
                continue;
              }
              if (plugin[1].isAdditionalCompletion && !isFirstMapping) {
                continue;
              }
              if (completionContext?.triggerCharacter && !plugin[0].capabilities.completionProvider?.triggerCharacters?.includes(completionContext.triggerCharacter)) {
                continue;
              }
              const isAdditional = codeInfo && typeof codeInfo.completion === "object" && codeInfo.completion.isAdditional || plugin[1].isAdditionalCompletion;
              if (mainCompletionUri && (!isAdditional || mainCompletionUri !== document.uri)) {
                continue;
              }
              if (plugin[1].isAdditionalCompletion && lastResult?.results.some((data) => data.plugin === plugin[1])) {
                continue;
              }
              let completionList = await plugin[1].provideCompletionItems(document, position2, completionContext, token);
              if (!completionList || !completionList.items.length) {
                continue;
              }
              if (typeof codeInfo?.completion === "object" && codeInfo.completion.onlyImport) {
                completionList.items = completionList.items.filter((item) => !!item.labelDetails);
              }
              if (!isAdditional) {
                mainCompletionUri = document.uri;
              }
              const pluginIndex = context.plugins.indexOf(plugin);
              for (const item of completionList.items) {
                if (plugin[1].resolveCompletionItem) {
                  item.data = {
                    uri: uri.toString(),
                    original: {
                      additionalTextEdits: item.additionalTextEdits,
                      textEdit: item.textEdit,
                      data: item.data
                    },
                    pluginIndex,
                    embeddedDocumentUri: docs ? document.uri : void 0
                  };
                } else {
                  delete item.data;
                }
              }
              if (docs) {
                completionList = (0, transform_1.transformCompletionList)(completionList, (range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isCompletionEnabled), document, context);
              }
              lastResult?.results.push({
                embeddedDocumentUri: docs ? vscode_uri_1.URI.parse(document.uri) : void 0,
                plugin: plugin[1],
                list: completionList
              });
            }
            isFirstMapping = false;
          };
          if (sourceScript?.generated) {
            for (const docs of (0, featureWorkers_1.forEachEmbeddedDocument)(context, sourceScript, sourceScript.generated.root)) {
              let _data;
              for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position, (data) => {
                _data = data;
                return (0, language_core_1.isCompletionEnabled)(data);
              })) {
                await worker(docs[1], mappedPosition, docs, _data);
              }
            }
          } else {
            const document = context.documents.get(uri, langaugeIdAndSnapshot.languageId, langaugeIdAndSnapshot.snapshot);
            await worker(document, position);
          }
        }
        return combineCompletionList(lastResult.results.map((cacheData) => cacheData.list));
        function sortServices(a, b) {
          return (b.isAdditionalCompletion ? -1 : 1) - (a.isAdditionalCompletion ? -1 : 1);
        }
        function combineCompletionList(lists) {
          return {
            isIncomplete: lists.some((list) => list?.isIncomplete),
            itemDefaults: lists.find((list) => list?.itemDefaults)?.itemDefaults,
            items: lists.map((list) => list?.items ?? []).flat()
          };
        }
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDefinition.js
var require_provideDefinition = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var dedupe = require_dedupe();
    var featureWorkers_1 = require_featureWorkers();
    function register(context, apiName, isValidPosition) {
      return (uri, position, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position, isValidPosition), async (plugin, document, position2) => {
          if (token.isCancellationRequested) {
            return;
          }
          const recursiveChecker = dedupe.createLocationSet();
          const result = [];
          await withLinkedCode(document, position2, void 0);
          return result;
          async function withLinkedCode(document2, position3, originDefinition) {
            const api = plugin[1][apiName];
            if (!api) {
              return;
            }
            if (recursiveChecker.has({ uri: document2.uri, range: { start: position3, end: position3 } })) {
              return;
            }
            recursiveChecker.add({ uri: document2.uri, range: { start: position3, end: position3 } });
            const definitions = await api?.(document2, position3, token) ?? [];
            for (const definition of definitions) {
              let foundMirrorPosition = false;
              recursiveChecker.add({
                uri: definition.targetUri,
                range: { start: definition.targetRange.start, end: definition.targetRange.start }
              });
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(definition.targetUri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              const linkedCodeMap = virtualCode && sourceScript ? context.language.linkedCodeMaps.get(virtualCode) : void 0;
              if (sourceScript && virtualCode && linkedCodeMap) {
                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, definition.targetSelectionRange.start)) {
                  if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
                    continue;
                  }
                  foundMirrorPosition = true;
                  await withLinkedCode(embeddedDocument, linkedPos, originDefinition ?? definition);
                }
              }
              if (!foundMirrorPosition) {
                if (originDefinition) {
                  result.push({
                    ...definition,
                    originSelectionRange: originDefinition.originSelectionRange
                  });
                } else {
                  result.push(definition);
                }
              }
            }
          }
        }, (data, map) => data.map((link) => {
          if (link.originSelectionRange && map) {
            const originSelectionRange = toSourcePositionPreferSurroundedPosition(map, link.originSelectionRange, position);
            if (!originSelectionRange) {
              return;
            }
            link.originSelectionRange = originSelectionRange;
          }
          let foundTargetSelectionRange = false;
          const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(link.targetUri));
          const sourceScript = decoded && context.language.scripts.get(decoded[0]);
          const targetVirtualFile = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
          if (sourceScript && targetVirtualFile) {
            const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, targetVirtualFile.id), targetVirtualFile.languageId, targetVirtualFile.snapshot);
            for (const [targetScript, targetSourceMap] of context.language.maps.forEach(targetVirtualFile)) {
              const sourceDocument = context.documents.get(targetScript.id, targetScript.languageId, targetScript.snapshot);
              const docs = [sourceDocument, embeddedDocument, targetSourceMap];
              const targetSelectionRange = (0, featureWorkers_1.getSourceRange)(docs, link.targetSelectionRange);
              if (!targetSelectionRange) {
                continue;
              }
              foundTargetSelectionRange = true;
              let targetRange = (0, featureWorkers_1.getSourceRange)(docs, link.targetRange);
              link.targetUri = sourceDocument.uri;
              link.targetRange = targetRange ?? targetSelectionRange;
              link.targetSelectionRange = targetSelectionRange;
            }
            if (apiName === "provideDefinition" && !foundTargetSelectionRange) {
              for (const [targetScript] of context.language.maps.forEach(targetVirtualFile)) {
                if (targetScript.id.toString() !== uri.toString()) {
                  return {
                    ...link,
                    targetUri: targetScript.id.toString(),
                    targetRange: {
                      start: { line: 0, character: 0 },
                      end: { line: 0, character: 0 }
                    },
                    targetSelectionRange: {
                      start: { line: 0, character: 0 },
                      end: { line: 0, character: 0 }
                    }
                  };
                }
              }
              return;
            }
          }
          return link;
        }).filter((link) => !!link), (arr) => dedupe.withLocationLinks(arr.flat()));
      };
    }
    function toSourcePositionPreferSurroundedPosition(docs, mappedRange, position) {
      let result;
      for (const range of (0, featureWorkers_1.getSourceRanges)(docs, mappedRange)) {
        if (!result) {
          result = range;
        }
        if ((range.start.line < position.line || range.start.line === position.line && range.start.character <= position.character) && (range.end.line > position.line || range.end.line === position.line && range.end.character >= position.character)) {
          return range;
        }
      }
      return result;
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isInsideRange = isInsideRange;
    exports2.isEqualRange = isEqualRange;
    exports2.stringToSnapshot = stringToSnapshot;
    exports2.sleep = sleep;
    function isInsideRange(parent, child) {
      if (child.start.line < parent.start.line) {
        return false;
      }
      if (child.end.line > parent.end.line) {
        return false;
      }
      if (child.start.line === parent.start.line && child.start.character < parent.start.character) {
        return false;
      }
      if (child.end.line === parent.end.line && child.end.character > parent.end.character) {
        return false;
      }
      return true;
    }
    function isEqualRange(a, b) {
      return a.start.line === b.start.line && a.start.character === b.start.character && a.end.line === b.end.line && a.end.character === b.end.character;
    }
    function stringToSnapshot(str) {
      return {
        getText: (start, end) => str.substring(start, end),
        getLength: () => str.length,
        getChangeRange: () => void 0
      };
    }
    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/uriMap.js
var require_uriMap = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/uriMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUriMap = createUriMap;
    function createUriMap(caseSensitive = false) {
      const map = /* @__PURE__ */ new Map();
      const rawUriToNormalizedUri = /* @__PURE__ */ new Map();
      const normalizedUriToRawUri = /* @__PURE__ */ new Map();
      return {
        get size() {
          return map.size;
        },
        get [Symbol.toStringTag]() {
          return "UriMap";
        },
        [Symbol.iterator]() {
          return this.entries();
        },
        clear() {
          rawUriToNormalizedUri.clear();
          normalizedUriToRawUri.clear();
          return map.clear();
        },
        values() {
          return map.values();
        },
        *keys() {
          for (const normalizedUri of map.keys()) {
            yield normalizedUriToRawUri.get(normalizedUri);
          }
          return void 0;
        },
        *entries() {
          for (const [normalizedUri, item] of map.entries()) {
            yield [normalizedUriToRawUri.get(normalizedUri), item];
          }
          return void 0;
        },
        forEach(callbackfn, thisArg) {
          for (const [uri, item] of this.entries()) {
            callbackfn.call(thisArg, item, uri, this);
          }
        },
        delete(uri) {
          return map.delete(toKey(uri));
        },
        get(uri) {
          return map.get(toKey(uri));
        },
        has(uri) {
          return map.has(toKey(uri));
        },
        set(uri, item) {
          map.set(toKey(uri), item);
          return this;
        }
      };
      function toKey(uri) {
        const rawUri = uri.toString();
        if (!rawUriToNormalizedUri.has(rawUri)) {
          let normalizedUri = uri.toString();
          if (!caseSensitive) {
            normalizedUri = normalizedUri.toLowerCase();
          }
          rawUriToNormalizedUri.set(rawUri, normalizedUri);
          normalizedUriToRawUri.set(normalizedUri, uri);
        }
        return rawUriToNormalizedUri.get(rawUri);
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDiagnostics.js
var require_provideDiagnostics = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDiagnostics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.errorMarkups = void 0;
    exports2.register = register;
    exports2.transformDiagnostic = transformDiagnostic;
    exports2.updateRange = updateRange;
    var language_core_1 = require_language_core();
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var common_1 = require_common();
    var dedupe = require_dedupe();
    var featureWorkers_1 = require_featureWorkers();
    var uriMap_1 = require_uriMap();
    exports2.errorMarkups = (0, uriMap_1.createUriMap)();
    function register(context) {
      const lastResponses = (0, uriMap_1.createUriMap)();
      const cacheMaps = {
        semantic: /* @__PURE__ */ new Map(),
        syntactic: /* @__PURE__ */ new Map()
      };
      context.env.onDidChangeConfiguration?.(() => {
        lastResponses.clear();
        cacheMaps.semantic.clear();
        cacheMaps.syntactic.clear();
      });
      return async (uri, response, token = cancellation_1.NoneCancellationToken) => {
        let langaugeIdAndSnapshot;
        const decoded = context.decodeEmbeddedDocumentUri(uri);
        if (decoded) {
          langaugeIdAndSnapshot = context.language.scripts.get(decoded[0])?.generated?.embeddedCodes.get(decoded[1]);
        } else {
          langaugeIdAndSnapshot = context.language.scripts.get(uri);
        }
        if (!langaugeIdAndSnapshot) {
          return [];
        }
        const document = context.documents.get(uri, langaugeIdAndSnapshot.languageId, langaugeIdAndSnapshot.snapshot);
        const lastResponse = lastResponses.get(uri) ?? lastResponses.set(uri, {
          semantic: { errors: [] },
          syntactic: { errors: [] }
        }).get(uri);
        let updateCacheRangeFailed = false;
        let errorsUpdated = false;
        let lastCheckCancelAt = 0;
        for (const cache of Object.values(lastResponse)) {
          const oldSnapshot = cache.snapshot;
          const oldDocument = cache.document;
          const change = oldSnapshot ? langaugeIdAndSnapshot.snapshot.getChangeRange(oldSnapshot) : void 0;
          cache.snapshot = langaugeIdAndSnapshot.snapshot;
          cache.document = document;
          if (!updateCacheRangeFailed && oldDocument && change) {
            const changeRange = {
              range: {
                start: oldDocument.positionAt(change.span.start),
                end: oldDocument.positionAt(change.span.start + change.span.length)
              },
              newEnd: document.positionAt(change.span.start + change.newLength)
            };
            for (const error of cache.errors) {
              if (!updateRange(error.range, changeRange)) {
                updateCacheRangeFailed = true;
                break;
              }
            }
          }
        }
        await worker("syntactic", cacheMaps.syntactic, lastResponse.syntactic);
        processResponse();
        await worker("semantic", cacheMaps.semantic, lastResponse.semantic);
        return collectErrors();
        function processResponse() {
          if (errorsUpdated && !updateCacheRangeFailed) {
            response?.(collectErrors());
            errorsUpdated = false;
          }
        }
        function collectErrors() {
          return Object.values(lastResponse).flatMap(({ errors }) => errors);
        }
        async function worker(kind, cacheMap, cache) {
          const result = await (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isDiagnosticsEnabled)(mapping.data)), async (plugin, document2) => {
            const interFileDependencies = plugin[0].capabilities.diagnosticProvider?.interFileDependencies;
            if (kind === "semantic" !== interFileDependencies) {
              return;
            }
            if (Date.now() - lastCheckCancelAt >= 10) {
              await (0, common_1.sleep)(10);
              lastCheckCancelAt = Date.now();
            }
            if (token.isCancellationRequested) {
              return;
            }
            const pluginIndex = context.plugins.indexOf(plugin);
            const pluginCache = cacheMap.get(pluginIndex) ?? cacheMap.set(pluginIndex, /* @__PURE__ */ new Map()).get(pluginIndex);
            const cache2 = pluginCache.get(document2.uri);
            if (!interFileDependencies && cache2 && cache2.documentVersion === document2.version) {
              return cache2.errors;
            }
            const errors = await plugin[1].provideDiagnostics?.(document2, token) || [];
            errors.forEach((error) => {
              error.data = {
                uri: uri.toString(),
                version: document2.version,
                pluginIndex,
                isFormat: false,
                original: {
                  data: error.data
                },
                documentUri: document2.uri
              };
            });
            errorsUpdated = true;
            pluginCache.set(document2.uri, {
              documentVersion: document2.version,
              errors
            });
            return errors;
          }, (errors, map) => {
            return errors.map((error) => transformDiagnostic(context, error, map)).filter((error) => !!error);
          }, (arr) => dedupe.withDiagnostics(arr.flat()));
          if (result) {
            cache.errors = result;
            cache.snapshot = langaugeIdAndSnapshot?.snapshot;
          }
        }
      };
    }
    function transformDiagnostic(context, error, docs) {
      let _error = { ...error };
      if (docs) {
        const range = (0, featureWorkers_1.getSourceRange)(docs, error.range, (data) => (0, language_core_1.shouldReportDiagnostics)(data, error.source, error.code));
        if (!range) {
          return;
        }
        _error.range = range;
      }
      if (_error.relatedInformation) {
        const relatedInfos = [];
        for (const info of _error.relatedInformation) {
          const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(info.location.uri));
          const sourceScript = decoded && context.language.scripts.get(decoded[0]);
          const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
          if (sourceScript && virtualCode) {
            const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
            for (const [sourceScript2, map] of context.language.maps.forEach(virtualCode)) {
              const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
              const docs2 = [sourceDocument, embeddedDocument, map];
              const range = (0, featureWorkers_1.getSourceRange)(docs2, info.location.range, (data) => (0, language_core_1.shouldReportDiagnostics)(data, void 0, void 0));
              if (range) {
                relatedInfos.push({
                  location: {
                    uri: sourceDocument.uri,
                    range
                  },
                  message: info.message
                });
              }
            }
          } else {
            relatedInfos.push(info);
          }
        }
        _error.relatedInformation = relatedInfos;
      }
      return _error;
    }
    function updateRange(range, change) {
      if (!updatePosition(range.start, change, false)) {
        return;
      }
      if (!updatePosition(range.end, change, true)) {
        return;
      }
      if (range.end.line === range.start.line && range.end.character <= range.start.character) {
        range.end.character++;
      }
      return range;
    }
    function updatePosition(position, change, isEnd) {
      if (change.range.end.line > position.line) {
        if (change.newEnd.line > position.line) {
          return true;
        } else if (change.newEnd.line === position.line) {
          position.character = Math.min(position.character, change.newEnd.character);
          return true;
        } else if (change.newEnd.line < position.line) {
          position.line = change.newEnd.line;
          position.character = change.newEnd.character;
          return true;
        }
      } else if (change.range.end.line === position.line) {
        const characterDiff = change.newEnd.character - change.range.end.character;
        if (position.character >= change.range.end.character) {
          if (change.newEnd.line !== change.range.end.line) {
            position.line = change.newEnd.line;
            position.character = change.newEnd.character + position.character - change.range.end.character;
          } else {
            if (isEnd ? change.range.end.character < position.character : change.range.end.character <= position.character) {
              position.character += characterDiff;
            } else {
              const offset = change.range.end.character - position.character;
              if (-characterDiff > offset) {
                position.character += characterDiff + offset;
              }
            }
          }
          return true;
        } else {
          if (change.newEnd.line === change.range.end.line) {
            const offset = change.range.end.character - position.character;
            if (-characterDiff > offset) {
              position.character += characterDiff + offset;
            }
          } else if (change.newEnd.line < change.range.end.line) {
            position.line = change.newEnd.line;
            position.character = change.newEnd.character;
          } else {
          }
          return true;
        }
      } else if (change.range.end.line < position.line) {
        position.line += change.newEnd.line - change.range.end.line;
        return true;
      }
      return false;
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentColors.js
var require_provideDocumentColors = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentColors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isColorEnabled)(mapping.data)), (plugin, document) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideDocumentColors?.(document, token);
        }, (data, docs) => {
          if (!docs) {
            return data;
          }
          return data.map((color) => {
            const range = (0, featureWorkers_1.getSourceRange)(docs, color.range, language_core_1.isColorEnabled);
            if (range) {
              return {
                range,
                color: color.color
              };
            }
          }).filter((color) => !!color);
        }, (arr) => arr.flat());
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentDropEdits.js
var require_provideDocumentDropEdits = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentDropEdits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return (uri, position, dataTransfer, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, function* (docs) {
          for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position)) {
            yield mappedPosition;
          }
        }, (plugin, document, arg) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideDocumentDropEdits?.(document, arg, dataTransfer, token);
        }, (edit) => {
          if (edit.additionalEdit) {
            edit.additionalEdit = (0, transform_1.transformWorkspaceEdit)(edit.additionalEdit, context, void 0);
          }
          return edit;
        });
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentFormattingEdits.js
var require_provideDocumentFormattingEdits = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentFormattingEdits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var common_1 = require_common();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return async (uri, options, range, onTypeParams, token = cancellation_1.NoneCancellationToken) => {
        const sourceScript = context.language.scripts.get(uri);
        if (!sourceScript) {
          return;
        }
        let document = context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
        range ??= {
          start: document.positionAt(0),
          end: document.positionAt(document.getText().length)
        };
        if (!sourceScript.generated) {
          return onTypeParams ? (await tryFormat(document, document, sourceScript, void 0, 0, onTypeParams.position, onTypeParams.ch))?.edits : (await tryFormat(document, document, sourceScript, void 0, 0, range, void 0))?.edits;
        }
        const embeddedRanges = /* @__PURE__ */ new Map();
        const startOffset = document.offsetAt(range.start);
        const endOffset = document.offsetAt(range.end);
        for (const code of (0, language_core_1.forEachEmbeddedCode)(sourceScript.generated.root)) {
          const map = context.language.maps.get(code, sourceScript);
          if (map) {
            const embeddedRange = (0, language_core_1.findOverlapCodeRange)(startOffset, endOffset, map, language_core_1.isFormattingEnabled);
            if (embeddedRange) {
              if (embeddedRange.start === map.mappings[0].generatedOffsets[0]) {
                embeddedRange.start = 0;
              }
              const lastMapping = map.mappings[map.mappings.length - 1];
              if (embeddedRange.end === lastMapping.generatedOffsets[lastMapping.generatedOffsets.length - 1] + (lastMapping.generatedLengths ?? lastMapping.lengths)[lastMapping.lengths.length - 1]) {
                embeddedRange.end = code.snapshot.getLength();
              }
              embeddedRanges.set(code.id, embeddedRange);
            }
          }
        }
        try {
          const originalDocument = document;
          let tempSourceSnapshot = sourceScript.snapshot;
          let tempVirtualFile = context.language.scripts.set(vscode_uri_1.URI.parse(sourceScript.id.toString() + ".tmp"), sourceScript.snapshot, sourceScript.languageId, [sourceScript.generated.languagePlugin])?.generated?.root;
          if (!tempVirtualFile) {
            return;
          }
          let currentCodes = [];
          for (let depth = 0; (currentCodes = getNestedEmbeddedFiles(context, sourceScript.id, tempVirtualFile, depth)).length > 0; depth++) {
            let edits = [];
            for (const code of currentCodes) {
              if (!code.mappings.some((mapping) => (0, language_core_1.isFormattingEnabled)(mapping.data))) {
                continue;
              }
              const currentRange = embeddedRanges.get(code.id);
              if (!currentRange) {
                continue;
              }
              const isChildRange = [...(0, language_core_1.forEachEmbeddedCode)(code)].some((child) => {
                if (child === code) {
                  return false;
                }
                const childRange = embeddedRanges.get(child.id);
                return childRange && childRange.end - childRange.start >= currentRange.end - currentRange.start;
              });
              if (isChildRange) {
                continue;
              }
              const docs = [
                context.documents.get(uri, sourceScript.languageId, tempSourceSnapshot),
                context.documents.get(context.encodeEmbeddedDocumentUri(uri, code.id), code.languageId, code.snapshot),
                context.language.mapperFactory(code.mappings)
              ];
              let embeddedResult;
              if (onTypeParams) {
                for (const embeddedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, onTypeParams.position)) {
                  embeddedResult = await tryFormat(docs[0], docs[1], sourceScript, code, depth, embeddedPosition, onTypeParams.ch);
                  break;
                }
              } else if (currentRange) {
                embeddedResult = await tryFormat(docs[0], docs[1], sourceScript, code, depth, {
                  start: docs[1].positionAt(currentRange.start),
                  end: docs[1].positionAt(currentRange.end)
                });
              }
              if (!embeddedResult) {
                continue;
              }
              for (const textEdit2 of embeddedResult.edits) {
                const range2 = (0, featureWorkers_1.getSourceRange)(docs, textEdit2.range);
                if (range2) {
                  edits.push({
                    newText: textEdit2.newText,
                    range: range2
                  });
                }
              }
            }
            if (edits.length > 0) {
              const newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, edits);
              document = vscode_languageserver_textdocument_1.TextDocument.create(document.uri, document.languageId, document.version + 1, newText);
              tempSourceSnapshot = (0, common_1.stringToSnapshot)(newText);
              tempVirtualFile = context.language.scripts.set(vscode_uri_1.URI.parse(sourceScript.id.toString() + ".tmp"), tempSourceSnapshot, sourceScript.languageId, [sourceScript.generated.languagePlugin])?.generated?.root;
              if (!tempVirtualFile) {
                break;
              }
            }
          }
          if (document.getText() === originalDocument.getText()) {
            return;
          }
          const editRange = {
            start: originalDocument.positionAt(0),
            end: originalDocument.positionAt(originalDocument.getText().length)
          };
          const textEdit = {
            range: editRange,
            newText: document.getText()
          };
          return [textEdit];
        } finally {
          context.language.scripts.delete(vscode_uri_1.URI.parse(sourceScript.id.toString() + ".tmp"));
        }
        async function tryFormat(sourceDocument, document2, sourceScript2, virtualCode, embeddedLevel, rangeOrPosition, ch) {
          if (context.disabledEmbeddedDocumentUris.get(vscode_uri_1.URI.parse(document2.uri))) {
            return;
          }
          let codeOptions;
          rangeOrPosition ??= {
            start: document2.positionAt(0),
            end: document2.positionAt(document2.getText().length)
          };
          if (virtualCode) {
            codeOptions = {
              level: embeddedLevel,
              initialIndentLevel: 0
            };
            if (virtualCode.mappings.length) {
              const firstMapping = virtualCode.mappings[0];
              const startOffset2 = firstMapping.sourceOffsets[0];
              const startPosition = sourceDocument.positionAt(startOffset2);
              codeOptions.initialIndentLevel = computeInitialIndent(sourceDocument.getText(), sourceDocument.offsetAt({ line: startPosition.line, character: 0 }), options);
            }
            for (const plugin of context.plugins) {
              if (context.disabledServicePlugins.has(plugin[1])) {
                continue;
              }
              codeOptions = await plugin[1].resolveEmbeddedCodeFormattingOptions?.(sourceScript2, virtualCode, codeOptions, token) ?? codeOptions;
            }
          }
          for (const plugin of context.plugins) {
            if (context.disabledServicePlugins.has(plugin[1])) {
              continue;
            }
            if (token.isCancellationRequested) {
              break;
            }
            let edits;
            try {
              if (ch !== void 0 && rangeOrPosition && "line" in rangeOrPosition && "character" in rangeOrPosition) {
                if (plugin[0].capabilities.documentOnTypeFormattingProvider?.triggerCharacters?.includes(ch)) {
                  edits = await plugin[1].provideOnTypeFormattingEdits?.(document2, rangeOrPosition, ch, options, codeOptions, token);
                }
              } else if (ch === void 0 && rangeOrPosition && "start" in rangeOrPosition && "end" in rangeOrPosition) {
                edits = await plugin[1].provideDocumentFormattingEdits?.(document2, rangeOrPosition, options, codeOptions, token);
              }
            } catch (err) {
              console.warn(err);
            }
            if (!edits) {
              continue;
            }
            return {
              plugin,
              edits
            };
          }
        }
      };
    }
    function getNestedEmbeddedFiles(context, uri, rootCode, depth) {
      const nestedCodesByLevel = [[rootCode]];
      while (true) {
        if (nestedCodesByLevel.length > depth) {
          return nestedCodesByLevel[depth];
        }
        const nestedCodes = [];
        for (const code of nestedCodesByLevel[nestedCodesByLevel.length - 1]) {
          if (code.embeddedCodes) {
            for (const embedded of code.embeddedCodes) {
              if (!context.disabledEmbeddedDocumentUris.get(context.encodeEmbeddedDocumentUri(uri, embedded.id))) {
                nestedCodes.push(embedded);
              }
            }
          }
        }
        nestedCodesByLevel.push(nestedCodes);
      }
    }
    function computeInitialIndent(content, i, options) {
      let nChars = 0;
      const tabSize = options.tabSize || 4;
      while (i < content.length) {
        const ch = content.charAt(i);
        if (ch === " ") {
          nChars++;
        } else if (ch === "	") {
          nChars += tabSize;
        } else {
          break;
        }
        i++;
      }
      return Math.floor(nChars / tabSize);
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentHighlights.js
var require_provideDocumentHighlights = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentHighlights.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var dedupe = require_dedupe();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, position, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isHighlightEnabled), async (plugin, document, position2) => {
          if (token.isCancellationRequested) {
            return;
          }
          const recursiveChecker = dedupe.createLocationSet();
          const result = [];
          await withLinkedCode(document, position2);
          return result;
          async function withLinkedCode(document2, position3) {
            if (!plugin[1].provideDocumentHighlights) {
              return;
            }
            if (recursiveChecker.has({ uri: document2.uri, range: { start: position3, end: position3 } })) {
              return;
            }
            recursiveChecker.add({ uri: document2.uri, range: { start: position3, end: position3 } });
            const references = await plugin[1].provideDocumentHighlights(document2, position3, token) ?? [];
            for (const reference of references) {
              let foundMirrorPosition = false;
              recursiveChecker.add({
                uri: document2.uri,
                range: { start: reference.range.start, end: reference.range.start }
              });
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(document2.uri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              const linkedCodeMap = virtualCode && sourceScript ? context.language.linkedCodeMaps.get(virtualCode) : void 0;
              if (sourceScript && virtualCode && linkedCodeMap) {
                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, reference.range.start)) {
                  if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
                    continue;
                  }
                  foundMirrorPosition = true;
                  await withLinkedCode(embeddedDocument, linkedPos);
                }
              }
              if (!foundMirrorPosition) {
                result.push(reference);
              }
            }
          }
        }, (data, docs) => data.map((highlight) => {
          if (!docs) {
            return highlight;
          }
          const range = (0, featureWorkers_1.getSourceRange)(docs, highlight.range, language_core_1.isHighlightEnabled);
          if (range) {
            return {
              ...highlight,
              range
            };
          }
        }).filter((highlight) => !!highlight), (arr) => arr.flat());
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentLinks.js
var require_provideDocumentLinks = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentLinks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return async (uri, token = cancellation_1.NoneCancellationToken) => {
        return await (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isDocumentLinkEnabled)(mapping.data)), async (plugin, document) => {
          if (token.isCancellationRequested) {
            return;
          }
          const links = await plugin[1].provideDocumentLinks?.(document, token);
          for (const link of links ?? []) {
            if (plugin[1].resolveDocumentLink) {
              link.data = {
                uri: uri.toString(),
                original: {
                  data: link.data
                },
                pluginIndex: context.plugins.indexOf(plugin)
              };
            } else {
              delete link.data;
            }
          }
          return links;
        }, (links, docs) => {
          if (!docs) {
            return links;
          }
          return links.map((link) => {
            const range = (0, featureWorkers_1.getSourceRange)(docs, link.range, language_core_1.isDocumentLinkEnabled);
            if (!range) {
              return;
            }
            link = {
              ...link,
              range
            };
            if (link.target) {
              link.target = (0, transform_1.transformDocumentLinkTarget)(link.target, context).toString();
            }
            return link;
          }).filter((link) => !!link);
        }, (arr) => arr.flat()) ?? [];
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/SemanticTokensBuilder.js
var require_SemanticTokensBuilder = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/utils/SemanticTokensBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = void 0;
    var SemanticTokensBuilder = class {
      constructor() {
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      build() {
        return {
          resultId: this.id,
          data: this._data
        };
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentSemanticTokens.js
var require_provideDocumentSemanticTokens = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentSemanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    var SemanticTokensBuilder_1 = require_SemanticTokensBuilder();
    function register(context) {
      return async (uri, range, legend, _reportProgress, token = cancellation_1.NoneCancellationToken) => {
        const sourceScript = context.language.scripts.get(uri);
        if (!sourceScript) {
          return;
        }
        const document = context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
        if (!range) {
          range = {
            start: { line: 0, character: 0 },
            end: { line: document.lineCount - 1, character: document.getText().length }
          };
        }
        const tokens = await (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, function* (docs) {
          const mapped = (0, language_core_1.findOverlapCodeRange)(docs[0].offsetAt(range.start), docs[0].offsetAt(range.end), docs[2], language_core_1.isSemanticTokensEnabled);
          if (mapped) {
            yield {
              start: docs[1].positionAt(mapped.start),
              end: docs[1].positionAt(mapped.end)
            };
          }
        }, (plugin, document2, range2) => {
          if (token?.isCancellationRequested) {
            return;
          }
          return plugin[1].provideDocumentSemanticTokens?.(document2, range2, legend, token);
        }, (tokens2, docs) => {
          if (!docs) {
            return tokens2;
          }
          return tokens2.map((_token) => {
            const range2 = (0, featureWorkers_1.getSourceRange)(docs, {
              start: { line: _token[0], character: _token[1] },
              end: { line: _token[0], character: _token[1] + _token[2] }
            }, language_core_1.isSemanticTokensEnabled);
            if (range2) {
              return [
                range2.start.line,
                range2.start.character,
                range2.end.character - range2.start.character,
                _token[3],
                _token[4]
              ];
            }
          }).filter((token2) => !!token2);
        }, (tokens2) => tokens2.flat());
        if (tokens) {
          return buildTokens(tokens);
        }
      };
    }
    function buildTokens(tokens) {
      const builder = new SemanticTokensBuilder_1.SemanticTokensBuilder();
      const sortedTokens = tokens.sort((a, b) => a[0] - b[0] === 0 ? a[1] - b[1] : a[0] - b[0]);
      for (const token of sortedTokens) {
        builder.push(...token);
      }
      return builder.build();
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentSymbols.js
var require_provideDocumentSymbols = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideDocumentSymbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var common_1 = require_common();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return (uri, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isSymbolsEnabled)(mapping.data)), (plugin, document) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideDocumentSymbols?.(document, token);
        }, (data, docs) => {
          if (!docs) {
            return data;
          }
          return data.map((symbol) => (0, transform_1.transformDocumentSymbol)(symbol, (range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isSymbolsEnabled))).filter((symbol) => !!symbol);
        }, (results) => {
          for (let i = 0; i < results.length; i++) {
            for (let j = 0; j < results.length; j++) {
              if (i === j) {
                continue;
              }
              results[i] = results[i].filter((child) => {
                for (const parent of forEachSymbol(results[j])) {
                  if ((0, common_1.isInsideRange)(parent.range, child.range)) {
                    parent.children ??= [];
                    parent.children.push(child);
                    return false;
                  }
                }
                return true;
              });
            }
          }
          return results.flat();
        });
      };
    }
    function* forEachSymbol(symbols) {
      for (const symbol of symbols) {
        if (symbol.children) {
          yield* forEachSymbol(symbol.children);
        }
        yield symbol;
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideFileReferences.js
var require_provideFileReferences = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideFileReferences.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var dedupe = require_dedupe();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.documentFeatureWorker)(context, uri, () => true, async (plugin, document) => {
          if (token.isCancellationRequested) {
            return;
          }
          return await plugin[1].provideFileReferences?.(document, token) ?? [];
        }, (data) => data.map((reference) => {
          const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(reference.uri));
          const sourceScript = decoded && context.language.scripts.get(decoded[0]);
          const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
          if (!sourceScript || !virtualCode) {
            return reference;
          }
          const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
          for (const [sourceScript2, map] of context.language.maps.forEach(virtualCode)) {
            const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
            const docs = [sourceDocument, embeddedDocument, map];
            const range = (0, featureWorkers_1.getSourceRange)(docs, reference.range, language_core_1.isReferencesEnabled);
            if (range) {
              reference.uri = sourceDocument.uri;
              reference.range = range;
              return reference;
            }
          }
        }).filter((reference) => !!reference), (arr) => dedupe.withLocations(arr.flat()));
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideFileRenameEdits.js
var require_provideFileRenameEdits = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideFileRenameEdits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var cancellation_1 = require_cancellation2();
    var dedupe = require_dedupe();
    var transform_1 = require_transform();
    function register(context) {
      return async (oldUri, newUri, token = cancellation_1.NoneCancellationToken) => {
        for (const plugin of context.plugins) {
          if (context.disabledServicePlugins.has(plugin[1])) {
            continue;
          }
          if (token.isCancellationRequested) {
            break;
          }
          if (!plugin[1].provideFileRenameEdits) {
            continue;
          }
          const workspaceEdit = await plugin[1].provideFileRenameEdits(oldUri, newUri, token);
          if (workspaceEdit) {
            const result = (0, transform_1.transformWorkspaceEdit)(workspaceEdit, context, "fileName");
            if (result?.documentChanges) {
              result.documentChanges = dedupe.withDocumentChanges(result.documentChanges);
            }
            return result;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideFoldingRanges.js
var require_provideFoldingRanges = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideFoldingRanges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return (uri, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isFoldingRangesEnabled)(mapping.data)), (plugin, document) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideFoldingRanges?.(document, token);
        }, (data, docs) => {
          if (!docs) {
            return data;
          }
          return (0, transform_1.transformFoldingRanges)(data, (range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isFoldingRangesEnabled));
        }, (arr) => arr.flat());
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideHover.js
var require_provideHover = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideHover.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var common_1 = require_common();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    var provideDiagnostics_1 = require_provideDiagnostics();
    function register(context) {
      return async (uri, position, token = cancellation_1.NoneCancellationToken) => {
        let hover = await (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isHoverEnabled), (plugin, document, position2) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideHover?.(document, position2, token);
        }, (item, docs) => {
          if (!docs || !item.range) {
            return item;
          }
          item.range = (0, featureWorkers_1.getSourceRange)(docs, item.range, language_core_1.isHoverEnabled);
          return item;
        }, (hovers) => ({
          contents: {
            kind: "markdown",
            value: hovers.map(getHoverTexts).flat().join("\n\n---\n\n")
          },
          range: hovers.find((hover2) => hover2.range && (0, common_1.isInsideRange)(hover2.range, { start: position, end: position }))?.range ?? hovers[0].range
        }));
        const markups = provideDiagnostics_1.errorMarkups.get(uri);
        if (markups) {
          for (const errorAndMarkup of markups) {
            if ((0, common_1.isInsideRange)(errorAndMarkup.error.range, { start: position, end: position })) {
              hover ??= {
                contents: {
                  kind: "markdown",
                  value: ""
                }
              };
              hover.range = errorAndMarkup.error.range;
              if (typeof hover.contents !== "object" || typeof hover.contents !== "string") {
                hover.contents = {
                  kind: "markdown",
                  value: hover.contents
                };
              }
              if (hover.contents.value) {
                hover.contents.value += "\n\n---\n\n";
              }
              hover.contents.value += errorAndMarkup.markup.value;
            }
          }
        }
        return hover;
      };
      function getHoverTexts(hover) {
        if (typeof hover.contents === "string") {
          return [(0, transform_1.transformMarkdown)(hover.contents, context)];
        }
        if (Array.isArray(hover.contents)) {
          return hover.contents.map((content) => {
            if (typeof content === "string") {
              return (0, transform_1.transformMarkdown)(content, context);
            }
            if (content.language === "md") {
              return `\`\`\`${content.language}
${(0, transform_1.transformMarkdown)(content.value, context)}
\`\`\``;
            } else {
              return `\`\`\`${content.language}
${content.value}
\`\`\``;
            }
          });
        }
        if ("kind" in hover.contents) {
          if (hover.contents.kind === "markdown") {
            return [(0, transform_1.transformMarkdown)(hover.contents.value, context)];
          } else {
            return [hover.contents.value];
          }
        }
        if (hover.contents.language === "md") {
          return [`\`\`\`${hover.contents.language}
${(0, transform_1.transformMarkdown)(hover.contents.value, context)}
\`\`\``];
        } else {
          return [`\`\`\`${hover.contents.language}
${hover.contents.value}
\`\`\``];
        }
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideInlayHints.js
var require_provideInlayHints = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideInlayHints.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return (uri, range, token = cancellation_1.NoneCancellationToken) => {
        const sourceScript = context.language.scripts.get(uri);
        if (!sourceScript) {
          return;
        }
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, function* (docs) {
          const mapped = (0, language_core_1.findOverlapCodeRange)(docs[0].offsetAt(range.start), docs[0].offsetAt(range.end), docs[2], language_core_1.isInlayHintsEnabled);
          if (mapped) {
            yield {
              start: docs[1].positionAt(mapped.start),
              end: docs[1].positionAt(mapped.end)
            };
          }
        }, async (plugin, document, arg) => {
          if (token.isCancellationRequested) {
            return;
          }
          const hints = await plugin[1].provideInlayHints?.(document, arg, token);
          hints?.forEach((link) => {
            if (plugin[1].resolveInlayHint) {
              link.data = {
                uri: uri.toString(),
                original: {
                  data: link.data
                },
                pluginIndex: context.plugins.indexOf(plugin)
              };
            } else {
              delete link.data;
            }
          });
          return hints;
        }, (inlayHints, docs) => {
          if (!docs) {
            return inlayHints;
          }
          return inlayHints.map((_inlayHint) => {
            const edits = _inlayHint.textEdits?.map((textEdit) => (0, transform_1.transformTextEdit)(textEdit, (range2) => (0, featureWorkers_1.getSourceRange)(docs, range2), docs[1])).filter((textEdit) => !!textEdit);
            for (const position of (0, featureWorkers_1.getSourcePositions)(docs, _inlayHint.position, language_core_1.isInlayHintsEnabled)) {
              return {
                ..._inlayHint,
                position,
                textEdits: edits
              };
            }
          }).filter((hint) => !!hint);
        }, (arr) => arr.flat());
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideInlineValue.js
var require_provideInlineValue = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideInlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, range, ivContext, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, (docs) => (0, featureWorkers_1.getGeneratedRanges)(docs, range, language_core_1.isInlineValueEnabled), (plugin, document, range2) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideInlineValues?.(document, range2, ivContext, token);
        }, (items, docs) => {
          if (!docs) {
            return items;
          }
          return items.map((item) => {
            const mappedRange = (0, featureWorkers_1.getSourceRange)(docs, item.range, language_core_1.isInlineValueEnabled);
            if (mappedRange) {
              item.range = mappedRange;
              return item;
            }
          }).filter((item) => !!item);
        }, (results) => results.flat());
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideLinkedEditingRanges.js
var require_provideLinkedEditingRanges = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideLinkedEditingRanges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, position, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, function* (docs) {
          for (const pos of (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isLinkedEditingEnabled)) {
            yield pos;
          }
        }, (plugin, document, position2) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideLinkedEditingRanges?.(document, position2, token);
        }, (ranges, docs) => {
          if (!docs) {
            return ranges;
          }
          return {
            wordPattern: ranges.wordPattern,
            ranges: ranges.ranges.map((range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isLinkedEditingEnabled)).filter((range) => !!range)
          };
        });
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideMoniker.js
var require_provideMoniker = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideMoniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, position, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isMonikerEnabled), (plugin, document, position2) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideMoniker?.(document, position2, token);
        }, (result) => result, (results) => results.flat());
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideReferences.js
var require_provideReferences = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideReferences.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var dedupe = require_dedupe();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, position, referenceContext, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isReferencesEnabled), async (plugin, document, position2) => {
          if (token.isCancellationRequested) {
            return;
          }
          const recursiveChecker = dedupe.createLocationSet();
          const result = [];
          await withLinkedCode(document, position2);
          return result;
          async function withLinkedCode(document2, position3) {
            if (!plugin[1].provideReferences) {
              return;
            }
            if (recursiveChecker.has({ uri: document2.uri, range: { start: position3, end: position3 } })) {
              return;
            }
            recursiveChecker.add({ uri: document2.uri, range: { start: position3, end: position3 } });
            const references = await plugin[1].provideReferences(document2, position3, referenceContext, token) ?? [];
            for (const reference of references) {
              let foundMirrorPosition = false;
              recursiveChecker.add({
                uri: reference.uri,
                range: { start: reference.range.start, end: reference.range.start }
              });
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(reference.uri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              const linkedCodeMap = virtualCode && sourceScript ? context.language.linkedCodeMaps.get(virtualCode) : void 0;
              if (sourceScript && virtualCode && linkedCodeMap) {
                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, reference.range.start)) {
                  if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
                    continue;
                  }
                  foundMirrorPosition = true;
                  await withLinkedCode(embeddedDocument, linkedPos);
                }
              }
              if (!foundMirrorPosition) {
                result.push(reference);
              }
            }
          }
        }, (data) => {
          const results = [];
          for (const reference of data) {
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(reference.uri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (sourceScript && virtualCode) {
              const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
              for (const [sourceScript2, map] of context.language.maps.forEach(virtualCode)) {
                const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
                const docs = [sourceDocument, embeddedDocument, map];
                const range = (0, featureWorkers_1.getSourceRange)(docs, reference.range, language_core_1.isReferencesEnabled);
                if (range) {
                  results.push({
                    uri: sourceDocument.uri,
                    range
                  });
                }
              }
            } else {
              results.push(reference);
            }
          }
          return results;
        }, (arr) => dedupe.withLocations(arr.flat()));
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideRenameRange.js
var require_provideRenameRange = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideRenameRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, position, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isRenameEnabled), (plugin, document, position2) => {
          if (token.isCancellationRequested) {
            return;
          }
          return plugin[1].provideRenameRange?.(document, position2, token);
        }, (item, docs) => {
          if (!docs) {
            return item;
          }
          if ("start" in item && "end" in item) {
            return (0, featureWorkers_1.getSourceRange)(docs, item);
          }
          return item;
        }, (prepares) => {
          for (const prepare of prepares) {
            if ("start" in prepare && "end" in prepare) {
              return prepare;
            }
          }
          return prepares[0];
        });
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideSelectionRanges.js
var require_provideSelectionRanges = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideSelectionRanges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var common_1 = require_common();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return (uri, positions, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => positions, function* (docs) {
          const result = positions.map((position) => {
            for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isSelectionRangesEnabled)) {
              return mappedPosition;
            }
          }).filter((position) => !!position);
          if (result.length) {
            yield result;
          }
        }, async (plugin, document, positions2) => {
          if (token.isCancellationRequested) {
            return;
          }
          const selectionRanges = await plugin[1].provideSelectionRanges?.(document, positions2, token);
          if (selectionRanges && selectionRanges.length !== positions2.length) {
            console.error("Selection ranges count should be equal to positions count:", plugin[0].name, selectionRanges.length, positions2.length);
            return;
          }
          return selectionRanges;
        }, (data, docs) => {
          if (!docs) {
            return data;
          }
          return (0, transform_1.transformSelectionRanges)(data, (range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isSelectionRangesEnabled));
        }, (results) => {
          const result = [];
          for (let i = 0; i < positions.length; i++) {
            let pluginResults = [];
            for (const ranges of results) {
              pluginResults.push(ranges[i]);
            }
            pluginResults = pluginResults.sort((a, b) => {
              if ((0, common_1.isInsideRange)(a.range, b.range)) {
                return 1;
              }
              if ((0, common_1.isInsideRange)(b.range, a.range)) {
                return -1;
              }
              return 0;
            });
            for (let j = 1; j < pluginResults.length; j++) {
              let top = pluginResults[j - 1];
              const parent = pluginResults[j];
              while (top.parent && (0, common_1.isInsideRange)(parent.range, top.parent.range) && !(0, common_1.isEqualRange)(parent.range, top.parent.range)) {
                top = top.parent;
              }
              if (top) {
                top.parent = parent;
              }
            }
            result.push(pluginResults[0]);
          }
          return result;
        });
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideSignatureHelp.js
var require_provideSignatureHelp = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideSignatureHelp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_core_1 = require_language_core();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    function register(context) {
      return (uri, position, signatureHelpContext = {
        triggerKind: 1,
        isRetrigger: false
      }, token = cancellation_1.NoneCancellationToken) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isSignatureHelpEnabled), (plugin, document, position2) => {
          if (token.isCancellationRequested) {
            return;
          }
          if (signatureHelpContext?.triggerKind === 2 && signatureHelpContext.triggerCharacter && !(signatureHelpContext.isRetrigger ? plugin[0].capabilities.signatureHelpProvider?.retriggerCharacters : plugin[0].capabilities.signatureHelpProvider?.triggerCharacters)?.includes(signatureHelpContext.triggerCharacter)) {
            return;
          }
          return plugin[1].provideSignatureHelp?.(document, position2, signatureHelpContext, token);
        }, (data) => data);
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideWorkspaceDiagnostics.js
var require_provideWorkspaceDiagnostics = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideWorkspaceDiagnostics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var provideDiagnostics_1 = require_provideDiagnostics();
    function register(context) {
      return async (token = cancellation_1.NoneCancellationToken) => {
        const allItems = [];
        for (const plugin of context.plugins) {
          if (context.disabledServicePlugins.has(plugin[1])) {
            continue;
          }
          if (token.isCancellationRequested) {
            break;
          }
          if (!plugin[1].provideWorkspaceDiagnostics) {
            continue;
          }
          const report = await plugin[1].provideWorkspaceDiagnostics(token);
          if (!report) {
            continue;
          }
          const items = report.map((item) => {
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(item.uri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (virtualCode && sourceScript) {
              if (item.kind === "unchanged") {
                return {
                  ...item,
                  uri: sourceScript.id.toString()
                };
              } else {
                const map = context.language.maps.get(virtualCode, sourceScript);
                const docs = [
                  context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot),
                  context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot),
                  map
                ];
                return {
                  ...item,
                  items: item.items.map((error) => (0, provideDiagnostics_1.transformDiagnostic)(context, error, docs)).filter((error) => !!error)
                };
              }
            } else {
              if (item.kind === "unchanged") {
                return item;
              }
              return {
                ...item,
                items: item.items.map((error) => (0, provideDiagnostics_1.transformDiagnostic)(context, error, void 0)).filter((error) => !!error)
              };
            }
          });
          allItems.push(...items);
        }
        return allItems;
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideWorkspaceSymbols.js
var require_provideWorkspaceSymbols = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/provideWorkspaceSymbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return async (query, token = cancellation_1.NoneCancellationToken) => {
        const symbolsList = [];
        for (const plugin of context.plugins) {
          if (context.disabledServicePlugins.has(plugin[1])) {
            continue;
          }
          if (token.isCancellationRequested) {
            break;
          }
          if (!plugin[1].provideWorkspaceSymbols) {
            continue;
          }
          const embeddedSymbols = await plugin[1].provideWorkspaceSymbols(query, token);
          if (!embeddedSymbols) {
            continue;
          }
          const symbols = embeddedSymbols.map((symbol) => (0, transform_1.transformWorkspaceSymbol)(symbol, (loc) => {
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(loc.uri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (sourceScript && virtualCode) {
              const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
              for (const [sourceScript2, map] of context.language.maps.forEach(virtualCode)) {
                const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
                const docs = [sourceDocument, embeddedDocument, map];
                const range = (0, featureWorkers_1.getSourceRange)(docs, loc.range);
                if (range) {
                  return { uri: sourceDocument.uri, range };
                }
              }
            } else {
              return loc;
            }
          })).filter((symbol) => !!symbol);
          symbols?.forEach((symbol) => {
            if (plugin[1].resolveWorkspaceSymbol) {
              symbol.data = {
                original: {
                  data: symbol.data
                },
                pluginIndex: context.plugins.indexOf(plugin)
              };
            } else {
              delete symbol.data;
            }
          });
          symbolsList.push(symbols);
        }
        return symbolsList.flat();
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveCodeAction.js
var require_resolveCodeAction = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveCodeAction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var cancellation_1 = require_cancellation2();
    var transform_1 = require_transform();
    function register(context) {
      return async (item, token = cancellation_1.NoneCancellationToken) => {
        const data = item.data;
        if (data) {
          const plugin = context.plugins[data.pluginIndex];
          if (!plugin[1].resolveCodeAction) {
            delete item.data;
            return item;
          }
          Object.assign(item, data.original);
          item = await plugin[1].resolveCodeAction(item, token);
          item = plugin[1].transformCodeAction?.(item) ?? (item.edit ? {
            ...item,
            edit: (0, transform_1.transformWorkspaceEdit)(item.edit, context, "codeAction", { [data.uri]: data.version })
          } : item);
        }
        delete item.data;
        return item;
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveCodeLens.js
var require_resolveCodeLens = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveCodeLens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var references = require_provideReferences();
    function register(context) {
      const findReferences = references.register(context);
      return async (item, token = cancellation_1.NoneCancellationToken) => {
        const data = item.data;
        if (data?.kind === "normal") {
          const plugin = context.plugins[data.pluginIndex];
          if (!plugin[1].resolveCodeLens) {
            delete item.data;
            return item;
          }
          Object.assign(item, data.original);
          item = await plugin[1].resolveCodeLens(item, token);
        } else if (data?.kind === "references") {
          const references2 = await findReferences(vscode_uri_1.URI.parse(data.sourceFileUri), item.range.start, { includeDeclaration: false }, token) ?? [];
          item.command = context.commands.showReferences.create(data.sourceFileUri, item.range.start, references2);
        }
        delete item.data;
        return item;
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveCompletionItem.js
var require_resolveCompletionItem = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveCompletionItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var vscode_uri_1 = require_umd();
    var cancellation_1 = require_cancellation2();
    var featureWorkers_1 = require_featureWorkers();
    var transform_1 = require_transform();
    function register(context) {
      return async (item, token = cancellation_1.NoneCancellationToken) => {
        const data = item.data;
        if (data) {
          const plugin = context.plugins[data.pluginIndex];
          if (!plugin[1].resolveCompletionItem) {
            delete item.data;
            return item;
          }
          item = Object.assign(item, data.original);
          if (data.embeddedDocumentUri) {
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (sourceScript && virtualCode) {
              const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
              for (const [sourceScript2, map] of context.language.maps.forEach(virtualCode)) {
                const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
                const docs = [sourceDocument, embeddedDocument, map];
                item = await plugin[1].resolveCompletionItem(item, token);
                item = plugin[1].transformCompletionItem?.(item) ?? (0, transform_1.transformCompletionItem)(item, (embeddedRange) => (0, featureWorkers_1.getSourceRange)(docs, embeddedRange), embeddedDocument, context);
              }
            }
          } else {
            item = await plugin[1].resolveCompletionItem(item, token);
          }
        }
        delete item.data;
        return item;
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveDocumentLink.js
var require_resolveDocumentLink = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveDocumentLink.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var cancellation_1 = require_cancellation2();
    var transform_1 = require_transform();
    function register(context) {
      return async (item, token = cancellation_1.NoneCancellationToken) => {
        const data = item.data;
        if (data) {
          const plugin = context.plugins[data.pluginIndex];
          if (!plugin[1].resolveDocumentLink) {
            delete item.data;
            return item;
          }
          Object.assign(item, data.original);
          item = await plugin[1].resolveDocumentLink(item, token);
          if (item.target) {
            item.target = (0, transform_1.transformDocumentLinkTarget)(item.target, context).toString();
          }
        }
        delete item.data;
        return item;
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveInlayHint.js
var require_resolveInlayHint = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveInlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var cancellation_1 = require_cancellation2();
    function register(context) {
      return async (item, token = cancellation_1.NoneCancellationToken) => {
        const data = item.data;
        if (data) {
          const plugin = context.plugins[data.pluginIndex];
          if (!plugin[1].resolveInlayHint) {
            delete item.data;
            return item;
          }
          Object.assign(item, data.original);
          item = await plugin[1].resolveInlayHint(item, token);
        }
        delete item.data;
        return item;
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveWorkspaceSymbol.js
var require_resolveWorkspaceSymbol = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/features/resolveWorkspaceSymbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var cancellation_1 = require_cancellation2();
    function register(context) {
      return async (item, token = cancellation_1.NoneCancellationToken) => {
        const data = item.data;
        if (data) {
          const plugin = context.plugins[data.pluginIndex];
          if (!plugin[1].resolveWorkspaceSymbol) {
            delete item.data;
            return item;
          }
          Object.assign(item, data.original);
          item = await plugin[1].resolveWorkspaceSymbol(item, token);
        }
        delete item.data;
        return item;
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/languageService.js
var require_languageService = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/languageService.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.embeddedContentScheme = void 0;
    exports2.createLanguageService = createLanguageService;
    exports2.decodeEmbeddedDocumentUri = decodeEmbeddedDocumentUri;
    exports2.encodeEmbeddedDocumentUri = encodeEmbeddedDocumentUri;
    var language_core_1 = require_language_core();
    var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
    var vscode_uri_1 = require_umd();
    var autoInsert = require_provideAutoInsertSnippet();
    var hierarchy = require_provideCallHierarchyItems();
    var codeActions = require_provideCodeActions();
    var codeLens = require_provideCodeLenses();
    var colorPresentations = require_provideColorPresentations();
    var completions = require_provideCompletionItems();
    var definition = require_provideDefinition();
    var diagnostics = require_provideDiagnostics();
    var documentColors = require_provideDocumentColors();
    var documentDrop = require_provideDocumentDropEdits();
    var format = require_provideDocumentFormattingEdits();
    var documentHighlight = require_provideDocumentHighlights();
    var documentLink = require_provideDocumentLinks();
    var semanticTokens = require_provideDocumentSemanticTokens();
    var documentSymbols = require_provideDocumentSymbols();
    var fileReferences = require_provideFileReferences();
    var fileRename = require_provideFileRenameEdits();
    var foldingRanges = require_provideFoldingRanges();
    var hover = require_provideHover();
    var inlayHints = require_provideInlayHints();
    var inlineValue = require_provideInlineValue();
    var linkedEditing = require_provideLinkedEditingRanges();
    var moniker = require_provideMoniker();
    var references = require_provideReferences();
    var rename = require_provideRenameEdits();
    var renamePrepare = require_provideRenameRange();
    var selectionRanges = require_provideSelectionRanges();
    var signatureHelp = require_provideSignatureHelp();
    var workspaceDiagnostics = require_provideWorkspaceDiagnostics();
    var workspaceSymbol = require_provideWorkspaceSymbols();
    var codeActionResolve = require_resolveCodeAction();
    var codeLensResolve = require_resolveCodeLens();
    var completionResolve = require_resolveCompletionItem();
    var documentLinkResolve = require_resolveDocumentLink();
    var inlayHintResolve = require_resolveInlayHint();
    var workspaceSymbolResolve = require_resolveWorkspaceSymbol();
    var cancellation_1 = require_cancellation2();
    var uriMap_1 = require_uriMap();
    exports2.embeddedContentScheme = "volar-embedded-content";
    function createLanguageService(language, plugins, env, project) {
      const documentVersions = (0, uriMap_1.createUriMap)();
      const snapshot2Doc = /* @__PURE__ */ new WeakMap();
      const context = {
        language,
        project,
        getLanguageService: () => langaugeService,
        documents: {
          get(uri, languageId, snapshot) {
            if (!snapshot2Doc.has(snapshot)) {
              snapshot2Doc.set(snapshot, (0, uriMap_1.createUriMap)());
            }
            const map = snapshot2Doc.get(snapshot);
            if (!map.has(uri)) {
              const version = documentVersions.get(uri) ?? 0;
              documentVersions.set(uri, version + 1);
              map.set(uri, vscode_languageserver_textdocument_1.TextDocument.create(uri.toString(), languageId, version, snapshot.getText(0, snapshot.getLength())));
            }
            return map.get(uri);
          }
        },
        env,
        inject: (key, ...args) => {
          for (const plugin of context.plugins) {
            if (context.disabledServicePlugins.has(plugin[1])) {
              continue;
            }
            const provide = plugin[1].provide?.[key];
            if (provide) {
              return provide(...args);
            }
          }
        },
        plugins: [],
        commands: {
          rename: {
            create(uri, position) {
              return {
                title: "",
                command: "editor.action.rename",
                arguments: [
                  uri,
                  position
                ]
              };
            },
            is(command) {
              return command.command === "editor.action.rename";
            }
          },
          showReferences: {
            create(uri, position, locations) {
              return {
                title: locations.length === 1 ? "1 reference" : `${locations.length} references`,
                command: "editor.action.showReferences",
                arguments: [
                  uri,
                  position,
                  locations
                ]
              };
            },
            is(command) {
              return command.command === "editor.action.showReferences";
            }
          },
          setSelection: {
            create(position) {
              return {
                title: "",
                command: "setSelection",
                arguments: [{
                  selection: {
                    selectionStartLineNumber: position.line + 1,
                    positionLineNumber: position.line + 1,
                    selectionStartColumn: position.character + 1,
                    positionColumn: position.character + 1
                  }
                }]
              };
            },
            is(command) {
              return command.command === "setSelection";
            }
          }
        },
        disabledEmbeddedDocumentUris: (0, uriMap_1.createUriMap)(),
        disabledServicePlugins: /* @__PURE__ */ new WeakSet(),
        decodeEmbeddedDocumentUri,
        encodeEmbeddedDocumentUri
      };
      for (const plugin of plugins) {
        context.plugins.push([plugin, plugin.create(context)]);
      }
      const langaugeService = createLanguageServiceBase(plugins, context);
      return langaugeService;
    }
    function decodeEmbeddedDocumentUri(maybeEmbeddedContentUri) {
      if (maybeEmbeddedContentUri.scheme === exports2.embeddedContentScheme) {
        const embeddedCodeId = decodeURIComponent(maybeEmbeddedContentUri.authority);
        const documentUri = decodeURIComponent(maybeEmbeddedContentUri.path.substring(1));
        return [
          vscode_uri_1.URI.parse(documentUri),
          embeddedCodeId
        ];
      }
    }
    function encodeEmbeddedDocumentUri(documentUri, embeddedContentId) {
      if (embeddedContentId !== embeddedContentId.toLowerCase()) {
        console.error(`embeddedContentId must be lowercase: ${embeddedContentId}`);
      }
      return vscode_uri_1.URI.from({
        scheme: exports2.embeddedContentScheme,
        authority: encodeURIComponent(embeddedContentId),
        path: "/" + encodeURIComponent(documentUri.toString())
      });
    }
    function createLanguageServiceBase(plugins, context) {
      const tokenModifiers = plugins.map((plugin) => plugin.capabilities.semanticTokensProvider?.legend?.tokenModifiers ?? []).flat();
      const tokenTypes = plugins.map((plugin) => plugin.capabilities.semanticTokensProvider?.legend?.tokenTypes ?? []).flat();
      return {
        semanticTokenLegend: {
          tokenModifiers: [...new Set(tokenModifiers)],
          tokenTypes: [...new Set(tokenTypes)]
        },
        commands: plugins.map((plugin) => plugin.capabilities.executeCommandProvider?.commands ?? []).flat(),
        triggerCharacters: plugins.map((plugin) => plugin.capabilities.completionProvider?.triggerCharacters ?? []).flat(),
        autoFormatTriggerCharacters: plugins.map((plugin) => plugin.capabilities.documentOnTypeFormattingProvider?.triggerCharacters ?? []).flat(),
        signatureHelpTriggerCharacters: plugins.map((plugin) => plugin.capabilities.signatureHelpProvider?.triggerCharacters ?? []).flat(),
        signatureHelpRetriggerCharacters: plugins.map((plugin) => plugin.capabilities.signatureHelpProvider?.retriggerCharacters ?? []).flat(),
        executeCommand(command, args, token = cancellation_1.NoneCancellationToken) {
          for (const plugin of context.plugins) {
            if (context.disabledServicePlugins.has(plugin[1])) {
              continue;
            }
            if (!plugin[1].executeCommand || !plugin[0].capabilities.executeCommandProvider?.commands.includes(command)) {
              continue;
            }
            return plugin[1].executeCommand(command, args, token);
          }
        },
        getDocumentFormattingEdits: format.register(context),
        getFoldingRanges: foldingRanges.register(context),
        getSelectionRanges: selectionRanges.register(context),
        getLinkedEditingRanges: linkedEditing.register(context),
        getDocumentSymbols: documentSymbols.register(context),
        getDocumentColors: documentColors.register(context),
        getColorPresentations: colorPresentations.register(context),
        getDiagnostics: diagnostics.register(context),
        getWorkspaceDiagnostics: workspaceDiagnostics.register(context),
        getReferences: references.register(context),
        getFileReferences: fileReferences.register(context),
        getDeclaration: definition.register(context, "provideDeclaration", language_core_1.isDefinitionEnabled),
        getDefinition: definition.register(context, "provideDefinition", language_core_1.isDefinitionEnabled),
        getTypeDefinition: definition.register(context, "provideTypeDefinition", language_core_1.isTypeDefinitionEnabled),
        getImplementations: definition.register(context, "provideImplementation", language_core_1.isImplementationEnabled),
        getRenameRange: renamePrepare.register(context),
        getRenameEdits: rename.register(context),
        getFileRenameEdits: fileRename.register(context),
        getSemanticTokens: semanticTokens.register(context),
        getHover: hover.register(context),
        getCompletionItems: completions.register(context),
        getCodeActions: codeActions.register(context),
        getSignatureHelp: signatureHelp.register(context),
        getCodeLenses: codeLens.register(context),
        getDocumentHighlights: documentHighlight.register(context),
        getDocumentLinks: documentLink.register(context),
        getWorkspaceSymbols: workspaceSymbol.register(context),
        getAutoInsertSnippet: autoInsert.register(context),
        getDocumentDropEdits: documentDrop.register(context),
        getInlayHints: inlayHints.register(context),
        getMoniker: moniker.register(context),
        getInlineValue: inlineValue.register(context),
        resolveCodeAction: codeActionResolve.register(context),
        resolveCompletionItem: completionResolve.register(context),
        resolveCodeLens: codeLensResolve.register(context),
        resolveDocumentLink: documentLinkResolve.register(context),
        resolveInlayHint: inlayHintResolve.register(context),
        resolveWorkspaceSymbol: workspaceSymbolResolve.register(context),
        ...hierarchy.register(context),
        dispose: () => context.plugins.forEach((plugin) => plugin[1].dispose?.()),
        context
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/types.js
var require_types2 = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileType = void 0;
    var FileType;
    (function(FileType2) {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
    })(FileType || (exports2.FileType = FileType = {}));
  }
});

// node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/index.js
var require_language_service = __commonJS({
  "node_modules/.pnpm/@volar+language-service@2.4.26/node_modules/@volar/language-service/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeWorkspaceEdits = void 0;
    __exportStar2(require_language_core(), exports2);
    var provideRenameEdits_1 = require_provideRenameEdits();
    Object.defineProperty(exports2, "mergeWorkspaceEdits", { enumerable: true, get: function() {
      return provideRenameEdits_1.mergeWorkspaceEdits;
    } });
    __exportStar2(require_languageService(), exports2);
    __exportStar2(require_types2(), exports2);
    __exportStar2(require_transform(), exports2);
    __exportStar2(require_uriMap(), exports2);
  }
});

// node_modules/.pnpm/request-light@0.7.0/node_modules/request-light/lib/node/main.js
var require_main5 = __commonJS({
  "node_modules/.pnpm/request-light@0.7.0/node_modules/request-light/lib/node/main.js"(exports2) {
    "use strict";
    (() => {
      var e = { 46: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, { signal: r2 } = {}) {
          return new Promise(((o2, n2) => {
            function s() {
              null == r2 || r2.removeEventListener("abort", s), e3.removeListener(t3, a), e3.removeListener("error", u);
            }
            function a(...e4) {
              s(), o2(e4);
            }
            function u(e4) {
              s(), n2(e4);
            }
            null == r2 || r2.addEventListener("abort", s), e3.on(t3, a), e3.on("error", u);
          }));
        };
      }, 54: function(e2, t2, r2) {
        "use strict";
        var o2 = this && this.__importDefault || function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        };
        const n2 = r2(361), s = o2(r2(374)), a = o2(r2(304)), u = s.default("agent-base");
        function i() {
          const { stack: e3 } = new Error();
          return "string" == typeof e3 && e3.split("\n").some(((e4) => -1 !== e4.indexOf("(https.js:") || -1 !== e4.indexOf("node:https:")));
        }
        function c(e3, t3) {
          return new c.Agent(e3, t3);
        }
        !(function(e3) {
          class t3 extends n2.EventEmitter {
            constructor(e4, t4) {
              super();
              let r3 = t4;
              "function" == typeof e4 ? this.callback = e4 : e4 && (r3 = e4), this.timeout = null, r3 && "number" == typeof r3.timeout && (this.timeout = r3.timeout), this.maxFreeSockets = 1, this.maxSockets = 1, this.maxTotalSockets = 1 / 0, this.sockets = {}, this.freeSockets = {}, this.requests = {}, this.options = {};
            }
            get defaultPort() {
              return "number" == typeof this.explicitDefaultPort ? this.explicitDefaultPort : i() ? 443 : 80;
            }
            set defaultPort(e4) {
              this.explicitDefaultPort = e4;
            }
            get protocol() {
              return "string" == typeof this.explicitProtocol ? this.explicitProtocol : i() ? "https:" : "http:";
            }
            set protocol(e4) {
              this.explicitProtocol = e4;
            }
            callback(e4, t4, r3) {
              throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
            }
            addRequest(e4, t4) {
              const r3 = Object.assign({}, t4);
              "boolean" != typeof r3.secureEndpoint && (r3.secureEndpoint = i()), null == r3.host && (r3.host = "localhost"), null == r3.port && (r3.port = r3.secureEndpoint ? 443 : 80), null == r3.protocol && (r3.protocol = r3.secureEndpoint ? "https:" : "http:"), r3.host && r3.path && delete r3.path, delete r3.agent, delete r3.hostname, delete r3._defaultAgent, delete r3.defaultPort, delete r3.createConnection, e4._last = true, e4.shouldKeepAlive = false;
              let o3 = false, n3 = null;
              const s2 = r3.timeout || this.timeout, c2 = (t5) => {
                e4._hadError || (e4.emit("error", t5), e4._hadError = true);
              }, l = () => {
                n3 = null, o3 = true;
                const e5 = new Error(`A "socket" was not created for HTTP request before ${s2}ms`);
                e5.code = "ETIMEOUT", c2(e5);
              }, d = (e5) => {
                o3 || (null !== n3 && (clearTimeout(n3), n3 = null), c2(e5));
              }, f = (t5) => {
                if (o3) return;
                if (null != n3 && (clearTimeout(n3), n3 = null), s3 = t5, Boolean(s3) && "function" == typeof s3.addRequest) return u("Callback returned another Agent instance %o", t5.constructor.name), void t5.addRequest(e4, r3);
                var s3;
                if (t5) return t5.once("free", (() => {
                  this.freeSocket(t5, r3);
                })), void e4.onSocket(t5);
                const a2 = new Error(`no Duplex stream was returned to agent-base for \`${e4.method} ${e4.path}\``);
                c2(a2);
              };
              if ("function" == typeof this.callback) {
                this.promisifiedCallback || (this.callback.length >= 3 ? (u("Converting legacy callback function to promise"), this.promisifiedCallback = a.default(this.callback)) : this.promisifiedCallback = this.callback), "number" == typeof s2 && s2 > 0 && (n3 = setTimeout(l, s2)), "port" in r3 && "number" != typeof r3.port && (r3.port = Number(r3.port));
                try {
                  u("Resolving socket for %o request: %o", r3.protocol, `${e4.method} ${e4.path}`), Promise.resolve(this.promisifiedCallback(e4, r3)).then(f, d);
                } catch (e5) {
                  Promise.reject(e5).catch(d);
                }
              } else c2(new Error("`callback` is not defined"));
            }
            freeSocket(e4, t4) {
              u("Freeing socket %o %o", e4.constructor.name, t4), e4.destroy();
            }
            destroy() {
              u("Destroying agent %o", this.constructor.name);
            }
          }
          e3.Agent = t3, e3.prototype = e3.Agent.prototype;
        })(c || (c = {})), e2.exports = c;
      }, 304: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return function(t3, r2) {
            return new Promise(((o2, n2) => {
              e3.call(this, t3, r2, ((e4, t4) => {
                e4 ? n2(e4) : o2(t4);
              }));
            }));
          };
        };
      }, 370: function(e2, t2, r2) {
        "use strict";
        var o2 = this && this.__awaiter || function(e3, t3, r3, o3) {
          return new (r3 || (r3 = Promise))((function(n3, s2) {
            function a2(e4) {
              try {
                i2(o3.next(e4));
              } catch (e5) {
                s2(e5);
              }
            }
            function u2(e4) {
              try {
                i2(o3.throw(e4));
              } catch (e5) {
                s2(e5);
              }
            }
            function i2(e4) {
              var t4;
              e4.done ? n3(e4.value) : (t4 = e4.value, t4 instanceof r3 ? t4 : new r3((function(e5) {
                e5(t4);
              }))).then(a2, u2);
            }
            i2((o3 = o3.apply(e3, t3 || [])).next());
          }));
        }, n2 = this && this.__importDefault || function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        };
        Object.defineProperty(t2, "__esModule", { value: true });
        const s = n2(r2(808)), a = n2(r2(404)), u = n2(r2(310)), i = n2(r2(374)), c = n2(r2(46)), l = r2(54), d = (0, i.default)("http-proxy-agent");
        class f extends l.Agent {
          constructor(e3) {
            let t3;
            if (t3 = "string" == typeof e3 ? u.default.parse(e3) : e3, !t3) throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
            d("Creating new HttpProxyAgent instance: %o", t3), super(t3);
            const r3 = Object.assign({}, t3);
            var o3;
            this.secureProxy = t3.secureProxy || "string" == typeof (o3 = r3.protocol) && /^https:?$/i.test(o3), r3.host = r3.hostname || r3.host, "string" == typeof r3.port && (r3.port = parseInt(r3.port, 10)), !r3.port && r3.host && (r3.port = this.secureProxy ? 443 : 80), r3.host && r3.path && (delete r3.path, delete r3.pathname), this.proxy = r3;
          }
          callback(e3, t3) {
            return o2(this, void 0, void 0, (function* () {
              const { proxy: r3, secureProxy: o3 } = this, n3 = u.default.parse(e3.path);
              let i2;
              if (n3.protocol || (n3.protocol = "http:"), n3.hostname || (n3.hostname = t3.hostname || t3.host || null), null == n3.port && (t3.port, 1) && (n3.port = String(t3.port)), "80" === n3.port && (n3.port = ""), e3.path = u.default.format(n3), r3.auth && e3.setHeader("Proxy-Authorization", `Basic ${Buffer.from(r3.auth).toString("base64")}`), o3 ? (d("Creating `tls.Socket`: %o", r3), i2 = a.default.connect(r3)) : (d("Creating `net.Socket`: %o", r3), i2 = s.default.connect(r3)), e3._header) {
                let t4, r4;
                d("Regenerating stored HTTP header string for request"), e3._header = null, e3._implicitHeader(), e3.output && e3.output.length > 0 ? (d("Patching connection write() output buffer with updated header"), t4 = e3.output[0], r4 = t4.indexOf("\r\n\r\n") + 4, e3.output[0] = e3._header + t4.substring(r4), d("Output buffer: %o", e3.output)) : e3.outputData && e3.outputData.length > 0 && (d("Patching connection write() output buffer with updated header"), t4 = e3.outputData[0].data, r4 = t4.indexOf("\r\n\r\n") + 4, e3.outputData[0].data = e3._header + t4.substring(r4), d("Output buffer: %o", e3.outputData[0].data));
              }
              return yield (0, c.default)(i2, "connect"), i2;
            }));
          }
        }
        t2.default = f;
      }, 201: function(e2, t2, r2) {
        "use strict";
        const o2 = (this && this.__importDefault || function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        })(r2(370));
        function n2(e3) {
          return new o2.default(e3);
        }
        !(function(e3) {
          e3.HttpProxyAgent = o2.default, e3.prototype = o2.default.prototype;
        })(n2 || (n2 = {})), e2.exports = n2;
      }, 146: function(e2, t2, r2) {
        "use strict";
        var o2 = this && this.__awaiter || function(e3, t3, r3, o3) {
          return new (r3 || (r3 = Promise))((function(n3, s2) {
            function a2(e4) {
              try {
                i2(o3.next(e4));
              } catch (e5) {
                s2(e5);
              }
            }
            function u2(e4) {
              try {
                i2(o3.throw(e4));
              } catch (e5) {
                s2(e5);
              }
            }
            function i2(e4) {
              var t4;
              e4.done ? n3(e4.value) : (t4 = e4.value, t4 instanceof r3 ? t4 : new r3((function(e5) {
                e5(t4);
              }))).then(a2, u2);
            }
            i2((o3 = o3.apply(e3, t3 || [])).next());
          }));
        }, n2 = this && this.__importDefault || function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        };
        Object.defineProperty(t2, "__esModule", { value: true });
        const s = n2(r2(808)), a = n2(r2(404)), u = n2(r2(310)), i = n2(r2(491)), c = n2(r2(374)), l = r2(54), d = n2(r2(829)), f = c.default("https-proxy-agent:agent");
        class p extends l.Agent {
          constructor(e3) {
            let t3;
            if (t3 = "string" == typeof e3 ? u.default.parse(e3) : e3, !t3) throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
            f("creating new HttpsProxyAgent instance: %o", t3), super(t3);
            const r3 = Object.assign({}, t3);
            var o3;
            this.secureProxy = t3.secureProxy || "string" == typeof (o3 = r3.protocol) && /^https:?$/i.test(o3), r3.host = r3.hostname || r3.host, "string" == typeof r3.port && (r3.port = parseInt(r3.port, 10)), !r3.port && r3.host && (r3.port = this.secureProxy ? 443 : 80), this.secureProxy && !("ALPNProtocols" in r3) && (r3.ALPNProtocols = ["http 1.1"]), r3.host && r3.path && (delete r3.path, delete r3.pathname), this.proxy = r3;
          }
          callback(e3, t3) {
            return o2(this, void 0, void 0, (function* () {
              const { proxy: r3, secureProxy: o3 } = this;
              let n3;
              o3 ? (f("Creating `tls.Socket`: %o", r3), n3 = a.default.connect(r3)) : (f("Creating `net.Socket`: %o", r3), n3 = s.default.connect(r3));
              const u2 = Object.assign({}, r3.headers);
              let c2 = `CONNECT ${t3.host}:${t3.port} HTTP/1.1\r
`;
              r3.auth && (u2["Proxy-Authorization"] = `Basic ${Buffer.from(r3.auth).toString("base64")}`);
              let { host: l2, port: p2, secureEndpoint: g } = t3;
              (function(e4, t4) {
                return Boolean(!t4 && 80 === e4 || t4 && 443 === e4);
              })(p2, g) || (l2 += `:${p2}`), u2.Host = l2, u2.Connection = "close";
              for (const e4 of Object.keys(u2)) c2 += `${e4}: ${u2[e4]}\r
`;
              const v = d.default(n3);
              n3.write(`${c2}\r
`);
              const { statusCode: m, buffered: y } = yield v;
              if (200 === m) {
                if (e3.once("socket", h), t3.secureEndpoint) {
                  f("Upgrading socket connection to TLS");
                  const e4 = t3.servername || t3.host;
                  return a.default.connect(Object.assign(Object.assign({}, (function(e5, ...t4) {
                    const r4 = {};
                    let o4;
                    for (o4 in e5) t4.includes(o4) || (r4[o4] = e5[o4]);
                    return r4;
                  })(t3, "host", "hostname", "path", "port")), { socket: n3, servername: e4 }));
                }
                return n3;
              }
              n3.destroy();
              const b = new s.default.Socket({ writable: false });
              return b.readable = true, e3.once("socket", ((e4) => {
                f("replaying proxy buffer for failed request"), i.default(e4.listenerCount("data") > 0), e4.push(y), e4.push(null);
              })), b;
            }));
          }
        }
        function h(e3) {
          e3.resume();
        }
        t2.default = p;
      }, 18: function(e2, t2, r2) {
        "use strict";
        const o2 = (this && this.__importDefault || function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        })(r2(146));
        function n2(e3) {
          return new o2.default(e3);
        }
        !(function(e3) {
          e3.HttpsProxyAgent = o2.default, e3.prototype = o2.default.prototype;
        })(n2 || (n2 = {})), e2.exports = n2;
      }, 829: function(e2, t2, r2) {
        "use strict";
        var o2 = this && this.__importDefault || function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        };
        Object.defineProperty(t2, "__esModule", { value: true });
        const n2 = o2(r2(374)).default("https-proxy-agent:parse-proxy-response");
        t2.default = function(e3) {
          return new Promise(((t3, r3) => {
            let o3 = 0;
            const s = [];
            function a() {
              const r4 = e3.read();
              r4 ? (function(e4) {
                s.push(e4), o3 += e4.length;
                const r5 = Buffer.concat(s, o3);
                if (-1 === r5.indexOf("\r\n\r\n")) return n2("have not received end of HTTP headers yet..."), void a();
                const u2 = r5.toString("ascii", 0, r5.indexOf("\r\n")), i2 = +u2.split(" ")[1];
                n2("got proxy server response: %o", u2), t3({ statusCode: i2, buffered: r5 });
              })(r4) : e3.once("readable", a);
            }
            function u(e4) {
              n2("onclose had error %o", e4);
            }
            function i() {
              n2("onend");
            }
            e3.on("error", (function t4(o4) {
              e3.removeListener("end", i), e3.removeListener("error", t4), e3.removeListener("close", u), e3.removeListener("readable", a), n2("onerror %o", o4), r3(o4);
            })), e3.on("close", u), e3.on("end", i), a();
          }));
        };
      }, 539: function(e2, t2, r2) {
        "use strict";
        var o2, n2 = this && this.__extends || (o2 = function(e3, t3) {
          return o2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
            e4.__proto__ = t4;
          } || function(e4, t4) {
            for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (e4[r3] = t4[r3]);
          }, o2(e3, t3);
        }, function(e3, t3) {
          if ("function" != typeof t3 && null !== t3) throw new TypeError("Class extends value " + String(t3) + " is not a constructor or null");
          function r3() {
            this.constructor = e3;
          }
          o2(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
        }), s = this && this.__assign || function() {
          return s = Object.assign || function(e3) {
            for (var t3, r3 = 1, o3 = arguments.length; r3 < o3; r3++) for (var n3 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
            return e3;
          }, s.apply(this, arguments);
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getErrorStatusDescription = t2.xhr = t2.configure = void 0;
        var a = r2(685), u = r2(687), i = r2(310), c = r2(472), l = r2(796), d = r2(201), f = r2(18);
        if (process.env.VSCODE_NLS_CONFIG) {
          var p = process.env.VSCODE_NLS_CONFIG;
          c.config(JSON.parse(p));
        }
        var h = c.loadMessageBundle(), g = void 0, v = true;
        function m(e3) {
          var t3;
          return new Promise((function(r3, o3) {
            var n3 = (0, i.parse)(e3.url), s2 = { hostname: n3.hostname, agent: !!e3.agent && e3.agent, port: n3.port ? parseInt(n3.port) : "https:" === n3.protocol ? 443 : 80, path: n3.path, method: e3.type || "GET", headers: e3.headers, rejectUnauthorized: "boolean" != typeof e3.strictSSL || e3.strictSSL };
            e3.user && e3.password && (s2.auth = e3.user + ":" + e3.password);
            var c2 = function(o4) {
              if (o4.statusCode >= 300 && o4.statusCode < 400 && e3.followRedirects && e3.followRedirects > 0 && o4.headers.location) {
                var s3 = o4.headers.location;
                s3.startsWith("/") && (s3 = (0, i.format)({ protocol: n3.protocol, hostname: n3.hostname, port: n3.port, pathname: s3 })), r3(m((function(e4) {
                  for (var t4 = [], r4 = 1; r4 < arguments.length; r4++) t4[r4 - 1] = arguments[r4];
                  return t4.forEach((function(t5) {
                    return Object.keys(t5).forEach((function(r5) {
                      return e4[r5] = t5[r5];
                    }));
                  })), e4;
                })({}, e3, { url: s3, followRedirects: e3.followRedirects - 1 })));
              } else r3({ req: t3, res: o4 });
            };
            (t3 = "https:" === n3.protocol ? u.request(s2, c2) : a.request(s2, c2)).on("error", o3), e3.timeout && t3.setTimeout(e3.timeout), e3.data && t3.write(e3.data), t3.end(), e3.token && (e3.token.isCancellationRequested && t3.destroy(new y()), e3.token.onCancellationRequested((function() {
              t3.destroy(new y());
            })));
          }));
        }
        t2.configure = function(e3, t3) {
          g = e3, v = t3;
        }, t2.xhr = function(e3) {
          return "boolean" != typeof (e3 = s({}, e3)).strictSSL && (e3.strictSSL = v), e3.agent || (e3.agent = (function(e4, t3) {
            void 0 === t3 && (t3 = {});
            var r3 = (0, i.parse)(e4), o3 = t3.proxyUrl || (function(e5) {
              return "http:" === e5.protocol ? process.env.HTTP_PROXY || process.env.http_proxy || null : "https:" === e5.protocol && (process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy) || null;
            })(r3);
            if (!o3) return null;
            var n3 = (0, i.parse)(o3);
            if (!/^https?:$/.test(n3.protocol)) return null;
            var s2 = { host: n3.hostname, port: Number(n3.port), auth: n3.auth, rejectUnauthorized: "boolean" != typeof t3.strictSSL || t3.strictSSL, protocol: n3.protocol };
            return "http:" === r3.protocol ? d(s2) : f(s2);
          })(e3.url, { proxyUrl: g, strictSSL: v })), "number" != typeof e3.followRedirects && (e3.followRedirects = 5), m(e3).then((function(r3) {
            return new Promise((function(o3, n3) {
              var s2, a2, u2 = r3.res, c2 = u2, d2 = false, f2 = u2.headers && u2.headers["content-encoding"];
              if (f2 && (s2 = e3.type, a2 = r3.res.statusCode, !("HEAD" === s2 || a2 >= 100 && a2 < 200 || 204 === a2 || 304 === a2))) {
                var p2 = { flush: l.constants.Z_SYNC_FLUSH, finishFlush: l.constants.Z_SYNC_FLUSH };
                if ("gzip" === f2) {
                  var g2 = l.createGunzip(p2);
                  u2.pipe(g2), c2 = g2;
                } else if ("deflate" === f2) {
                  var v2 = l.createInflate(p2);
                  u2.pipe(v2), c2 = v2;
                }
              }
              var m2 = [];
              c2.on("data", (function(e4) {
                return m2.push(e4);
              })), c2.on("end", (function() {
                if (!d2) {
                  if (d2 = true, e3.followRedirects > 0 && (u2.statusCode >= 300 && u2.statusCode <= 303 || 307 === u2.statusCode)) {
                    var r4 = u2.headers.location;
                    if (r4.startsWith("/")) {
                      var s3 = (0, i.parse)(e3.url);
                      r4 = (0, i.format)({ protocol: s3.protocol, hostname: s3.hostname, port: s3.port, pathname: r4 });
                    }
                    if (r4) {
                      var a3 = { type: e3.type, url: r4, user: e3.user, password: e3.password, headers: e3.headers, timeout: e3.timeout, followRedirects: e3.followRedirects - 1, data: e3.data, token: e3.token };
                      return void (0, t2.xhr)(a3).then(o3, n3);
                    }
                  }
                  var c3 = Buffer.concat(m2), l2 = { responseText: c3.toString(), body: c3, status: u2.statusCode, headers: u2.headers || {} };
                  u2.statusCode >= 200 && u2.statusCode < 300 || 1223 === u2.statusCode ? o3(l2) : n3(l2);
                }
              })), c2.on("error", (function(t3) {
                var r4;
                r4 = y.is(t3) ? t3 : { responseText: h("error", "Unable to access {0}. Error: {1}", e3.url, t3.message), body: Buffer.concat(m2), status: 500, headers: {} }, d2 = true, n3(r4);
              })), e3.token && (e3.token.isCancellationRequested && c2.destroy(new y()), e3.token.onCancellationRequested((function() {
                c2.destroy(new y());
              })));
            }));
          }), (function(t3) {
            var r3;
            return r3 = y.is(t3) ? t3 : { responseText: e3.agent ? h("error.cannot.connect.proxy", "Unable to connect to {0} through a proxy. Error: {1}", e3.url, t3.message) : h("error.cannot.connect", "Unable to connect to {0}. Error: {1}", e3.url, t3.message), body: Buffer.concat([]), status: 404, headers: {} }, Promise.reject(r3);
          }));
        }, t2.getErrorStatusDescription = function(e3) {
          if (!(e3 < 400)) switch (e3) {
            case 400:
              return h("status.400", "Bad request. The request cannot be fulfilled due to bad syntax.");
            case 401:
              return h("status.401", "Unauthorized. The server is refusing to respond.");
            case 403:
              return h("status.403", "Forbidden. The server is refusing to respond.");
            case 404:
              return h("status.404", "Not Found. The requested location could not be found.");
            case 405:
              return h("status.405", "Method not allowed. A request was made using a request method not supported by that location.");
            case 406:
              return h("status.406", "Not Acceptable. The server can only generate a response that is not accepted by the client.");
            case 407:
              return h("status.407", "Proxy Authentication Required. The client must first authenticate itself with the proxy.");
            case 408:
              return h("status.408", "Request Timeout. The server timed out waiting for the request.");
            case 409:
              return h("status.409", "Conflict. The request could not be completed because of a conflict in the request.");
            case 410:
              return h("status.410", "Gone. The requested page is no longer available.");
            case 411:
              return h("status.411", 'Length Required. The "Content-Length" is not defined.');
            case 412:
              return h("status.412", "Precondition Failed. The precondition given in the request evaluated to false by the server.");
            case 413:
              return h("status.413", "Request Entity Too Large. The server will not accept the request, because the request entity is too large.");
            case 414:
              return h("status.414", "Request-URI Too Long. The server will not accept the request, because the URL is too long.");
            case 415:
              return h("status.415", "Unsupported Media Type. The server will not accept the request, because the media type is not supported.");
            case 500:
              return h("status.500", "Internal Server Error.");
            case 501:
              return h("status.501", "Not Implemented. The server either does not recognize the request method, or it lacks the ability to fulfill the request.");
            case 502:
              return h("status.502", "Bad Gateway. The upstream server did not respond.");
            case 503:
              return h("status.503", "Service Unavailable. The server is currently unavailable (overloaded or down).");
            default:
              return h("status.416", "HTTP status code {0}", e3);
          }
        };
        var y = (function(e3) {
          function t3() {
            var r3 = e3.call(this, "The user aborted a request") || this;
            return r3.name = "AbortError", Object.setPrototypeOf(r3, t3.prototype), r3;
          }
          return n2(t3, e3), t3.is = function(e4) {
            return e4 instanceof t3;
          }, t3;
        })(Error);
      }, 800: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.config = t2.loadMessageBundle = t2.localize = t2.format = t2.setPseudo = t2.isPseudo = t2.isDefined = t2.BundleFormat = t2.MessageFormat = void 0;
        var o2, n2, s, a = r2(926);
        function u(e3) {
          return void 0 !== e3;
        }
        function i(e3, r3) {
          return t2.isPseudo && (e3 = "\uFF3B" + e3.replace(/[aouei]/g, "$&$&") + "\uFF3D"), 0 === r3.length ? e3 : e3.replace(/\{(\d+)\}/g, (function(e4, t3) {
            var o3 = t3[0], n3 = r3[o3], s2 = e4;
            return "string" == typeof n3 ? s2 = n3 : "number" != typeof n3 && "boolean" != typeof n3 && null != n3 || (s2 = String(n3)), s2;
          }));
        }
        (s = t2.MessageFormat || (t2.MessageFormat = {})).file = "file", s.bundle = "bundle", s.both = "both", (n2 = t2.BundleFormat || (t2.BundleFormat = {})).standalone = "standalone", n2.languagePack = "languagePack", (function(e3) {
          e3.is = function(e4) {
            var t3 = e4;
            return t3 && u(t3.key) && u(t3.comment);
          };
        })(o2 || (o2 = {})), t2.isDefined = u, t2.isPseudo = false, t2.setPseudo = function(e3) {
          t2.isPseudo = e3;
        }, t2.format = i, t2.localize = function(e3, t3) {
          for (var r3 = [], o3 = 2; o3 < arguments.length; o3++) r3[o3 - 2] = arguments[o3];
          return i(t3, r3);
        }, t2.loadMessageBundle = function(e3) {
          return (0, a.default)().loadMessageBundle(e3);
        }, t2.config = function(e3) {
          return (0, a.default)().config(e3);
        };
      }, 926: (e2, t2) => {
        "use strict";
        var r2;
        function o2() {
          if (void 0 === r2) throw new Error("No runtime abstraction layer installed");
          return r2;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), (function(e3) {
          e3.install = function(e4) {
            if (void 0 === e4) throw new Error("No runtime abstraction layer provided");
            r2 = e4;
          };
        })(o2 || (o2 = {})), t2.default = o2;
      }, 472: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.config = t2.loadMessageBundle = t2.BundleFormat = t2.MessageFormat = void 0;
        var o2 = r2(17), n2 = r2(147), s = r2(926), a = r2(800), u = r2(800);
        Object.defineProperty(t2, "MessageFormat", { enumerable: true, get: function() {
          return u.MessageFormat;
        } }), Object.defineProperty(t2, "BundleFormat", { enumerable: true, get: function() {
          return u.BundleFormat;
        } });
        var i, c, l = Object.prototype.toString;
        function d(e3) {
          return "[object Number]" === l.call(e3);
        }
        function f(e3) {
          return "[object String]" === l.call(e3);
        }
        function p(e3) {
          return JSON.parse(n2.readFileSync(e3, "utf8"));
        }
        function h(e3) {
          return function(t3, r3) {
            for (var o3 = [], n3 = 2; n3 < arguments.length; n3++) o3[n3 - 2] = arguments[n3];
            return d(t3) ? t3 >= e3.length ? void console.error("Broken localize call found. Index out of bounds. Stacktrace is\n: ".concat(new Error("").stack)) : (0, a.format)(e3[t3], o3) : f(r3) ? (console.warn("Message ".concat(r3, " didn't get externalized correctly.")), (0, a.format)(r3, o3)) : void console.error("Broken localize call found. Stacktrace is\n: ".concat(new Error("").stack));
          };
        }
        function g(e3, t3) {
          return i[e3] = t3, t3;
        }
        function v(e3) {
          try {
            return (function(e4) {
              var t3 = p(o2.join(e4, "nls.metadata.json")), r3 = /* @__PURE__ */ Object.create(null);
              for (var n3 in t3) {
                var s2 = t3[n3];
                r3[n3] = s2.messages;
              }
              return r3;
            })(e3);
          } catch (e4) {
            return void console.log("Generating default bundle from meta data failed.", e4);
          }
        }
        function m(e3, t3) {
          var r3;
          if (true === c.languagePackSupport && void 0 !== c.cacheRoot && void 0 !== c.languagePackId && void 0 !== c.translationsConfigFile && void 0 !== c.translationsConfig) try {
            r3 = (function(e4, t4) {
              var r4, s3, a2, u2 = o2.join(c.cacheRoot, "".concat(e4.id, "-").concat(e4.hash, ".json")), i2 = false, l2 = false;
              try {
                return r4 = JSON.parse(n2.readFileSync(u2, { encoding: "utf8", flag: "r" })), s3 = u2, a2 = /* @__PURE__ */ new Date(), n2.utimes(s3, a2, a2, (function() {
                })), r4;
              } catch (e5) {
                if ("ENOENT" === e5.code) l2 = true;
                else {
                  if (!(e5 instanceof SyntaxError)) throw e5;
                  console.log("Syntax error parsing message bundle: ".concat(e5.message, ".")), n2.unlink(u2, (function(e6) {
                    e6 && console.error("Deleting corrupted bundle ".concat(u2, " failed."));
                  })), i2 = true;
                }
              }
              if (r4 = (function(e5, t5) {
                var r5 = c.translationsConfig[e5.id];
                if (r5) {
                  var n3 = p(r5).contents, s4 = p(o2.join(t5, "nls.metadata.json")), a3 = /* @__PURE__ */ Object.create(null);
                  for (var u3 in s4) {
                    var i3 = s4[u3], l3 = n3["".concat(e5.outDir, "/").concat(u3)];
                    if (l3) {
                      for (var d2 = [], h2 = 0; h2 < i3.keys.length; h2++) {
                        var g2 = i3.keys[h2], v2 = l3[f(g2) ? g2 : g2.key];
                        void 0 === v2 && (v2 = i3.messages[h2]), d2.push(v2);
                      }
                      a3[u3] = d2;
                    } else a3[u3] = i3.messages;
                  }
                  return a3;
                }
              })(e4, t4), !r4 || i2) return r4;
              if (l2) try {
                n2.writeFileSync(u2, JSON.stringify(r4), { encoding: "utf8", flag: "wx" });
              } catch (e5) {
                if ("EEXIST" === e5.code) return r4;
                throw e5;
              }
              return r4;
            })(e3, t3);
          } catch (e4) {
            console.log("Load or create bundle failed ", e4);
          }
          if (!r3) {
            if (c.languagePackSupport) return v(t3);
            var s2 = (function(e4) {
              for (var t4 = c.language; t4; ) {
                var r4 = o2.join(e4, "nls.bundle.".concat(t4, ".json"));
                if (n2.existsSync(r4)) return r4;
                var s3 = t4.lastIndexOf("-");
                t4 = s3 > 0 ? t4.substring(0, s3) : void 0;
              }
              if (void 0 === t4 && (r4 = o2.join(e4, "nls.bundle.json"), n2.existsSync(r4))) return r4;
            })(t3);
            if (s2) try {
              return p(s2);
            } catch (e4) {
              console.log("Loading in the box message bundle failed.", e4);
            }
            r3 = v(t3);
          }
          return r3;
        }
        function y(e3) {
          if (!e3) return a.localize;
          var t3 = o2.extname(e3);
          if (t3 && (e3 = e3.substr(0, e3.length - t3.length)), c.messageFormat === a.MessageFormat.both || c.messageFormat === a.MessageFormat.bundle) {
            var r3 = (function(e4) {
              for (var t4, r4 = o2.dirname(e4); t4 = o2.join(r4, "nls.metadata.header.json"), !n2.existsSync(t4); ) {
                var s3 = o2.dirname(r4);
                if (s3 === r4) {
                  t4 = void 0;
                  break;
                }
                r4 = s3;
              }
              return t4;
            })(e3);
            if (r3) {
              var s2 = o2.dirname(r3), u2 = i[s2];
              if (void 0 === u2) try {
                var l2 = JSON.parse(n2.readFileSync(r3, "utf8"));
                try {
                  var d2 = m(l2, s2);
                  u2 = g(s2, d2 ? { header: l2, nlsBundle: d2 } : null);
                } catch (e4) {
                  console.error("Failed to load nls bundle", e4), u2 = g(s2, null);
                }
              } catch (e4) {
                console.error("Failed to read header file", e4), u2 = g(s2, null);
              }
              if (u2) {
                var f2 = e3.substr(s2.length + 1).replace(/\\/g, "/"), v2 = u2.nlsBundle[f2];
                return void 0 === v2 ? (console.error("Messages for file ".concat(e3, " not found. See console for details.")), function() {
                  return "Messages not found.";
                }) : h(v2);
              }
            }
          }
          if (c.messageFormat === a.MessageFormat.both || c.messageFormat === a.MessageFormat.file) try {
            var y2 = p((function(e4) {
              var t4;
              if (c.cacheLanguageResolution && t4) ;
              else {
                if (a.isPseudo || !c.language) t4 = ".nls.json";
                else for (var r4 = c.language; r4; ) {
                  var o3 = ".nls." + r4 + ".json";
                  if (n2.existsSync(e4 + o3)) {
                    t4 = o3;
                    break;
                  }
                  var s3 = r4.lastIndexOf("-");
                  s3 > 0 ? r4 = r4.substring(0, s3) : (t4 = ".nls.json", r4 = null);
                }
                c.cacheLanguageResolution;
              }
              return e4 + t4;
            })(e3));
            return Array.isArray(y2) ? h(y2) : (0, a.isDefined)(y2.messages) && (0, a.isDefined)(y2.keys) ? h(y2.messages) : (console.error("String bundle '".concat(e3, "' uses an unsupported format.")), function() {
              return "File bundle has unsupported format. See console for details";
            });
          } catch (e4) {
            "ENOENT" !== e4.code && console.error("Failed to load single file bundle", e4);
          }
          return console.error("Failed to load message bundle for file ".concat(e3)), function() {
            return "Failed to load message bundle. See console for details.";
          };
        }
        function b(e3) {
          return e3 && (f(e3.locale) && (c.locale = e3.locale.toLowerCase(), c.language = c.locale, i = /* @__PURE__ */ Object.create(null)), void 0 !== e3.messageFormat && (c.messageFormat = e3.messageFormat), e3.bundleFormat === a.BundleFormat.standalone && true === c.languagePackSupport && (c.languagePackSupport = false)), (0, a.setPseudo)("pseudo" === c.locale), y;
        }
        !(function() {
          if (c = { locale: void 0, language: void 0, languagePackSupport: false, cacheLanguageResolution: true, messageFormat: a.MessageFormat.bundle }, f(process.env.VSCODE_NLS_CONFIG)) try {
            var e3 = JSON.parse(process.env.VSCODE_NLS_CONFIG), t3 = void 0;
            if (e3.availableLanguages) {
              var r3 = e3.availableLanguages["*"];
              f(r3) && (t3 = r3);
            }
            if (f(e3.locale) && (c.locale = e3.locale.toLowerCase()), void 0 === t3 ? c.language = c.locale : "en" !== t3 && (c.language = t3), /* @__PURE__ */ (function(e4) {
              return true === e4 || false === e4;
            })(e3._languagePackSupport) && (c.languagePackSupport = e3._languagePackSupport), f(e3._cacheRoot) && (c.cacheRoot = e3._cacheRoot), f(e3._languagePackId) && (c.languagePackId = e3._languagePackId), f(e3._translationsConfigFile)) {
              c.translationsConfigFile = e3._translationsConfigFile;
              try {
                c.translationsConfig = p(c.translationsConfigFile);
              } catch (t4) {
                if (e3._corruptedFile) {
                  var s2 = o2.dirname(e3._corruptedFile);
                  n2.exists(s2, (function(t5) {
                    t5 && n2.writeFile(e3._corruptedFile, "corrupted", "utf8", (function(e4) {
                      console.error(e4);
                    }));
                  }));
                }
              }
            }
          } catch (e4) {
          }
          (0, a.setPseudo)("pseudo" === c.locale), i = /* @__PURE__ */ Object.create(null);
        })(), t2.loadMessageBundle = y, t2.config = b, s.default.install(Object.freeze({ loadMessageBundle: y, config: b }));
      }, 374: (e2, t2) => {
        function r2() {
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return r2;
        };
      }, 491: (e2) => {
        "use strict";
        e2.exports = require("assert");
      }, 361: (e2) => {
        "use strict";
        e2.exports = require("events");
      }, 147: (e2) => {
        "use strict";
        e2.exports = require("fs");
      }, 685: (e2) => {
        "use strict";
        e2.exports = require("http");
      }, 687: (e2) => {
        "use strict";
        e2.exports = require("https");
      }, 808: (e2) => {
        "use strict";
        e2.exports = require("net");
      }, 17: (e2) => {
        "use strict";
        e2.exports = require("path");
      }, 404: (e2) => {
        "use strict";
        e2.exports = require("tls");
      }, 310: (e2) => {
        "use strict";
        e2.exports = require("url");
      }, 796: (e2) => {
        "use strict";
        e2.exports = require("zlib");
      } }, t = {}, r = (function r2(o2) {
        var n2 = t[o2];
        if (void 0 !== n2) return n2.exports;
        var s = t[o2] = { exports: {} };
        return e[o2].call(s.exports, s, s.exports, r2), s.exports;
      })(539), o = exports2;
      for (var n in r) o[n] = r[n];
      r.__esModule && Object.defineProperty(o, "__esModule", { value: true });
    })();
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/fileSystemProviders/http.js
var require_http = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/fileSystemProviders/http.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.provider = void 0;
    exports2.listenEditorSettings = listenEditorSettings;
    exports2.handler = handler;
    var language_service_1 = require_language_service();
    var request_light_1 = require_main5();
    exports2.provider = {
      async stat(uri) {
        const text = await this.readFile(uri);
        if (text !== void 0) {
          return {
            type: language_service_1.FileType.File,
            size: text.length,
            ctime: 0,
            mtime: 0
          };
        }
      },
      readFile(uri) {
        return handler(uri);
      },
      readDirectory() {
        return [];
      }
    };
    function listenEditorSettings(server2) {
      server2.configurations.onDidChange(updateHttpSettings);
      updateHttpSettings();
      async function updateHttpSettings() {
        const httpSettings = await server2.configurations.get("http");
        (0, request_light_1.configure)(httpSettings?.proxy, httpSettings?.proxyStrictSSL ?? false);
      }
    }
    function handler(uri) {
      const headers = { "Accept-Encoding": "gzip, deflate" };
      return (0, request_light_1.xhr)({ url: uri.toString(true), followRedirects: 5, headers }).then((response) => {
        if (response.status !== 200) {
          return;
        }
        return response.responseText;
      }, (error) => {
        return Promise.reject(error.responseText || (0, request_light_1.getErrorStatusDescription)(error.status) || error);
      });
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/fileSystemProviders/node.js
var require_node4 = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/fileSystemProviders/node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.provider = void 0;
    var language_service_1 = require_language_service();
    var fs2 = require("fs");
    exports2.provider = {
      stat(uri) {
        try {
          const stats = fs2.statSync(uri.fsPath, { throwIfNoEntry: false });
          if (stats) {
            return {
              type: stats.isFile() ? language_service_1.FileType.File : stats.isDirectory() ? language_service_1.FileType.Directory : stats.isSymbolicLink() ? language_service_1.FileType.SymbolicLink : language_service_1.FileType.Unknown,
              ctime: stats.ctimeMs,
              mtime: stats.mtimeMs,
              size: stats.size
            };
          }
        } catch {
          return void 0;
        }
      },
      readFile(uri, encoding) {
        try {
          return fs2.readFileSync(uri.fsPath, { encoding: encoding ?? "utf-8" });
        } catch {
          return void 0;
        }
      },
      readDirectory(uri) {
        try {
          const files = fs2.readdirSync(uri.fsPath, { withFileTypes: true });
          return files.map((file) => {
            return [
              file.name,
              file.isFile() ? language_service_1.FileType.File : file.isDirectory() ? language_service_1.FileType.Directory : file.isSymbolicLink() ? language_service_1.FileType.SymbolicLink : language_service_1.FileType.Unknown
            ];
          });
        } catch {
          return [];
        }
      }
    };
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/configurations.js
var require_configurations = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/configurations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var vscode2 = require_main4();
    function register(server2) {
      const configurations = /* @__PURE__ */ new Map();
      const didChangeCallbacks = /* @__PURE__ */ new Set();
      server2.onInitialized(() => {
        server2.connection.onDidChangeConfiguration((params) => {
          configurations.clear();
          for (const cb of didChangeCallbacks) {
            cb(params);
          }
        });
        const didChangeConfiguration = server2.initializeParams.capabilities.workspace?.didChangeConfiguration;
        if (didChangeConfiguration?.dynamicRegistration) {
          server2.connection.client.register(vscode2.DidChangeConfigurationNotification.type);
        }
      });
      return {
        get,
        onDidChange
      };
      function get(section, scopeUri) {
        if (!server2.initializeParams.capabilities.workspace?.configuration) {
          return Promise.resolve(void 0);
        }
        const didChangeConfiguration = server2.initializeParams.capabilities.workspace?.didChangeConfiguration;
        if (!scopeUri && didChangeConfiguration) {
          if (!configurations.has(section)) {
            configurations.set(section, getConfigurationWorker(section, scopeUri));
          }
          return configurations.get(section);
        }
        return getConfigurationWorker(section, scopeUri);
      }
      function onDidChange(cb) {
        didChangeCallbacks.add(cb);
        return {
          dispose() {
            didChangeCallbacks.delete(cb);
          }
        };
      }
      async function getConfigurationWorker(section, scopeUri) {
        return await server2.connection.workspace.getConfiguration({ scopeUri, section }) ?? void 0;
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/protocol.js
var require_protocol2 = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/protocol.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GetVirtualCodeRequest = exports2.GetVirtualFileRequest = exports2.GetServicePluginsRequest = exports2.UpdateServicePluginStateNotification = exports2.UpdateVirtualCodeStateNotification = exports2.DocumentDrop_DataTransferItemFileDataRequest = exports2.DocumentDrop_DataTransferItemAsStringRequest = exports2.DocumentDropRequest = exports2.ReloadProjectNotification = exports2.AutoInsertRequest = exports2.GetMatchTsConfigRequest = exports2.FindFileReferenceRequest = void 0;
    var protocol = require_main3();
    __exportStar2(require_main3(), exports2);
    var FindFileReferenceRequest;
    (function(FindFileReferenceRequest2) {
      FindFileReferenceRequest2.type = new protocol.RequestType("volar/client/findFileReference");
    })(FindFileReferenceRequest || (exports2.FindFileReferenceRequest = FindFileReferenceRequest = {}));
    var GetMatchTsConfigRequest;
    (function(GetMatchTsConfigRequest2) {
      GetMatchTsConfigRequest2.type = new protocol.RequestType("volar/client/tsconfig");
    })(GetMatchTsConfigRequest || (exports2.GetMatchTsConfigRequest = GetMatchTsConfigRequest = {}));
    var AutoInsertRequest;
    (function(AutoInsertRequest2) {
      AutoInsertRequest2.type = new protocol.RequestType("volar/client/autoInsert");
    })(AutoInsertRequest || (exports2.AutoInsertRequest = AutoInsertRequest = {}));
    var ReloadProjectNotification;
    (function(ReloadProjectNotification2) {
      ReloadProjectNotification2.type = new protocol.NotificationType("volar/client/reloadProject");
    })(ReloadProjectNotification || (exports2.ReloadProjectNotification = ReloadProjectNotification = {}));
    var DocumentDropRequest;
    (function(DocumentDropRequest2) {
      DocumentDropRequest2.type = new protocol.RequestType("volar/client/documentDrop");
    })(DocumentDropRequest || (exports2.DocumentDropRequest = DocumentDropRequest = {}));
    var DocumentDrop_DataTransferItemAsStringRequest;
    (function(DocumentDrop_DataTransferItemAsStringRequest2) {
      DocumentDrop_DataTransferItemAsStringRequest2.type = new protocol.RequestType("volar/client/documentDrop/asString");
    })(DocumentDrop_DataTransferItemAsStringRequest || (exports2.DocumentDrop_DataTransferItemAsStringRequest = DocumentDrop_DataTransferItemAsStringRequest = {}));
    var DocumentDrop_DataTransferItemFileDataRequest;
    (function(DocumentDrop_DataTransferItemFileDataRequest2) {
      DocumentDrop_DataTransferItemFileDataRequest2.type = new protocol.RequestType("volar/client/documentDrop/fileData");
    })(DocumentDrop_DataTransferItemFileDataRequest || (exports2.DocumentDrop_DataTransferItemFileDataRequest = DocumentDrop_DataTransferItemFileDataRequest = {}));
    var UpdateVirtualCodeStateNotification;
    (function(UpdateVirtualCodeStateNotification2) {
      UpdateVirtualCodeStateNotification2.type = new protocol.NotificationType("volar/client/labs/updateVirtualFileState");
    })(UpdateVirtualCodeStateNotification || (exports2.UpdateVirtualCodeStateNotification = UpdateVirtualCodeStateNotification = {}));
    var UpdateServicePluginStateNotification;
    (function(UpdateServicePluginStateNotification2) {
      UpdateServicePluginStateNotification2.type = new protocol.NotificationType("volar/client/labs/updateServicePluginState");
    })(UpdateServicePluginStateNotification || (exports2.UpdateServicePluginStateNotification = UpdateServicePluginStateNotification = {}));
    var GetServicePluginsRequest;
    (function(GetServicePluginsRequest2) {
      GetServicePluginsRequest2.type = new protocol.RequestType("volar/client/servicePlugins");
    })(GetServicePluginsRequest || (exports2.GetServicePluginsRequest = GetServicePluginsRequest = {}));
    var GetVirtualFileRequest;
    (function(GetVirtualFileRequest2) {
      GetVirtualFileRequest2.type = new protocol.RequestType("volar/client/virtualFiles");
    })(GetVirtualFileRequest || (exports2.GetVirtualFileRequest = GetVirtualFileRequest = {}));
    var GetVirtualCodeRequest;
    (function(GetVirtualCodeRequest2) {
      GetVirtualCodeRequest2.type = new protocol.RequestType("volar/client/virtualFile");
    })(GetVirtualCodeRequest || (exports2.GetVirtualCodeRequest = GetVirtualCodeRequest = {}));
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/editorFeatures.js
var require_editorFeatures = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/editorFeatures.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_service_1 = require_language_service();
    var vscode_uri_1 = require_umd();
    var protocol_1 = require_protocol2();
    function register(server2) {
      server2.onInitialize(() => {
        const { project } = server2;
        const scriptVersions = (0, language_service_1.createUriMap)();
        const scriptVersionSnapshots = /* @__PURE__ */ new WeakSet();
        server2.connection.onRequest(protocol_1.GetMatchTsConfigRequest.type, async (params) => {
          const uri = vscode_uri_1.URI.parse(params.uri);
          const languageService = await project.getLanguageService(uri);
          const tsProject = languageService.context.project.typescript;
          if (tsProject?.configFileName) {
            const { configFileName, uriConverter } = tsProject;
            return { uri: uriConverter.asUri(configFileName).toString() };
          }
        });
        server2.connection.onRequest(protocol_1.GetVirtualFileRequest.type, async (document) => {
          const uri = vscode_uri_1.URI.parse(document.uri);
          const languageService = await project.getLanguageService(uri);
          const documentUri = vscode_uri_1.URI.parse(document.uri);
          const sourceScript = languageService.context.language.scripts.get(documentUri);
          if (sourceScript?.generated) {
            return prune(sourceScript.generated.root);
          }
          function prune(virtualCode) {
            const uri2 = languageService.context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id);
            let version = scriptVersions.get(uri2) ?? 0;
            if (!scriptVersionSnapshots.has(virtualCode.snapshot)) {
              version++;
              scriptVersions.set(uri2, version);
              scriptVersionSnapshots.add(virtualCode.snapshot);
            }
            return {
              fileUri: sourceScript.id.toString(),
              virtualCodeId: virtualCode.id,
              languageId: virtualCode.languageId,
              embeddedCodes: virtualCode.embeddedCodes?.map(prune) || [],
              version,
              disabled: languageService.context.disabledEmbeddedDocumentUris.has(uri2)
            };
          }
        });
        server2.connection.onRequest(protocol_1.GetVirtualCodeRequest.type, async (params) => {
          const uri = vscode_uri_1.URI.parse(params.fileUri);
          const languageService = await project.getLanguageService(uri);
          const sourceScript = languageService.context.language.scripts.get(vscode_uri_1.URI.parse(params.fileUri));
          const virtualCode = sourceScript?.generated?.embeddedCodes.get(params.virtualCodeId);
          if (virtualCode) {
            const mappings = {};
            for (const [sourceScript2, map] of languageService.context.language.maps.forEach(virtualCode)) {
              mappings[sourceScript2.id.toString()] = map.mappings;
            }
            return {
              content: virtualCode.snapshot.getText(0, virtualCode.snapshot.getLength()),
              mappings
            };
          }
        });
        server2.connection.onNotification(protocol_1.UpdateVirtualCodeStateNotification.type, async (params) => {
          const uri = vscode_uri_1.URI.parse(params.fileUri);
          const languageService = await project.getLanguageService(uri);
          const virtualFileUri = languageService.context.encodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(params.fileUri), params.virtualCodeId);
          if (params.disabled) {
            languageService.context.disabledEmbeddedDocumentUris.set(virtualFileUri, true);
          } else {
            languageService.context.disabledEmbeddedDocumentUris.delete(virtualFileUri);
          }
        });
        server2.connection.onNotification(protocol_1.UpdateServicePluginStateNotification.type, async (params) => {
          const uri = vscode_uri_1.URI.parse(params.uri);
          const languageService = await project.getLanguageService(uri);
          const plugin = languageService.context.plugins[params.serviceId][1];
          if (params.disabled) {
            languageService.context.disabledServicePlugins.add(plugin);
          } else {
            languageService.context.disabledServicePlugins.delete(plugin);
          }
        });
        server2.connection.onRequest(protocol_1.GetServicePluginsRequest.type, async (params) => {
          const uri = vscode_uri_1.URI.parse(params.uri);
          const languageService = await project.getLanguageService(uri);
          const result = [];
          for (let pluginIndex = 0; pluginIndex < languageService.context.plugins.length; pluginIndex++) {
            const plugin = languageService.context.plugins[pluginIndex];
            result.push({
              id: pluginIndex,
              name: plugin[0].name,
              disabled: languageService.context.disabledServicePlugins.has(plugin[1]),
              features: Object.keys(plugin[1])
            });
          }
          return result;
        });
      });
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/fileSystem.js
var require_fileSystem = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/fileSystem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_service_1 = require_language_service();
    var vscode2 = require_main4();
    var vscode_uri_1 = require_umd();
    function register(documents, fileWatcher) {
      const providers = /* @__PURE__ */ new Map();
      const readFileCache = (0, language_service_1.createUriMap)();
      const statCache = (0, language_service_1.createUriMap)();
      const readDirectoryCache = (0, language_service_1.createUriMap)();
      documents.onDidSave(({ document }) => {
        const uri = vscode_uri_1.URI.parse(document.uri);
        readFileCache.set(uri, document.getText());
        statCache.delete(uri);
      });
      fileWatcher.onDidChangeWatchedFiles(({ changes }) => {
        for (const change of changes) {
          const changeUri = vscode_uri_1.URI.parse(change.uri);
          const dir = vscode_uri_1.URI.parse(change.uri.substring(0, change.uri.lastIndexOf("/")));
          if (change.type === vscode2.FileChangeType.Deleted) {
            readFileCache.set(changeUri, void 0);
            statCache.set(changeUri, void 0);
            readDirectoryCache.delete(dir);
          } else if (change.type === vscode2.FileChangeType.Changed) {
            readFileCache.delete(changeUri);
            statCache.delete(changeUri);
          } else if (change.type === vscode2.FileChangeType.Created) {
            readFileCache.delete(changeUri);
            statCache.delete(changeUri);
            readDirectoryCache.delete(dir);
          }
        }
      });
      return {
        readFile(uri) {
          if (!readFileCache.has(uri)) {
            readFileCache.set(uri, providers.get(uri.scheme)?.readFile(uri));
          }
          return readFileCache.get(uri);
        },
        stat(uri) {
          if (!statCache.has(uri)) {
            statCache.set(uri, providers.get(uri.scheme)?.stat(uri));
          }
          return statCache.get(uri);
        },
        readDirectory(uri) {
          if (!readDirectoryCache.has(uri)) {
            readDirectoryCache.set(uri, providers.get(uri.scheme)?.readDirectory(uri) ?? []);
          }
          return readDirectoryCache.get(uri);
        },
        install(scheme, provider) {
          providers.set(scheme, provider);
        }
      };
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/fileWatcher.js
var require_fileWatcher = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/fileWatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var vscode2 = require_main4();
    function register(server2) {
      let watchFilesDisposableCounter = 0;
      let watchFilesDisposable;
      const didChangeWatchedFilesCallbacks = /* @__PURE__ */ new Set();
      return {
        watchFiles,
        onDidChangeWatchedFiles
      };
      async function watchFiles(patterns) {
        const disposables = [];
        const didChangeWatchedFiles = server2.initializeParams.capabilities.workspace?.didChangeWatchedFiles;
        const fileOperations = server2.initializeParams.capabilities.workspace?.fileOperations;
        if (didChangeWatchedFiles) {
          if (watchFilesDisposableCounter === 0) {
            watchFilesDisposable = server2.connection.onDidChangeWatchedFiles((e) => {
              for (const cb of didChangeWatchedFilesCallbacks) {
                cb(e);
              }
            });
          }
          watchFilesDisposableCounter++;
          disposables.push({
            dispose() {
              watchFilesDisposableCounter--;
              if (watchFilesDisposableCounter === 0) {
                watchFilesDisposable?.dispose();
              }
            }
          });
        }
        if (didChangeWatchedFiles?.dynamicRegistration) {
          disposables.push(await server2.connection.client.register(vscode2.DidChangeWatchedFilesNotification.type, {
            watchers: patterns.map((pattern) => ({ globPattern: pattern }))
          }));
        }
        if (fileOperations?.dynamicRegistration && fileOperations.willRename) {
          disposables.push(await server2.connection.client.register(vscode2.WillRenameFilesRequest.type, {
            filters: patterns.map((pattern) => ({ pattern: { glob: pattern } }))
          }));
        }
        return {
          dispose() {
            for (const disposable of disposables) {
              disposable.dispose();
            }
            disposables.length = 0;
          }
        };
      }
      function onDidChangeWatchedFiles(cb) {
        didChangeWatchedFilesCallbacks.add(cb);
        return {
          dispose: () => {
            didChangeWatchedFilesCallbacks.delete(cb);
          }
        };
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/languageFeatures.js
var require_languageFeatures = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/languageFeatures.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_service_1 = require_language_service();
    var vscode2 = require_main4();
    var vscode_uri_1 = require_umd();
    var protocol_1 = require_protocol2();
    var reportedCapabilities = /* @__PURE__ */ new Set();
    function register(server2, documents, configurations) {
      configurations.onDidChange(() => requestRefresh(false));
      let refreshReq = 0;
      let updateDiagnosticsBatchReq = 0;
      const refreshHandlers = [];
      server2.onInitialize((serverCapabilities) => {
        let lastCompleteUri;
        let lastCompleteLs;
        let lastCodeLensLs;
        let lastCodeActionLs;
        let lastCallHierarchyLs;
        let lastTypeHierarchyLs;
        let lastDocumentLinkLs;
        let lastInlayHintLs;
        let languageServiceToId = /* @__PURE__ */ new WeakMap();
        let currentLanguageServiceId = 0;
        const languageServiceById = /* @__PURE__ */ new Map();
        const { languageServicePlugins, project, initializeParams } = server2;
        if (languageServicePlugins.some(({ capabilities }) => capabilities.selectionRangeProvider)) {
          serverCapabilities.selectionRangeProvider = true;
          server2.connection.onSelectionRanges(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getSelectionRanges(uri, params.positions, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.foldingRangeProvider)) {
          serverCapabilities.foldingRangeProvider = true;
          server2.connection.onFoldingRanges(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getFoldingRanges(uri, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.linkedEditingRangeProvider)) {
          serverCapabilities.linkedEditingRangeProvider = true;
          server2.connection.languages.onLinkedEditingRange(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getLinkedEditingRanges(uri, params.position, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.colorProvider)) {
          serverCapabilities.colorProvider = true;
          server2.connection.onDocumentColor(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getDocumentColors(uri, token);
            });
          });
          server2.connection.onColorPresentation(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getColorPresentations(uri, params.color, params.range, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentSymbolProvider)) {
          serverCapabilities.documentSymbolProvider = true;
          server2.connection.onDocumentSymbol(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getDocumentSymbols(uri, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentFormattingProvider)) {
          serverCapabilities.documentFormattingProvider = true;
          serverCapabilities.documentRangeFormattingProvider = true;
          server2.connection.onDocumentFormatting(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getDocumentFormattingEdits(uri, params.options, void 0, void 0, token);
            });
          });
          server2.connection.onDocumentRangeFormatting(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getDocumentFormattingEdits(uri, params.options, params.range, void 0, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.referencesProvider)) {
          serverCapabilities.referencesProvider = true;
          server2.connection.onReferences(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getReferences(uri, params.position, { includeDeclaration: true }, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.implementationProvider)) {
          serverCapabilities.implementationProvider = true;
          server2.connection.onImplementation(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, async (languageService) => {
              const definitions = await languageService.getImplementations(uri, params.position, token);
              return handleDefinitions(initializeParams, "implementation", definitions ?? []);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.declarationProvider)) {
          serverCapabilities.declarationProvider = true;
          server2.connection.onDeclaration(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, async (languageService) => {
              const definitions = await languageService.getDeclaration(uri, params.position, token);
              return handleDefinitions(initializeParams, "declaration", definitions ?? []);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.definitionProvider)) {
          serverCapabilities.definitionProvider = true;
          server2.connection.onDefinition(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, async (languageService) => {
              const definitions = await languageService.getDefinition(uri, params.position, token);
              return handleDefinitions(initializeParams, "definition", definitions ?? []);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.typeDefinitionProvider)) {
          serverCapabilities.typeDefinitionProvider = true;
          server2.connection.onTypeDefinition(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, async (languageService) => {
              const definitions = await languageService.getTypeDefinition(uri, params.position, token);
              return handleDefinitions(initializeParams, "typeDefinition", definitions ?? []);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.callHierarchyProvider)) {
          serverCapabilities.callHierarchyProvider = true;
          server2.connection.languages.callHierarchy.onPrepare(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              lastCallHierarchyLs = languageService;
              return languageService.getCallHierarchyItems(uri, params.position, token);
            }) ?? [];
          });
          server2.connection.languages.callHierarchy.onIncomingCalls(async (params, token) => {
            return await lastCallHierarchyLs?.getCallHierarchyIncomingCalls(params.item, token) ?? [];
          });
          server2.connection.languages.callHierarchy.onOutgoingCalls(async (params, token) => {
            return await lastCallHierarchyLs?.getCallHierarchyOutgoingCalls(params.item, token) ?? [];
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.typeHierarchyProvider)) {
          serverCapabilities.typeHierarchyProvider = true;
          server2.connection.languages.typeHierarchy.onPrepare(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              lastTypeHierarchyLs = languageService;
              return languageService.getTypeHierarchyItems(uri, params.position, token);
            }) ?? [];
          });
          server2.connection.languages.typeHierarchy.onSupertypes(async (params, token) => {
            return await lastTypeHierarchyLs?.getTypeHierarchySupertypes(params.item, token) ?? [];
          });
          server2.connection.languages.typeHierarchy.onSubtypes(async (params, token) => {
            return await lastTypeHierarchyLs?.getTypeHierarchySubtypes(params.item, token) ?? [];
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.hoverProvider)) {
          serverCapabilities.hoverProvider = true;
          server2.connection.onHover(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getHover(uri, params.position, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentHighlightProvider)) {
          serverCapabilities.documentHighlightProvider = true;
          server2.connection.onDocumentHighlight(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getDocumentHighlights(uri, params.position, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.workspaceSymbolProvider)) {
          serverCapabilities.workspaceSymbolProvider = {};
          server2.connection.onWorkspaceSymbol(async (params, token) => {
            let languageServices = await project.getExistingLanguageServices();
            if (!languageServices.length) {
              for (const document of documents.all()) {
                await project.getLanguageService(vscode_uri_1.URI.parse(document.uri));
              }
              languageServices = await project.getExistingLanguageServices();
            }
            const symbols = [];
            for (const languageService of languageServices) {
              if (token.isCancellationRequested) {
                return;
              }
              let languageServiceId = languageServiceToId.get(languageService);
              if (languageServiceId === void 0) {
                languageServiceId = currentLanguageServiceId;
                languageServiceToId.set(languageService, languageServiceId);
                languageServiceById.set(languageServiceId, new WeakRef(languageService));
              }
              const languageServiceResult = await languageService.getWorkspaceSymbols(params.query, token);
              for (const symbol of languageServiceResult) {
                symbol.data = {
                  languageServiceId,
                  originalData: symbol.data
                };
              }
              symbols.push(...await languageService.getWorkspaceSymbols(params.query, token));
            }
            return symbols;
          });
          if (languageServicePlugins.some(({ capabilities }) => capabilities.workspaceSymbolProvider?.resolveProvider)) {
            serverCapabilities.workspaceSymbolProvider.resolveProvider = true;
            server2.connection.onWorkspaceSymbolResolve(async (symbol, token) => {
              const languageServiceId = symbol.data?.languageServiceId;
              const languageService = languageServiceById.get(languageServiceId)?.deref();
              if (!languageService) {
                return symbol;
              }
              symbol.data = symbol.data?.originalData;
              return await languageService.resolveWorkspaceSymbol?.(symbol, token);
            });
          }
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.renameProvider)) {
          serverCapabilities.renameProvider = {};
          server2.connection.onRenameRequest(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getRenameEdits(uri, params.position, params.newName, token);
            });
          });
          if (languageServicePlugins.some(({ capabilities }) => capabilities.renameProvider?.prepareProvider)) {
            serverCapabilities.renameProvider.prepareProvider = true;
            server2.connection.onPrepareRename(async (params, token) => {
              const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
              return await worker(uri, token, async (languageService) => {
                const result = await languageService.getRenameRange(uri, params.position, token);
                if (result && "message" in result) {
                  return new vscode2.ResponseError(0, result.message);
                }
                return result;
              });
            });
          }
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentLinkProvider)) {
          serverCapabilities.documentLinkProvider = {};
          server2.connection.onDocumentLinks(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              lastDocumentLinkLs = languageService;
              return languageService.getDocumentLinks(uri, token);
            });
          });
          if (languageServicePlugins.some(({ capabilities }) => capabilities.documentLinkProvider?.resolveProvider)) {
            serverCapabilities.documentLinkProvider.resolveProvider = true;
            server2.connection.onDocumentLinkResolve(async (link, token) => {
              return await lastDocumentLinkLs?.resolveDocumentLink(link, token);
            });
          }
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.codeLensProvider)) {
          serverCapabilities.codeLensProvider = {};
          server2.connection.onCodeLens(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              lastCodeLensLs = languageService;
              return languageService.getCodeLenses(uri, token);
            });
          });
          if (languageServicePlugins.some(({ capabilities }) => capabilities.codeLensProvider?.resolveProvider)) {
            serverCapabilities.codeLensProvider.resolveProvider = true;
            server2.connection.onCodeLensResolve(async (codeLens, token) => {
              return await lastCodeLensLs?.resolveCodeLens(codeLens, token) ?? codeLens;
            });
          }
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.inlayHintProvider)) {
          serverCapabilities.inlayHintProvider = {};
          server2.connection.languages.inlayHint.on(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              lastInlayHintLs = languageService;
              return languageService.getInlayHints(uri, params.range, token);
            });
          });
          if (languageServicePlugins.some(({ capabilities }) => capabilities.inlayHintProvider?.resolveProvider)) {
            serverCapabilities.inlayHintProvider.resolveProvider = true;
            server2.connection.languages.inlayHint.resolve(async (hint, token) => {
              return await lastInlayHintLs?.resolveInlayHint(hint, token) ?? hint;
            });
          }
          refreshHandlers.push(() => {
            if (initializeParams.capabilities.workspace?.inlayHint?.refreshSupport) {
              server2.connection.languages.inlayHint.refresh();
            } else {
              wranCapabilitiesNotSupported("workspace.inlayHint.refreshSupport");
            }
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.signatureHelpProvider)) {
          serverCapabilities.signatureHelpProvider = {
            triggerCharacters: [
              ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.signatureHelpProvider?.triggerCharacters ?? []).flat())
            ],
            retriggerCharacters: [
              ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.signatureHelpProvider?.retriggerCharacters ?? []).flat())
            ]
          };
          server2.connection.onSignatureHelp(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getSignatureHelp(uri, params.position, params.context, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.completionProvider)) {
          serverCapabilities.completionProvider = {
            triggerCharacters: [
              ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.completionProvider?.triggerCharacters ?? []).flat())
            ]
          };
          server2.connection.onCompletion(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, async (languageService) => {
              lastCompleteUri = params.textDocument.uri;
              lastCompleteLs = languageService;
              const list = await languageService.getCompletionItems(uri, params.position, params.context, token);
              list.items = list.items.map((item) => handleCompletionItem(initializeParams, item));
              return list;
            });
          });
          if (languageServicePlugins.some(({ capabilities }) => capabilities.completionProvider?.resolveProvider)) {
            serverCapabilities.completionProvider.resolveProvider = true;
            server2.connection.onCompletionResolve(async (item, token) => {
              if (lastCompleteUri && lastCompleteLs) {
                item = await lastCompleteLs.resolveCompletionItem(item, token);
                item = handleCompletionItem(initializeParams, item);
              }
              return item;
            });
          }
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.semanticTokensProvider)) {
          serverCapabilities.semanticTokensProvider = {
            full: true,
            range: true,
            legend: {
              tokenTypes: [
                ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.semanticTokensProvider?.legend?.tokenTypes ?? []).flat())
              ],
              tokenModifiers: [
                ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.semanticTokensProvider?.legend?.tokenModifiers ?? []).flat())
              ]
            }
          };
          server2.connection.languages.semanticTokens.on(async (params, token, _, resultProgress) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, async (languageService) => {
              return await languageService?.getSemanticTokens(uri, void 0, serverCapabilities.semanticTokensProvider.legend, (tokens) => resultProgress?.report(tokens), token);
            }) ?? { data: [] };
          });
          server2.connection.languages.semanticTokens.onRange(async (params, token, _, resultProgress) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, async (languageService) => {
              return await languageService?.getSemanticTokens(uri, params.range, serverCapabilities.semanticTokensProvider.legend, (tokens) => resultProgress?.report(tokens), token);
            }) ?? { data: [] };
          });
          refreshHandlers.push(() => {
            if (initializeParams.capabilities.workspace?.semanticTokens?.refreshSupport) {
              server2.connection.languages.semanticTokens.refresh();
            } else {
              wranCapabilitiesNotSupported("workspace.semanticTokens.refreshSupport");
            }
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.codeActionProvider)) {
          serverCapabilities.codeActionProvider = {
            codeActionKinds: languageServicePlugins.some(({ capabilities }) => capabilities.codeActionProvider?.codeActionKinds) ? [
              ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.codeActionProvider?.codeActionKinds ?? []).flat())
            ] : void 0
          };
          server2.connection.onCodeAction(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, async (languageService) => {
              lastCodeActionLs = languageService;
              let codeActions = await languageService.getCodeActions(uri, params.range, params.context, token) ?? [];
              for (const codeAction of codeActions) {
                if (codeAction.data && typeof codeAction.data === "object") {
                  codeAction.data.uri = params.textDocument.uri;
                } else {
                  codeAction.data = { uri: params.textDocument.uri };
                }
              }
              if (!initializeParams.capabilities.textDocument?.codeAction?.disabledSupport && codeActions.some((codeAction) => !codeAction.disabled)) {
                codeActions = codeActions.filter((codeAction) => !codeAction.disabled);
                wranCapabilitiesNotSupported("textDocument.codeAction.disabledSupport");
              }
              return codeActions;
            });
          });
          if (languageServicePlugins.some(({ capabilities }) => capabilities.codeActionProvider?.resolveProvider)) {
            serverCapabilities.codeActionProvider.resolveProvider = true;
            server2.connection.onCodeActionResolve(async (codeAction, token) => {
              return await lastCodeActionLs?.resolveCodeAction(codeAction, token) ?? codeAction;
            });
          }
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentOnTypeFormattingProvider)) {
          serverCapabilities.documentOnTypeFormattingProvider = {
            firstTriggerCharacter: [
              ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.documentOnTypeFormattingProvider?.triggerCharacters ?? []).flat())
            ][0],
            moreTriggerCharacter: [
              ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.documentOnTypeFormattingProvider?.triggerCharacters ?? []).flat())
            ].slice(1)
          };
          server2.connection.onDocumentOnTypeFormatting(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getDocumentFormattingEdits(uri, params.options, void 0, params, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.executeCommandProvider)) {
          serverCapabilities.executeCommandProvider = {
            commands: [
              ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.executeCommandProvider?.commands ?? []).flat())
            ]
          };
          server2.connection.onExecuteCommand(async (params, token) => {
            let languageServices = await project.getExistingLanguageServices();
            if (!languageServices.length) {
              for (const document of documents.all()) {
                await project.getLanguageService(vscode_uri_1.URI.parse(document.uri));
              }
              languageServices = await project.getExistingLanguageServices();
            }
            for (const languageService of languageServices) {
              if (languageService.executeCommand && languageService.commands.includes(params.command)) {
                try {
                  return await languageService.executeCommand(params.command, params.arguments ?? [], token);
                } catch {
                }
              }
            }
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.monikerProvider)) {
          serverCapabilities.monikerProvider = true;
          server2.connection.languages.moniker.on(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getMoniker(uri, params.position, token);
            }) ?? null;
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.inlineValueProvider)) {
          serverCapabilities.inlineValueProvider = true;
          server2.connection.languages.inlineValue.on(async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getInlineValue(uri, params.range, params.context, token);
            });
          });
          refreshHandlers.push(() => {
            if (initializeParams.capabilities.workspace?.inlineValue?.refreshSupport) {
              server2.connection.languages.inlineValue.refresh();
            } else {
              wranCapabilitiesNotSupported("workspace.inlineValue.refreshSupport");
            }
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.autoInsertionProvider)) {
          const triggerCharacterToConfigurationSections = /* @__PURE__ */ new Map();
          const tryAdd = (char, section) => {
            let sectionSet = triggerCharacterToConfigurationSections.get(char);
            if (!sectionSet) {
              triggerCharacterToConfigurationSections.set(char, sectionSet = /* @__PURE__ */ new Set());
            }
            if (section) {
              sectionSet.add(section);
            }
          };
          for (const { capabilities } of languageServicePlugins) {
            if (capabilities.autoInsertionProvider) {
              const { triggerCharacters, configurationSections } = capabilities.autoInsertionProvider;
              if (configurationSections) {
                if (configurationSections.length !== triggerCharacters.length) {
                  throw new Error("configurationSections.length !== triggerCharacters.length");
                }
                for (let i = 0; i < configurationSections.length; i++) {
                  tryAdd(triggerCharacters[i], configurationSections[i]);
                }
              } else {
                for (const char of triggerCharacters) {
                  tryAdd(char);
                }
              }
            }
          }
          serverCapabilities.experimental ??= {};
          serverCapabilities.experimental.autoInsertionProvider = {
            triggerCharacters: [],
            configurationSections: []
          };
          for (const [char, sections] of triggerCharacterToConfigurationSections) {
            if (sections.size) {
              serverCapabilities.experimental.autoInsertionProvider.triggerCharacters.push(char);
              serverCapabilities.experimental.autoInsertionProvider.configurationSections.push([...sections]);
            } else {
              serverCapabilities.experimental.autoInsertionProvider.triggerCharacters.push(char);
              serverCapabilities.experimental.autoInsertionProvider.configurationSections.push(null);
            }
          }
          server2.connection.onRequest(protocol_1.AutoInsertRequest.type, async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getAutoInsertSnippet(uri, params.selection, params.change, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.fileRenameEditsProvider)) {
          serverCapabilities.experimental ??= {};
          serverCapabilities.experimental.fileRenameEditsProvider = true;
          server2.connection.workspace.onWillRenameFiles(async (params, token) => {
            const _edits = await Promise.all(params.files.map(async (file) => {
              const oldUri = vscode_uri_1.URI.parse(file.oldUri);
              const newUri = vscode_uri_1.URI.parse(file.newUri);
              return await worker(oldUri, token, (languageService) => {
                return languageService.getFileRenameEdits(oldUri, newUri, token) ?? null;
              }) ?? null;
            }));
            const edits = _edits.filter((edit) => !!edit);
            if (edits.length) {
              (0, language_service_1.mergeWorkspaceEdits)(edits[0], ...edits.slice(1));
              return edits[0];
            }
            return null;
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.fileReferencesProvider)) {
          serverCapabilities.experimental ??= {};
          serverCapabilities.experimental.fileReferencesProvider = true;
          server2.connection.onRequest(protocol_1.FindFileReferenceRequest.type, async (params, token) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            return await worker(uri, token, (languageService) => {
              return languageService.getFileReferences(uri, token);
            });
          });
        }
        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentDropEditsProvider)) {
          serverCapabilities.experimental ??= {};
          serverCapabilities.experimental.documentDropEditsProvider = true;
          server2.connection.onRequest(protocol_1.DocumentDropRequest.type, async ({ textDocument, position, dataTransfer }, token) => {
            const dataTransferMap = /* @__PURE__ */ new Map();
            for (const item of dataTransfer) {
              dataTransferMap.set(item.mimeType, {
                value: item.value,
                asString() {
                  return server2.connection.sendRequest(protocol_1.DocumentDrop_DataTransferItemAsStringRequest.type, {
                    mimeType: item.mimeType
                  });
                },
                asFile() {
                  if (item.file) {
                    return {
                      name: item.file.name,
                      uri: item.file.uri,
                      data() {
                        return server2.connection.sendRequest(protocol_1.DocumentDrop_DataTransferItemFileDataRequest.type, {
                          mimeType: item.mimeType
                        });
                      }
                    };
                  }
                }
              });
            }
            const uri = vscode_uri_1.URI.parse(textDocument.uri);
            const languageService = await project.getLanguageService(uri);
            return languageService.getDocumentDropEdits(uri, position, dataTransferMap, token);
          });
        }
        const supportsDiagnosticPull = !!initializeParams.capabilities.workspace?.diagnostics;
        const diagnosticProvider = languageServicePlugins.some(({ capabilities }) => !!capabilities.diagnosticProvider);
        const interFileDependencies = languageServicePlugins.some(({ capabilities }) => capabilities.diagnosticProvider?.interFileDependencies);
        const workspaceDiagnostics = languageServicePlugins.some(({ capabilities }) => capabilities.diagnosticProvider?.workspaceDiagnostics);
        if (diagnosticProvider) {
          if (supportsDiagnosticPull && !interFileDependencies) {
            serverCapabilities.diagnosticProvider = {
              // Unreliable, see https://github.com/microsoft/vscode-languageserver-node/issues/848#issuecomment-2189521060
              interFileDependencies: false,
              workspaceDiagnostics
            };
            refreshHandlers.push(() => {
              if (initializeParams.capabilities.workspace?.diagnostics?.refreshSupport) {
                server2.connection.languages.diagnostics.refresh();
              } else {
                wranCapabilitiesNotSupported("workspace.diagnostics.refreshSupport");
              }
            });
          } else {
            documents.onDidChangeContent(({ document }) => {
              const changedDocument = documents.get(vscode_uri_1.URI.parse(document.uri));
              if (!changedDocument) {
                return;
              }
              if (interFileDependencies) {
                const remainingDocuments = [...documents.all()].filter((doc) => doc !== changedDocument);
                updateDiagnosticsBatch(project, [changedDocument, ...remainingDocuments]);
              } else {
                updateDiagnosticsBatch(project, [changedDocument]);
              }
            });
            documents.onDidClose(({ document }) => {
              server2.connection.sendDiagnostics({ uri: document.uri, diagnostics: [] });
            });
            refreshHandlers.push(async (clearDiagnostics) => {
              if (clearDiagnostics) {
                for (const document of documents.all()) {
                  server2.connection.sendDiagnostics({ uri: document.uri, diagnostics: [] });
                }
              }
              await updateDiagnosticsBatch(project, [...documents.all()]);
            });
          }
          server2.connection.languages.diagnostics.on(async (params, token, _workDoneProgressReporter, resultProgressReporter) => {
            const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
            const result = await worker(uri, token, (languageService) => {
              return languageService.getDiagnostics(uri, (errors) => {
                resultProgressReporter?.report({
                  relatedDocuments: {
                    [params.textDocument.uri]: {
                      kind: vscode2.DocumentDiagnosticReportKind.Full,
                      items: errors
                    }
                  }
                });
              }, token);
            });
            return {
              kind: vscode2.DocumentDiagnosticReportKind.Full,
              items: result ?? []
            };
          });
        }
        if (workspaceDiagnostics) {
          server2.connection.languages.diagnostics.onWorkspace(async (_params, token) => {
            let languageServices = await project.getExistingLanguageServices();
            if (!languageServices.length) {
              for (const document of documents.all()) {
                await project.getLanguageService(vscode_uri_1.URI.parse(document.uri));
              }
              languageServices = await project.getExistingLanguageServices();
            }
            const items = [];
            for (const languageService of languageServices) {
              if (token.isCancellationRequested) {
                break;
              }
              const result = await languageService.getWorkspaceDiagnostics(token);
              items.push(...result);
            }
            return { items };
          });
        }
      });
      return { requestRefresh };
      async function requestRefresh(clearDiagnostics) {
        const req = ++refreshReq;
        const delay = 250;
        await sleep(delay);
        if (req !== refreshReq) {
          return;
        }
        for (const handler of refreshHandlers) {
          handler(clearDiagnostics);
        }
      }
      async function updateDiagnosticsBatch(project, documents2) {
        const req = ++updateDiagnosticsBatchReq;
        const delay = 250;
        const token = {
          get isCancellationRequested() {
            return req !== updateDiagnosticsBatchReq;
          },
          onCancellationRequested: vscode2.Event.None
        };
        for (const doc of documents2) {
          await sleep(delay);
          if (token.isCancellationRequested) {
            break;
          }
          await updateDiagnostics(project, vscode_uri_1.URI.parse(doc.uri), doc.version, token);
        }
      }
      async function updateDiagnostics(project, uri, version, token) {
        const languageService = await project.getLanguageService(uri);
        const diagnostics = await languageService.getDiagnostics(uri, (diagnostics2) => server2.connection.sendDiagnostics({ uri: uri.toString(), diagnostics: diagnostics2, version }), token);
        if (!token.isCancellationRequested) {
          server2.connection.sendDiagnostics({ uri: uri.toString(), diagnostics, version });
        }
      }
      function worker(uri, token, cb) {
        return new Promise((resolve) => {
          server2.env.timer.setImmediate(async () => {
            if (token.isCancellationRequested) {
              resolve(void 0);
              return;
            }
            const languageService = await server2.project.getLanguageService((0, language_service_1.decodeEmbeddedDocumentUri)(uri)?.[0] ?? uri);
            const result = await cb(languageService);
            if (token.isCancellationRequested) {
              resolve(void 0);
              return;
            }
            resolve(result);
          });
        });
      }
      function handleCompletionItem(initializeParams, item) {
        const snippetSupport = initializeParams.capabilities.textDocument?.completion?.completionItem?.snippetSupport ?? false;
        const insertReplaceSupport = initializeParams.capabilities.textDocument?.completion?.completionItem?.insertReplaceSupport ?? false;
        if (!snippetSupport && item.insertTextFormat === vscode2.InsertTextFormat.Snippet) {
          item.insertTextFormat = vscode2.InsertTextFormat.PlainText;
          if (item.insertText) {
            item.insertText = item.insertText.replace(/\$\d+/g, "");
            item.insertText = item.insertText.replace(/\${\d+:([^}]*)}/g, "");
          }
          wranCapabilitiesNotSupported("textDocument.completion.completionItem.snippetSupport");
        }
        if (!insertReplaceSupport && item.textEdit && vscode2.InsertReplaceEdit.is(item.textEdit)) {
          item.textEdit = vscode2.TextEdit.replace(item.textEdit.insert, item.textEdit.newText);
          wranCapabilitiesNotSupported("textDocument.completion.completionItem.insertReplaceSupport");
        }
        return item;
      }
      function handleDefinitions(initializeParams, type, items) {
        const linkSupport = initializeParams.capabilities.textDocument?.[type]?.linkSupport ?? false;
        if (!linkSupport) {
          wranCapabilitiesNotSupported(`textDocument.${type}.linkSupport`);
          return items.map((item) => ({
            uri: item.targetUri,
            range: item.targetRange
          }));
        }
        return items;
      }
    }
    function wranCapabilitiesNotSupported(path3) {
      if (reportedCapabilities.has(path3)) {
        return;
      }
      reportedCapabilities.add(path3);
      console.warn(`${path3} is not supported by the client but could be used by the server.`);
    }
    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/utils/combineChangeRanges.js
var require_combineChangeRanges = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/utils/combineChangeRanges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineChangeRanges = combineChangeRanges;
    function combineChangeRanges(...changeRanges) {
      let changeRange = changeRanges[0];
      for (let i = 1; i < changeRanges.length; i++) {
        const nextChangeRange = changeRanges[i];
        changeRange = combineTwoChanges(changeRange, nextChangeRange);
      }
      return changeRange;
    }
    function combineTwoChanges(a, b) {
      const aStart = a.span.start;
      const aEnd = a.span.start + a.span.length;
      const aDiff = a.newLength - a.span.length;
      const changeBegin = aStart + Math.min(a.span.length, a.newLength);
      const rollback = (start2) => start2 > changeBegin ? Math.max(aStart, start2 - aDiff) : start2;
      const bStart = rollback(b.span.start);
      const bEnd = rollback(b.span.start + b.span.length);
      const bDiff = b.newLength - b.span.length;
      const start = Math.min(aStart, bStart);
      const end = Math.max(aEnd, bEnd);
      const length = end - start;
      const newLength = aDiff + bDiff + length;
      return { span: { start, length }, newLength };
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/utils/snapshotDocument.js
var require_snapshotDocument = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/utils/snapshotDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SnapshotDocument = void 0;
    var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
    var combineChangeRanges_1 = require_combineChangeRanges();
    var SnapshotDocument = class {
      constructor(uri, languageId, version, text) {
        this.snapshots = [];
        this.document = vscode_languageserver_textdocument_1.TextDocument.create(uri, languageId, version, text);
        this.resetChanges();
      }
      get uri() {
        return this.document.uri;
      }
      get languageId() {
        return this.document.languageId;
      }
      get version() {
        return this.document.version;
      }
      get lineCount() {
        return this.document.lineCount;
      }
      getText(range) {
        return this.document.getText(range);
      }
      positionAt(offset) {
        return this.document.positionAt(offset);
      }
      offsetAt(position) {
        return this.document.offsetAt(position);
      }
      /**
       * Update the document with the given content changes and version.
       * If all changes is incremental, calculate the change range and add a new snapshot.
       * Otherwise, reset the changes.
       */
      update(contentChanges, version) {
        if (contentChanges.every((change) => "range" in change)) {
          let changeRanges = [];
          for (const contentChange of contentChanges) {
            if (!("range" in contentChange)) {
              continue;
            }
            const start = this.offsetAt(contentChange.range.start);
            const length = contentChange.rangeLength ?? this.offsetAt(contentChange.range.end) - start;
            changeRanges.push({
              span: { start, length },
              newLength: contentChange.text.length
            });
            vscode_languageserver_textdocument_1.TextDocument.update(this.document, [contentChange], version);
          }
          this.snapshots.push({
            changeRange: (0, combineChangeRanges_1.combineChangeRanges)(...changeRanges),
            version,
            ref: void 0
          });
        } else {
          vscode_languageserver_textdocument_1.TextDocument.update(this.document, contentChanges, version);
          this.resetChanges();
        }
      }
      getSnapshot() {
        this.clearUnreferencedVersions();
        const lastChange = this.snapshots[this.snapshots.length - 1];
        if (!lastChange.ref) {
          const text = this.document.getText();
          const changeRangeCache = /* @__PURE__ */ new WeakMap();
          const snapshot = {
            getText: (start, end) => text.substring(start, end),
            getLength: () => text.length,
            getChangeRange: (oldSnapshot) => {
              if (!changeRangeCache.has(oldSnapshot)) {
                const oldIndex = this.snapshots.findIndex((change) => change.ref?.deref() === oldSnapshot);
                if (oldIndex >= 0) {
                  const start = oldIndex + 1;
                  const end = this.snapshots.indexOf(lastChange) + 1;
                  const changeRanges = this.snapshots.slice(start, end).map((change) => change.changeRange);
                  const changeRange = (0, combineChangeRanges_1.combineChangeRanges)(...changeRanges);
                  changeRangeCache.set(oldSnapshot, changeRange);
                } else {
                  changeRangeCache.set(oldSnapshot, void 0);
                }
              }
              return changeRangeCache.get(oldSnapshot);
            }
          };
          lastChange.ref = new WeakRef(snapshot);
        }
        return lastChange.ref.deref();
      }
      resetChanges() {
        this.snapshots = [
          {
            changeRange: {
              span: {
                start: 0,
                length: 0
              },
              newLength: this.document.getText().length
            },
            version: this.document.version,
            ref: void 0
          }
        ];
      }
      clearUnreferencedVersions() {
        let firstReferencedIndex = 0;
        while (firstReferencedIndex < this.snapshots.length - 1 && !this.snapshots[firstReferencedIndex].ref?.deref()) {
          firstReferencedIndex++;
        }
        this.snapshots = this.snapshots.slice(firstReferencedIndex);
      }
    };
    exports2.SnapshotDocument = SnapshotDocument;
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/textDocuments.js
var require_textDocuments2 = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var vscode2 = require_main4();
    var vscode_uri_1 = require_umd();
    var snapshotDocument_1 = require_snapshotDocument();
    function register(server2) {
      const syncedDocumentParsedUriToUri = /* @__PURE__ */ new Map();
      const documentsCache = /* @__PURE__ */ new Map();
      const documents = new vscode2.TextDocuments({
        create(uri, languageId, version, text) {
          const cache = documentsCache.get(uri)?.deref();
          if (cache && cache.languageId === languageId && cache.version === version && cache.getText() === text) {
            return cache;
          }
          const document = new snapshotDocument_1.SnapshotDocument(uri, languageId, version, text);
          documentsCache.set(uri, new WeakRef(document));
          return document;
        },
        update(snapshot, contentChanges, version) {
          snapshot.update(contentChanges, version);
          return snapshot;
        }
      });
      documents.listen(server2.connection);
      documents.onDidOpen(({ document }) => {
        const parsedUri = vscode_uri_1.URI.parse(document.uri);
        syncedDocumentParsedUriToUri.set(parsedUri.toString(), document.uri);
      });
      documents.onDidClose(({ document }) => {
        const parsedUri = vscode_uri_1.URI.parse(document.uri);
        syncedDocumentParsedUriToUri.delete(parsedUri.toString());
      });
      server2.onInitialize((serverCapabilities) => {
        serverCapabilities.textDocumentSync = vscode2.TextDocumentSyncKind.Incremental;
      });
      return {
        all: documents.all.bind(documents),
        onDidChangeContent: documents.onDidChangeContent.bind(documents),
        onDidOpen: documents.onDidOpen.bind(documents),
        onDidClose: documents.onDidClose.bind(documents),
        onDidSave: documents.onDidSave.bind(documents),
        get(uri) {
          return documents.get(getSyncedDocumentKey(uri) ?? uri.toString());
        }
      };
      function getSyncedDocumentKey(uri) {
        const originalUri = syncedDocumentParsedUriToUri.get(uri.toString());
        if (originalUri) {
          return originalUri;
        }
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/workspaceFolders.js
var require_workspaceFolders = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/features/workspaceFolders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var language_service_1 = require_language_service();
    var vscode_uri_1 = require_umd();
    function register(server2) {
      const folders = (0, language_service_1.createUriMap)();
      const didChangeCallbacks = /* @__PURE__ */ new Set();
      server2.onInitialize((serverCapabilities) => {
        const { initializeParams } = server2;
        if (initializeParams.workspaceFolders?.length) {
          for (const folder of initializeParams.workspaceFolders) {
            folders.set(vscode_uri_1.URI.parse(folder.uri), true);
          }
        } else if (initializeParams.rootUri) {
          folders.set(vscode_uri_1.URI.parse(initializeParams.rootUri), true);
        } else if (initializeParams.rootPath) {
          folders.set(vscode_uri_1.URI.file(initializeParams.rootPath), true);
        }
        serverCapabilities.workspace ??= {};
        serverCapabilities.workspace.workspaceFolders = {
          supported: true,
          changeNotifications: true
        };
      });
      server2.onInitialized(() => {
        if (server2.initializeParams.capabilities.workspace?.workspaceFolders) {
          server2.connection.workspace.onDidChangeWorkspaceFolders((e) => {
            e.added = e.added.filter((folder) => !folders.has(vscode_uri_1.URI.parse(folder.uri)));
            e.removed = e.removed.filter((folder) => folders.has(vscode_uri_1.URI.parse(folder.uri)));
            if (e.added.length || e.removed.length) {
              for (const folder of e.added) {
                folders.set(vscode_uri_1.URI.parse(folder.uri), true);
              }
              for (const folder of e.removed) {
                folders.delete(vscode_uri_1.URI.parse(folder.uri));
              }
              server2.project.reload();
              for (const cb of didChangeCallbacks) {
                cb(e);
              }
            }
          });
        }
      });
      return {
        get all() {
          return [...folders.keys()];
        },
        has(uri) {
          return folders.has(uri);
        },
        onDidChange
      };
      function onDidChange(cb) {
        didChangeCallbacks.add(cb);
        return {
          dispose() {
            didChangeCallbacks.delete(cb);
          }
        };
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/server.js
var require_server2 = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createServerBase = createServerBase;
    var configurations_js_1 = require_configurations();
    var editorFeatures_js_1 = require_editorFeatures();
    var fileSystem_js_1 = require_fileSystem();
    var fileWatcher_js_1 = require_fileWatcher();
    var languageFeatures_js_1 = require_languageFeatures();
    var textDocuments_js_1 = require_textDocuments2();
    var workspaceFolders_js_1 = require_workspaceFolders();
    function createServerBase(connection2, env) {
      const onInitializeCallbacks = [];
      const onInitializedCallbacks = [];
      const state = {
        env,
        connection: connection2,
        initializeParams: void 0,
        project: void 0,
        languageServicePlugins: void 0,
        onInitialize(callback) {
          onInitializeCallbacks.push(callback);
        },
        onInitialized(callback) {
          onInitializedCallbacks.push(callback);
        }
      };
      const configurations = (0, configurations_js_1.register)(state);
      const editorFeatures = (0, editorFeatures_js_1.register)(state);
      const documents = (0, textDocuments_js_1.register)(state);
      const workspaceFolders = (0, workspaceFolders_js_1.register)(state);
      const fileWatcher = (0, fileWatcher_js_1.register)(state);
      const languageFeatures = (0, languageFeatures_js_1.register)(state, documents, configurations);
      const fileSystem = (0, fileSystem_js_1.register)(documents, fileWatcher);
      const server2 = {
        ...state,
        get initializeParams() {
          return state.initializeParams;
        },
        get project() {
          return state.project;
        },
        get languageServicePlugins() {
          return state.languageServicePlugins;
        },
        initialize(params, project, languageServicePlugins) {
          state.initializeParams = params;
          state.project = project;
          state.languageServicePlugins = languageServicePlugins;
          const serverCapabilities = {};
          onInitializeCallbacks.forEach((cb) => cb(serverCapabilities));
          return { capabilities: serverCapabilities };
        },
        initialized() {
          onInitializedCallbacks.forEach((cb) => cb());
          state.project.setup(server2);
        },
        shutdown() {
          state.project.reload();
        },
        configurations,
        editorFeatures,
        documents,
        workspaceFolders,
        fileWatcher,
        languageFeatures,
        fileSystem
      };
      return server2;
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/types.js
var require_types3 = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/index.js
var require_language_server = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_types3(), exports2);
    __exportStar2(require_protocol2(), exports2);
    __exportStar2(require_types(), exports2);
    __exportStar2(require_types2(), exports2);
    __exportStar2(require_main4(), exports2);
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/project/simpleProject.js
var require_simpleProject = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/project/simpleProject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSimpleProject = createSimpleProject2;
    exports2.createLanguageServiceEnvironment = createLanguageServiceEnvironment;
    var language_service_1 = require_language_service();
    function createSimpleProject2(languagePlugins) {
      let server2;
      let languageService;
      return {
        setup(_server) {
          server2 = _server;
          const language = (0, language_service_1.createLanguage)([
            { getLanguageId: (uri) => server2.documents.get(uri)?.languageId },
            ...languagePlugins
          ], (0, language_service_1.createUriMap)(false), (uri) => {
            const document = server2.documents.get(uri);
            if (document) {
              language.scripts.set(uri, document.getSnapshot(), document.languageId);
            } else {
              language.scripts.delete(uri);
            }
          });
          languageService = (0, language_service_1.createLanguageService)(language, server2.languageServicePlugins, createLanguageServiceEnvironment(server2, server2.workspaceFolders.all), {});
        },
        getLanguageService() {
          return languageService;
        },
        getExistingLanguageServices() {
          return [languageService];
        },
        reload() {
          languageService.dispose();
          this.setup(server2);
        }
      };
    }
    function createLanguageServiceEnvironment(server2, workspaceFolders) {
      return {
        workspaceFolders,
        fs: server2.fileSystem,
        locale: server2.initializeParams?.locale,
        clientCapabilities: server2.initializeParams?.capabilities,
        getConfiguration: server2.configurations.get,
        onDidChangeConfiguration: server2.configurations.onDidChange,
        onDidChangeWatchedFiles: server2.fileWatcher.onDidChangeWatchedFiles
      };
    }
  }
});

// node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js"(exports2, module2) {
    "use strict";
    function assertPath(path3) {
      if (typeof path3 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path3));
      }
    }
    function normalizeStringPosix(path3, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path3.length; ++i) {
        if (i < path3.length)
          code = path3.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path3.slice(lastSlash + 1, i);
            else
              res = path3.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path3;
          if (i >= 0)
            path3 = arguments[i];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path3 = cwd;
          }
          assertPath(path3);
          if (path3.length === 0) {
            continue;
          }
          resolvedPath = path3 + "/" + resolvedPath;
          resolvedAbsolute = path3.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path3) {
        assertPath(path3);
        if (path3.length === 0) return ".";
        var isAbsolute = path3.charCodeAt(0) === 47;
        var trailingSeparator = path3.charCodeAt(path3.length - 1) === 47;
        path3 = normalizeStringPosix(path3, !isAbsolute);
        if (path3.length === 0 && !isAbsolute) path3 = ".";
        if (path3.length > 0 && trailingSeparator) path3 += "/";
        if (isAbsolute) return "/" + path3;
        return path3;
      },
      isAbsolute: function isAbsolute(path3) {
        assertPath(path3);
        return path3.length > 0 && path3.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path3) {
        return path3;
      },
      dirname: function dirname2(path3) {
        assertPath(path3);
        if (path3.length === 0) return ".";
        var code = path3.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path3.length - 1; i >= 1; --i) {
          code = path3.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path3.slice(0, end);
      },
      basename: function basename(path3, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path3);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path3.length) {
          if (ext.length === path3.length && ext === path3) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path3.length - 1; i >= 0; --i) {
            var code = path3.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path3.length;
          return path3.slice(start, end);
        } else {
          for (i = path3.length - 1; i >= 0; --i) {
            if (path3.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) return "";
          return path3.slice(start, end);
        }
      },
      extname: function extname(path3) {
        assertPath(path3);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path3.length - 1; i >= 0; --i) {
          var code = path3.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path3.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path3) {
        assertPath(path3);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path3.length === 0) return ret;
        var code = path3.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path3.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path3.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path3.slice(1, end);
            else ret.base = ret.name = path3.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path3.slice(1, startDot);
            ret.base = path3.slice(1, end);
          } else {
            ret.name = path3.slice(startPart, startDot);
            ret.base = path3.slice(startPart, end);
          }
          ret.ext = path3.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path3.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module2.exports = posix;
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/project/inferredCompilerOptions.js
var require_inferredCompilerOptions = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/project/inferredCompilerOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInferredCompilerOptions = getInferredCompilerOptions;
    async function getInferredCompilerOptions(server2) {
      const [implicitProjectConfig_1 = {}, implicitProjectConfig_2 = {}] = await Promise.all([
        server2.configurations.get("js/ts.implicitProjectConfig"),
        server2.configurations.get("javascript.implicitProjectConfig")
      ]);
      const checkJs = readCheckJs();
      const experimentalDecorators = readExperimentalDecorators();
      const strictNullChecks = readImplicitStrictNullChecks();
      const strictFunctionTypes = readImplicitStrictFunctionTypes();
      const options = {
        ...inferredProjectCompilerOptions("typescript"),
        allowJs: true,
        allowSyntheticDefaultImports: true,
        allowNonTsExtensions: true,
        resolveJsonModule: true,
        jsx: 1
      };
      return options;
      function readCheckJs() {
        return implicitProjectConfig_1["checkJs"] ?? implicitProjectConfig_2["checkJs"] ?? false;
      }
      function readExperimentalDecorators() {
        return implicitProjectConfig_1["experimentalDecorators"] ?? implicitProjectConfig_2["experimentalDecorators"] ?? false;
      }
      function readImplicitStrictNullChecks() {
        return implicitProjectConfig_1["strictNullChecks"] ?? false;
      }
      function readImplicitStrictFunctionTypes() {
        return implicitProjectConfig_1["strictFunctionTypes"] ?? true;
      }
      function inferredProjectCompilerOptions(projectType) {
        const projectConfig = {
          module: 1,
          target: 7,
          jsx: 1
        };
        if (checkJs) {
          projectConfig.checkJs = true;
          if (projectType === "typescript") {
            projectConfig.allowJs = true;
          }
        }
        if (experimentalDecorators) {
          projectConfig.experimentalDecorators = true;
        }
        if (strictNullChecks) {
          projectConfig.strictNullChecks = true;
        }
        if (strictFunctionTypes) {
          projectConfig.strictFunctionTypes = true;
        }
        if (projectType === "typescript") {
          projectConfig.sourceMap = true;
        }
        return projectConfig;
      }
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/common.js
var require_common2 = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveFileLanguageId = resolveFileLanguageId;
    function resolveFileLanguageId(path3) {
      const ext = path3.split(".").pop();
      switch (ext) {
        case "js":
          return "javascript";
        case "cjs":
          return "javascript";
        case "mjs":
          return "javascript";
        case "ts":
          return "typescript";
        case "cts":
          return "typescript";
        case "mts":
          return "typescript";
        case "jsx":
          return "javascriptreact";
        case "tsx":
          return "typescriptreact";
        case "json":
          return "json";
      }
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/resolveModuleName.js
var require_resolveModuleName = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/resolveModuleName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createResolveModuleName = createResolveModuleName;
    function createResolveModuleName(ts, getFileSize, host, languagePlugins, getSourceScript) {
      const toSourceFileInfo = /* @__PURE__ */ new Map();
      const moduleResolutionHost = {
        readFile: host.readFile.bind(host),
        directoryExists: host.directoryExists?.bind(host),
        realpath: host.realpath?.bind(host),
        getCurrentDirectory: host.getCurrentDirectory?.bind(host),
        getDirectories: host.getDirectories?.bind(host),
        useCaseSensitiveFileNames: typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames.bind(host) : host.useCaseSensitiveFileNames,
        fileExists(fileName) {
          const result = host.fileExists(fileName);
          for (const { typescript } of languagePlugins) {
            if (!typescript) {
              continue;
            }
            if (!result) {
              for (const { extension } of typescript.extraFileExtensions) {
                if (!fileName.endsWith(`.d.${extension}.ts`)) {
                  continue;
                }
                const sourceFileName = fileName.slice(0, -`.d.${extension}.ts`.length) + `.${extension}`;
                if (fileExists(sourceFileName)) {
                  const sourceScript = getSourceScript(sourceFileName);
                  if (sourceScript?.generated) {
                    const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
                    if (serviceScript) {
                      const dtsPath = sourceFileName + ".d.ts";
                      if ((serviceScript.extension === ".js" || serviceScript.extension === ".jsx") && fileExists(dtsPath)) {
                        toSourceFileInfo.set(fileName, {
                          sourceFileName: dtsPath,
                          extension: ".ts"
                        });
                      } else {
                        toSourceFileInfo.set(fileName, {
                          sourceFileName,
                          extension: serviceScript.extension
                        });
                      }
                      return true;
                    }
                  }
                }
              }
            }
            if (typescript.resolveHiddenExtensions && fileName.endsWith(`.d.ts`)) {
              for (const { extension } of typescript.extraFileExtensions) {
                const sourceFileName = fileName.slice(0, -`.d.ts`.length) + `.${extension}`;
                if (fileExists(sourceFileName)) {
                  const sourceScript = getSourceScript(sourceFileName);
                  if (sourceScript?.generated) {
                    const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
                    if (serviceScript) {
                      toSourceFileInfo.set(fileName, {
                        sourceFileName,
                        extension: serviceScript.extension
                      });
                      return true;
                    }
                  }
                }
              }
            }
          }
          return result;
        }
      };
      return (moduleName, containingFile, compilerOptions, cache, redirectedReference, resolutionMode) => {
        const result = ts.resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionHost, cache, redirectedReference, resolutionMode);
        if (result.resolvedModule) {
          const sourceFileInfo = toSourceFileInfo.get(result.resolvedModule.resolvedFileName);
          if (sourceFileInfo) {
            result.resolvedModule.resolvedFileName = sourceFileInfo.sourceFileName;
            result.resolvedModule.extension = sourceFileInfo.extension;
          }
        }
        toSourceFileInfo.clear();
        return result;
      };
      function fileExists(fileName) {
        if (host.fileExists(fileName)) {
          const fileSize = getFileSize?.(fileName) ?? host.readFile(fileName)?.length ?? 0;
          return fileSize < 4 * 1024 * 1024;
        }
        return false;
      }
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getServiceScript = getServiceScript;
    exports2.fixupImpliedNodeFormatForFile = fixupImpliedNodeFormatForFile;
    function getServiceScript(language, fileName) {
      const sourceScript = language.scripts.get(fileName);
      if (sourceScript?.targetIds.size) {
        for (const targetId of sourceScript.targetIds) {
          const targetScript = language.scripts.get(targetId);
          if (targetScript?.generated) {
            const serviceScript = targetScript.generated.languagePlugin.typescript?.getServiceScript(targetScript.generated.root);
            if (serviceScript) {
              return [serviceScript, targetScript, sourceScript];
            }
          }
        }
      }
      if (sourceScript?.associatedOnly) {
        return [void 0, sourceScript, sourceScript];
      }
      if (sourceScript?.generated) {
        const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
        if (serviceScript) {
          return [serviceScript, sourceScript, sourceScript];
        }
      }
      return [void 0, void 0, void 0];
    }
    function fixupImpliedNodeFormatForFile(ts, pluginExtensions, sourceFile, packageJsonInfoCache, host, options) {
      if (sourceFile.impliedNodeFormat !== void 0 || !pluginExtensions.some((ext) => sourceFile.fileName.endsWith(ext))) {
        return;
      }
      const validExts = [".d.ts", ".ts", ".tsx", ".js", ".jsx"];
      if (validExts.some((ext) => sourceFile.fileName.endsWith(ext))) {
        return;
      }
      const asTs = sourceFile.fileName + ".ts";
      const impliedNodeFormat = ts.getImpliedNodeFormatForFileWorker?.(asTs, packageJsonInfoCache, host, options)?.impliedNodeFormat;
      if (impliedNodeFormat === void 0) {
        return;
      }
      sourceFile.impliedNodeFormat = impliedNodeFormat;
      return () => sourceFile.impliedNodeFormat = void 0;
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/decorateLanguageServiceHost.js
var require_decorateLanguageServiceHost = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/decorateLanguageServiceHost.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decorateLanguageServiceHost = decorateLanguageServiceHost;
    exports2.searchExternalFiles = searchExternalFiles;
    var resolveModuleName_1 = require_resolveModuleName();
    var utils_1 = require_utils2();
    function decorateLanguageServiceHost(ts, language, languageServiceHost) {
      const pluginExtensions = language.plugins.map((plugin) => plugin.typescript?.extraFileExtensions.map((ext) => "." + ext.extension) ?? []).flat();
      const scripts = /* @__PURE__ */ new Map();
      const crashFileNames = /* @__PURE__ */ new Set();
      const readDirectory = languageServiceHost.readDirectory?.bind(languageServiceHost);
      const resolveModuleNameLiterals = languageServiceHost.resolveModuleNameLiterals?.bind(languageServiceHost);
      const resolveModuleNames = languageServiceHost.resolveModuleNames?.bind(languageServiceHost);
      const getScriptSnapshot = languageServiceHost.getScriptSnapshot.bind(languageServiceHost);
      const getScriptKind = languageServiceHost.getScriptKind?.bind(languageServiceHost);
      if (readDirectory) {
        languageServiceHost.readDirectory = (path3, extensions, exclude, include, depth) => {
          if (extensions) {
            for (const ext of pluginExtensions) {
              if (!extensions.includes(ext)) {
                extensions = [...extensions, ext];
              }
            }
          }
          return readDirectory(path3, extensions, exclude, include, depth);
        };
      }
      if (pluginExtensions.length) {
        const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts, ts.sys.getFileSize, languageServiceHost, language.plugins, (fileName) => language.scripts.get(fileName));
        const getCanonicalFileName = languageServiceHost.useCaseSensitiveFileNames?.() ? (fileName) => fileName : (fileName) => fileName.toLowerCase();
        const moduleResolutionCache = ts.createModuleResolutionCache(languageServiceHost.getCurrentDirectory(), getCanonicalFileName, languageServiceHost.getCompilationSettings());
        if (resolveModuleNameLiterals) {
          languageServiceHost.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, ...rest) => {
            const disposeFixup = (0, utils_1.fixupImpliedNodeFormatForFile)(ts, pluginExtensions, containingSourceFile, moduleResolutionCache.getPackageJsonInfoCache(), languageServiceHost, options);
            try {
              if (moduleLiterals.every((name) => !pluginExtensions.some((ext) => name.text.endsWith(ext)))) {
                return resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, ...rest);
              }
              return moduleLiterals.map((moduleLiteral) => {
                const mode = ts.getModeForUsageLocation(containingSourceFile, moduleLiteral, options);
                return resolveModuleName(moduleLiteral.text, containingFile, options, moduleResolutionCache, redirectedReference, mode);
              });
            } finally {
              disposeFixup?.();
            }
          };
        }
        if (resolveModuleNames) {
          languageServiceHost.resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile) => {
            if (moduleNames.every((name) => !pluginExtensions.some((ext) => name.endsWith(ext)))) {
              return resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile);
            }
            return moduleNames.map((moduleName) => {
              return resolveModuleName(moduleName, containingFile, options, moduleResolutionCache, redirectedReference).resolvedModule;
            });
          };
        }
      }
      languageServiceHost.getScriptSnapshot = (fileName) => {
        const virtualScript = updateVirtualScript(fileName, true);
        if (virtualScript) {
          return virtualScript.snapshot;
        }
        return getScriptSnapshot(fileName);
      };
      if (getScriptKind) {
        languageServiceHost.getScriptKind = (fileName) => {
          const virtualScript = updateVirtualScript(fileName, false);
          if (virtualScript) {
            return virtualScript.scriptKind;
          }
          return getScriptKind(fileName);
        };
      }
      function updateVirtualScript(fileName, shouldRegister) {
        if (crashFileNames.has(fileName)) {
          return;
        }
        let version;
        try {
          version = languageServiceHost.getScriptVersion(fileName);
        } catch {
          crashFileNames.add(fileName);
        }
        if (version === void 0) {
          return;
        }
        let script = scripts.get(fileName);
        if (!script || script[0] !== version) {
          script = [version];
          const sourceScript = language.scripts.get(fileName, void 0, shouldRegister);
          if (sourceScript?.generated) {
            const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
            if (serviceScript) {
              if (serviceScript.preventLeadingOffset) {
                script[1] = {
                  extension: serviceScript.extension,
                  scriptKind: serviceScript.scriptKind,
                  snapshot: serviceScript.code.snapshot
                };
              } else {
                const sourceContents = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength());
                const virtualContents = sourceContents.split("\n").map((line) => " ".repeat(line.length)).join("\n") + serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
                script[1] = {
                  extension: serviceScript.extension,
                  scriptKind: serviceScript.scriptKind,
                  snapshot: ts.ScriptSnapshot.fromString(virtualContents)
                };
              }
            }
            if (sourceScript.generated.languagePlugin.typescript?.getExtraServiceScripts) {
              console.warn("getExtraServiceScripts() is not available in TS plugin.");
            }
          }
          scripts.set(fileName, script);
        }
        return script[1];
      }
    }
    function searchExternalFiles(ts, project, exts) {
      if (project.projectKind !== ts.server.ProjectKind.Configured) {
        return [];
      }
      const configFile = project.getProjectName();
      const config = ts.readJsonConfigFile(configFile, project.readFile.bind(project));
      const parseHost = {
        useCaseSensitiveFileNames: project.useCaseSensitiveFileNames(),
        fileExists: project.fileExists.bind(project),
        readFile: project.readFile.bind(project),
        readDirectory: (...args) => {
          args[1] = exts;
          return project.readDirectory(...args);
        }
      };
      const parsed = ts.parseJsonSourceFileConfigFileContent(config, parseHost, project.getCurrentDirectory());
      return parsed.fileNames;
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/transform.js
var require_transform2 = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/transform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transformCallHierarchyItem = transformCallHierarchyItem;
    exports2.transformDiagnostic = transformDiagnostic;
    exports2.fillSourceFileText = fillSourceFileText;
    exports2.transformFileTextChanges = transformFileTextChanges;
    exports2.transformDocumentSpan = transformDocumentSpan;
    exports2.transformSpan = transformSpan;
    exports2.transformTextChange = transformTextChange;
    exports2.transformTextSpan = transformTextSpan;
    exports2.toSourceOffset = toSourceOffset;
    exports2.toSourceRanges = toSourceRanges;
    exports2.toSourceOffsets = toSourceOffsets;
    exports2.toGeneratedRange = toGeneratedRange;
    exports2.toGeneratedRanges = toGeneratedRanges;
    exports2.toGeneratedOffset = toGeneratedOffset;
    exports2.toGeneratedOffsets = toGeneratedOffsets;
    exports2.getMappingOffset = getMappingOffset;
    var language_core_1 = require_language_core();
    var utils_1 = require_utils2();
    var transformedDiagnostics = /* @__PURE__ */ new WeakMap();
    var transformedSourceFile = /* @__PURE__ */ new WeakSet();
    function transformCallHierarchyItem(language, item, fallbackToAnyMatch, filter) {
      const span = transformSpan(language, item.file, item.span, fallbackToAnyMatch, filter);
      const selectionSpan = transformSpan(language, item.file, item.selectionSpan, fallbackToAnyMatch, filter);
      return {
        ...item,
        file: span?.fileName ?? item.file,
        span: span?.textSpan ?? { start: 0, length: 0 },
        selectionSpan: selectionSpan?.textSpan ?? { start: 0, length: 0 }
      };
    }
    function transformDiagnostic(language, diagnostic, program, isTsc) {
      if (!transformedDiagnostics.has(diagnostic)) {
        transformedDiagnostics.set(diagnostic, void 0);
        const { relatedInformation } = diagnostic;
        if (relatedInformation) {
          diagnostic.relatedInformation = relatedInformation.map((d) => transformDiagnostic(language, d, program, isTsc)).filter((d) => !!d);
        }
        if (diagnostic.file !== void 0 && diagnostic.start !== void 0 && diagnostic.length !== void 0) {
          const [serviceScript] = (0, utils_1.getServiceScript)(language, diagnostic.file.fileName);
          if (serviceScript) {
            const [sourceSpanFileName, sourceSpan] = transformTextSpan(void 0, language, serviceScript, {
              start: diagnostic.start,
              length: diagnostic.length
            }, true, (data) => (0, language_core_1.shouldReportDiagnostics)(data, String(diagnostic.source), String(diagnostic.code))) ?? [];
            const actualDiagnosticFile = sourceSpanFileName ? diagnostic.file.fileName === sourceSpanFileName ? diagnostic.file : program?.getSourceFile(sourceSpanFileName) : void 0;
            if (sourceSpan && actualDiagnosticFile) {
              if (isTsc) {
                fillSourceFileText(language, diagnostic.file);
              }
              transformedDiagnostics.set(diagnostic, {
                ...diagnostic,
                file: actualDiagnosticFile,
                start: sourceSpan.start,
                length: sourceSpan.length
              });
            }
          } else {
            transformedDiagnostics.set(diagnostic, diagnostic);
          }
        } else {
          transformedDiagnostics.set(diagnostic, diagnostic);
        }
      }
      return transformedDiagnostics.get(diagnostic);
    }
    function fillSourceFileText(language, sourceFile) {
      if (transformedSourceFile.has(sourceFile)) {
        return;
      }
      transformedSourceFile.add(sourceFile);
      const [serviceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
      if (serviceScript && !serviceScript.preventLeadingOffset) {
        const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
        sourceFile.text = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength()) + sourceFile.text.substring(sourceScript.snapshot.getLength());
      }
    }
    function transformFileTextChanges(language, changes, fallbackToAnyMatch, filter) {
      const changesPerFile = {};
      const newFiles = /* @__PURE__ */ new Set();
      for (const fileChanges of changes) {
        const [_, source] = (0, utils_1.getServiceScript)(language, fileChanges.fileName);
        if (source) {
          fileChanges.textChanges.forEach((c) => {
            const { fileName, textSpan } = transformSpan(language, fileChanges.fileName, c.span, fallbackToAnyMatch, filter) ?? {};
            if (fileName && textSpan) {
              (changesPerFile[fileName] ?? (changesPerFile[fileName] = [])).push({ ...c, span: textSpan });
            }
          });
        } else {
          const list = changesPerFile[fileChanges.fileName] ?? (changesPerFile[fileChanges.fileName] = []);
          fileChanges.textChanges.forEach((c) => {
            list.push(c);
          });
          if (fileChanges.isNewFile) {
            newFiles.add(fileChanges.fileName);
          }
        }
      }
      const result = [];
      for (const fileName in changesPerFile) {
        result.push({
          fileName,
          isNewFile: newFiles.has(fileName),
          textChanges: changesPerFile[fileName]
        });
      }
      return result;
    }
    function transformDocumentSpan(language, documentSpan, fallbackToAnyMatch, filter, shouldFallback) {
      let textSpan = transformSpan(language, documentSpan.fileName, documentSpan.textSpan, fallbackToAnyMatch, filter);
      if (!textSpan && shouldFallback) {
        textSpan = {
          fileName: documentSpan.fileName,
          textSpan: { start: 0, length: 0 }
        };
      }
      if (!textSpan) {
        return;
      }
      const contextSpan = transformSpan(language, documentSpan.fileName, documentSpan.contextSpan, fallbackToAnyMatch, filter);
      const originalTextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalTextSpan, fallbackToAnyMatch, filter);
      const originalContextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalContextSpan, fallbackToAnyMatch, filter);
      return {
        ...documentSpan,
        fileName: textSpan.fileName,
        textSpan: textSpan.textSpan,
        contextSpan: contextSpan?.textSpan,
        originalFileName: originalTextSpan?.fileName,
        originalTextSpan: originalTextSpan?.textSpan,
        originalContextSpan: originalContextSpan?.textSpan
      };
    }
    function transformSpan(language, fileName, textSpan, fallbackToAnyMatch, filter) {
      if (!fileName || !textSpan) {
        return;
      }
      const [serviceScript] = (0, utils_1.getServiceScript)(language, fileName);
      if (serviceScript) {
        const [sourceSpanFileName, sourceSpan] = transformTextSpan(void 0, language, serviceScript, textSpan, fallbackToAnyMatch, filter) ?? [];
        if (sourceSpan && sourceSpanFileName) {
          return {
            fileName: sourceSpanFileName,
            textSpan: sourceSpan
          };
        }
      } else {
        return {
          fileName,
          textSpan
        };
      }
    }
    function transformTextChange(sourceScript, language, serviceScript, textChange, fallbackToAnyMatch, filter) {
      const [sourceSpanFileName, sourceSpan] = transformTextSpan(sourceScript, language, serviceScript, textChange.span, fallbackToAnyMatch, filter) ?? [];
      if (sourceSpan && sourceSpanFileName) {
        return [sourceSpanFileName, {
          newText: textChange.newText,
          span: sourceSpan
        }];
      }
      return void 0;
    }
    function transformTextSpan(sourceScript, language, serviceScript, textSpan, fallbackToAnyMatch, filter) {
      const start = textSpan.start;
      const end = textSpan.start + textSpan.length;
      for (const [fileName, sourceStart, sourceEnd] of toSourceRanges(sourceScript, language, serviceScript, start, end, fallbackToAnyMatch, filter)) {
        return [fileName, {
          start: sourceStart,
          length: sourceEnd - sourceStart
        }];
      }
    }
    function toSourceOffset(sourceScript, language, serviceScript, position, filter) {
      for (const source of toSourceOffsets(sourceScript, language, serviceScript, position, filter)) {
        return source;
      }
    }
    function* toSourceRanges(sourceScript, language, serviceScript, start, end, fallbackToAnyMatch, filter) {
      if (sourceScript) {
        const map = language.maps.get(serviceScript.code, sourceScript);
        for (const [sourceStart, sourceEnd] of map.toSourceRange(start - getMappingOffset(language, serviceScript), end - getMappingOffset(language, serviceScript), fallbackToAnyMatch, filter)) {
          yield [sourceScript.id, sourceStart, sourceEnd];
        }
      } else {
        for (const [sourceScript2, map] of language.maps.forEach(serviceScript.code)) {
          for (const [sourceStart, sourceEnd] of map.toSourceRange(start - getMappingOffset(language, serviceScript), end - getMappingOffset(language, serviceScript), fallbackToAnyMatch, filter)) {
            yield [sourceScript2.id, sourceStart, sourceEnd];
          }
        }
      }
    }
    function* toSourceOffsets(sourceScript, language, serviceScript, position, filter) {
      if (sourceScript) {
        const map = language.maps.get(serviceScript.code, sourceScript);
        for (const [sourceOffset, mapping] of map.toSourceLocation(position - getMappingOffset(language, serviceScript))) {
          if (filter(mapping.data)) {
            yield [sourceScript.id, sourceOffset];
          }
        }
      } else {
        for (const [sourceScript2, map] of language.maps.forEach(serviceScript.code)) {
          for (const [sourceOffset, mapping] of map.toSourceLocation(position - getMappingOffset(language, serviceScript))) {
            if (filter(mapping.data)) {
              yield [sourceScript2.id, sourceOffset];
            }
          }
        }
      }
    }
    function toGeneratedRange(language, serviceScript, sourceScript, start, end, filter) {
      for (const result of toGeneratedRanges(language, serviceScript, sourceScript, start, end, filter)) {
        return result;
      }
    }
    function* toGeneratedRanges(language, serviceScript, sourceScript, start, end, filter) {
      const map = language.maps.get(serviceScript.code, sourceScript);
      for (const [generateStart, generateEnd] of map.toGeneratedRange(start, end, true, filter)) {
        yield [
          generateStart + getMappingOffset(language, serviceScript),
          generateEnd + getMappingOffset(language, serviceScript)
        ];
      }
    }
    function toGeneratedOffset(language, serviceScript, sourceScript, position, filter) {
      for (const [generateOffset] of toGeneratedOffsets(language, serviceScript, sourceScript, position, filter)) {
        return generateOffset;
      }
    }
    function* toGeneratedOffsets(language, serviceScript, sourceScript, position, filter) {
      const map = language.maps.get(serviceScript.code, sourceScript);
      for (const [generateOffset, mapping] of map.toGeneratedLocation(position)) {
        if (filter(mapping.data)) {
          yield [generateOffset + getMappingOffset(language, serviceScript), mapping];
        }
      }
    }
    function getMappingOffset(language, serviceScript) {
      if (serviceScript.preventLeadingOffset) {
        return 0;
      }
      const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
      return sourceScript.snapshot.getLength();
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/decorateProgram.js
var require_decorateProgram = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/decorateProgram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decorateProgram = decorateProgram;
    var transform_1 = require_transform2();
    var utils_1 = require_utils2();
    function decorateProgram(language, program) {
      const emit = program.emit;
      const getSyntacticDiagnostics = program.getSyntacticDiagnostics;
      const getSemanticDiagnostics = program.getSemanticDiagnostics;
      const getGlobalDiagnostics = program.getGlobalDiagnostics;
      const getSourceFileByPath = program.getSourceFileByPath;
      const getBindAndCheckDiagnostics = program.getBindAndCheckDiagnostics;
      program.emit = (...args) => {
        const result = emit(...args);
        return {
          ...result,
          diagnostics: result.diagnostics.map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d)
        };
      };
      program.getSyntacticDiagnostics = (sourceFile, cancellationToken) => {
        if (!sourceFile) {
          return getSyntacticDiagnostics(void 0, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d);
        } else {
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
          const actualSourceFile = targetScript ? program.getSourceFile(targetScript.id) : sourceFile;
          return getSyntacticDiagnostics(actualSourceFile, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
        }
      };
      program.getSemanticDiagnostics = (sourceFile, cancellationToken) => {
        if (!sourceFile) {
          return getSemanticDiagnostics(void 0, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d);
        } else {
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
          const actualSourceFile = targetScript ? program.getSourceFile(targetScript.id) : sourceFile;
          return getSemanticDiagnostics(actualSourceFile, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
        }
      };
      program.getGlobalDiagnostics = (cancellationToken) => {
        return getGlobalDiagnostics(cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d);
      };
      program.getBindAndCheckDiagnostics = (sourceFile, cancellationToken) => {
        if (!sourceFile) {
          return getBindAndCheckDiagnostics(void 0, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d);
        } else {
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
          const actualSourceFile = targetScript ? program.getSourceFile(targetScript.id) : sourceFile;
          return getBindAndCheckDiagnostics(actualSourceFile, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d).filter((d) => !serviceScript || language.scripts.get(d.file.fileName) === sourceScript);
        }
      };
      program.getSourceFileByPath = (path3) => {
        const sourceFile = getSourceFileByPath(path3);
        if (sourceFile) {
          (0, transform_1.fillSourceFileText)(language, sourceFile);
        }
        return sourceFile;
      };
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/proxyCreateProgram.js
var require_proxyCreateProgram = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/proxyCreateProgram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.proxyCreateProgram = proxyCreateProgram;
    var language_core_1 = require_language_core();
    var common_1 = require_common2();
    var resolveModuleName_1 = require_resolveModuleName();
    var decorateProgram_1 = require_decorateProgram();
    var utils_1 = require_utils2();
    var arrayEqual = (a, b) => {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    };
    var objectEqual = (a, b) => {
      const keysA = Object.keys(a);
      const keysB = Object.keys(b);
      if (keysA.length !== keysB.length) {
        return false;
      }
      for (const key of keysA) {
        if (a[key] !== b[key]) {
          return false;
        }
      }
      return true;
    };
    function proxyCreateProgram(ts, original, create) {
      const sourceFileSnapshots = new language_core_1.FileMap(ts.sys.useCaseSensitiveFileNames);
      const parsedSourceFiles = /* @__PURE__ */ new WeakMap();
      let lastOptions;
      let languagePlugins;
      let language;
      let moduleResolutionCache;
      return new Proxy(original, {
        apply: (target, thisArg, args) => {
          const options = args[0];
          assert(!!options.host, "!!options.host");
          if (!lastOptions || !languagePlugins || !language || !arrayEqual(options.rootNames, lastOptions.rootNames) || !objectEqual(options.options, lastOptions.options)) {
            moduleResolutionCache = ts.createModuleResolutionCache(options.host.getCurrentDirectory(), options.host.getCanonicalFileName, options.options);
            lastOptions = options;
            const created = create(ts, options);
            if (Array.isArray(created)) {
              languagePlugins = created;
            } else {
              languagePlugins = created.languagePlugins;
            }
            language = (0, language_core_1.createLanguage)([
              ...languagePlugins,
              { getLanguageId: common_1.resolveFileLanguageId }
            ], new language_core_1.FileMap(ts.sys.useCaseSensitiveFileNames), (fileName, includeFsFiles) => {
              if (includeFsFiles && !sourceFileSnapshots.has(fileName)) {
                const sourceFileText = originalHost.readFile(fileName);
                if (sourceFileText !== void 0) {
                  sourceFileSnapshots.set(fileName, [void 0, {
                    getChangeRange() {
                      return void 0;
                    },
                    getLength() {
                      return sourceFileText.length;
                    },
                    getText(start, end) {
                      return sourceFileText.substring(start, end);
                    }
                  }]);
                } else {
                  sourceFileSnapshots.set(fileName, [void 0, void 0]);
                }
              }
              const snapshot = sourceFileSnapshots.get(fileName)?.[1];
              if (snapshot) {
                language.scripts.set(fileName, snapshot);
              } else {
                language.scripts.delete(fileName);
              }
            });
            if ("setup" in created) {
              created.setup?.(language);
            }
          }
          const originalHost = options.host;
          const pluginExtensions = languagePlugins.map((plugin) => plugin.typescript?.extraFileExtensions.map(({ extension }) => `.${extension}`) ?? []).flat();
          options.host = { ...originalHost };
          options.host.getSourceFile = (fileName, languageVersionOrOptions, onError, shouldCreateNewSourceFile) => {
            const originalSourceFile = originalHost.getSourceFile(fileName, languageVersionOrOptions, onError, shouldCreateNewSourceFile);
            if (!sourceFileSnapshots.has(fileName) || sourceFileSnapshots.get(fileName)?.[0] !== originalSourceFile) {
              if (originalSourceFile) {
                sourceFileSnapshots.set(fileName, [originalSourceFile, {
                  getChangeRange() {
                    return void 0;
                  },
                  getLength() {
                    return originalSourceFile.text.length;
                  },
                  getText(start, end) {
                    return originalSourceFile.text.substring(start, end);
                  }
                }]);
              } else {
                sourceFileSnapshots.set(fileName, [void 0, void 0]);
              }
            }
            if (!originalSourceFile) {
              return;
            }
            if (!parsedSourceFiles.has(originalSourceFile)) {
              const sourceScript = language.scripts.get(fileName);
              assert(!!sourceScript, "!!sourceScript");
              parsedSourceFiles.set(originalSourceFile, void 0);
              if (sourceScript.generated?.languagePlugin.typescript) {
                const { getServiceScript, getExtraServiceScripts } = sourceScript.generated.languagePlugin.typescript;
                const serviceScript = getServiceScript(sourceScript.generated.root);
                if (serviceScript) {
                  let virtualContents;
                  if (!serviceScript.preventLeadingOffset) {
                    virtualContents = originalSourceFile.text.split("\n").map((line) => " ".repeat(line.length)).join("\n") + serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
                  } else {
                    virtualContents = serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
                  }
                  const parsedSourceFile = ts.createSourceFile(fileName, virtualContents, languageVersionOrOptions, void 0, serviceScript.scriptKind);
                  parsedSourceFile.version = originalSourceFile.version;
                  parsedSourceFiles.set(originalSourceFile, parsedSourceFile);
                }
                if (getExtraServiceScripts) {
                  console.warn("getExtraServiceScripts() is not available in this use case.");
                }
              }
            }
            return parsedSourceFiles.get(originalSourceFile) ?? originalSourceFile;
          };
          if (pluginExtensions.length) {
            options.options.allowArbitraryExtensions = true;
            const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts, ts.sys.getFileSize, originalHost, language.plugins, (fileName) => language.scripts.get(fileName));
            const resolveModuleNameLiterals = originalHost.resolveModuleNameLiterals;
            const resolveModuleNames = originalHost.resolveModuleNames;
            options.host.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, compilerOptions, containingSourceFile, ...rest) => {
              const disposeFixup = (0, utils_1.fixupImpliedNodeFormatForFile)(ts, pluginExtensions, containingSourceFile, moduleResolutionCache.getPackageJsonInfoCache(), originalHost, compilerOptions);
              try {
                if (resolveModuleNameLiterals && moduleLiterals.every((name) => !pluginExtensions.some((ext) => name.text.endsWith(ext)))) {
                  return resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, compilerOptions, containingSourceFile, ...rest);
                }
                return moduleLiterals.map((moduleLiteral) => {
                  const mode = ts.getModeForUsageLocation(containingSourceFile, moduleLiteral, compilerOptions);
                  return resolveModuleName(moduleLiteral.text, containingFile, compilerOptions, moduleResolutionCache, redirectedReference, mode);
                });
              } finally {
                disposeFixup?.();
              }
            };
            options.host.resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, compilerOptions, containingSourceFile) => {
              if (resolveModuleNames && moduleNames.every((name) => !pluginExtensions.some((ext) => name.endsWith(ext)))) {
                return resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, compilerOptions, containingSourceFile);
              }
              return moduleNames.map((moduleName) => {
                return resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionCache, redirectedReference, containingSourceFile?.impliedNodeFormat).resolvedModule;
              });
            };
          }
          const program = Reflect.apply(target, thisArg, args);
          (0, decorateProgram_1.decorateProgram)(language, program);
          return program;
        }
      });
    }
    function assert(condition, message) {
      if (!condition) {
        console.error(message);
        throw new Error(message);
      }
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/dedupe.js
var require_dedupe2 = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/dedupe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dedupeDocumentSpans = dedupeDocumentSpans;
    function dedupeDocumentSpans(items) {
      return dedupe(items, (item) => [
        item.fileName,
        item.textSpan.start,
        item.textSpan.length
      ].join(":"));
    }
    function dedupe(items, getKey) {
      const map = /* @__PURE__ */ new Map();
      for (const item of items.reverse()) {
        map.set(getKey(item), item);
      }
      return [...map.values()];
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/proxyLanguageService.js
var require_proxyLanguageService = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/node/proxyLanguageService.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProxyLanguageService = createProxyLanguageService;
    var language_core_1 = require_language_core();
    var dedupe_1 = require_dedupe2();
    var transform_1 = require_transform2();
    var utils_1 = require_utils2();
    var windowsPathReg = /\\/g;
    function createProxyLanguageService(languageService) {
      const proxyCache = /* @__PURE__ */ new Map();
      let getProxyMethod;
      return {
        initialize(language) {
          getProxyMethod = (target, p) => {
            switch (p) {
              case "getNavigationTree":
                return getNavigationTree(language, target[p]);
              case "getOutliningSpans":
                return getOutliningSpans(language, target[p]);
              case "getFormattingEditsForDocument":
                return getFormattingEditsForDocument(language, target[p]);
              case "getFormattingEditsForRange":
                return getFormattingEditsForRange(language, target[p]);
              case "getFormattingEditsAfterKeystroke":
                return getFormattingEditsAfterKeystroke(language, target[p]);
              case "getEditsForFileRename":
                return getEditsForFileRename(language, target[p]);
              case "getLinkedEditingRangeAtPosition":
                return getLinkedEditingRangeAtPosition(language, target[p]);
              case "prepareCallHierarchy":
                return prepareCallHierarchy(language, target[p]);
              case "provideCallHierarchyIncomingCalls":
                return provideCallHierarchyIncomingCalls(language, target[p]);
              case "provideCallHierarchyOutgoingCalls":
                return provideCallHierarchyOutgoingCalls(language, target[p]);
              case "organizeImports":
                return organizeImports(language, target[p]);
              case "getQuickInfoAtPosition":
                return getQuickInfoAtPosition(language, target[p]);
              case "getSignatureHelpItems":
                return getSignatureHelpItems(language, target[p]);
              case "getDocumentHighlights":
                return getDocumentHighlights(language, target[p]);
              case "getApplicableRefactors":
                return getApplicableRefactors(language, target[p]);
              case "getEditsForRefactor":
                return getEditsForRefactor(language, target[p]);
              case "getCombinedCodeFix":
                return getCombinedCodeFix(language, target[p]);
              case "getRenameInfo":
                return getRenameInfo(language, target[p]);
              case "getCodeFixesAtPosition":
                return getCodeFixesAtPosition(language, target[p]);
              case "getEncodedSemanticClassifications":
                return getEncodedSemanticClassifications(language, target[p]);
              case "getSyntacticDiagnostics":
                return getSyntacticDiagnostics(language, languageService, target[p]);
              case "getSemanticDiagnostics":
                return getSemanticDiagnostics(language, languageService, target[p]);
              case "getSuggestionDiagnostics":
                return getSuggestionDiagnostics(language, languageService, target[p]);
              case "getDefinitionAndBoundSpan":
                return getDefinitionAndBoundSpan(language, target[p]);
              case "findReferences":
                return findReferences(language, target[p]);
              case "getDefinitionAtPosition":
                return getDefinitionAtPosition(language, target[p]);
              case "getTypeDefinitionAtPosition":
                return getTypeDefinitionAtPosition(language, target[p]);
              case "getImplementationAtPosition":
                return getImplementationAtPosition(language, target[p]);
              case "findRenameLocations":
                return findRenameLocations(language, target[p]);
              case "getReferencesAtPosition":
                return getReferencesAtPosition(language, target[p]);
              case "getCompletionsAtPosition":
                return getCompletionsAtPosition(language, target[p]);
              case "getCompletionEntryDetails":
                return getCompletionEntryDetails(language, target[p]);
              case "provideInlayHints":
                return provideInlayHints(language, target[p]);
              case "getFileReferences":
                return getFileReferences(language, target[p]);
              case "getNavigateToItems":
                return getNavigateToItems(language, target[p]);
            }
          };
        },
        proxy: new Proxy(languageService, {
          get(target, p, receiver) {
            if (getProxyMethod) {
              if (!proxyCache.has(p)) {
                proxyCache.set(p, getProxyMethod(target, p));
              }
              const proxyMethod = proxyCache.get(p);
              if (proxyMethod) {
                return proxyMethod;
              }
            }
            return Reflect.get(target, p, receiver);
          },
          set(target, p, value, receiver) {
            return Reflect.set(target, p, value, receiver);
          }
        })
      };
    }
    function getNavigationTree(language, getNavigationTree2) {
      return (filePath) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (serviceScript || targetScript?.associatedOnly) {
          const tree = getNavigationTree2(targetScript.id);
          tree.childItems = void 0;
          return tree;
        } else {
          return getNavigationTree2(fileName);
        }
      };
    }
    function getOutliningSpans(language, getOutliningSpans2) {
      return (filePath) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (serviceScript || targetScript?.associatedOnly) {
          return [];
        } else {
          return getOutliningSpans2(fileName);
        }
      };
    }
    function getFormattingEditsForDocument(language, getFormattingEditsForDocument2) {
      return (filePath, options) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const map = language.maps.get(serviceScript.code, targetScript);
          if (!map.mappings.some((mapping) => (0, language_core_1.isFormattingEnabled)(mapping.data))) {
            return [];
          }
          const edits = getFormattingEditsForDocument2(targetScript.id, options);
          return edits.map((edit) => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, false, language_core_1.isFormattingEnabled)?.[1]).filter((edit) => !!edit);
        } else {
          return getFormattingEditsForDocument2(fileName, options);
        }
      };
    }
    function getFormattingEditsForRange(language, getFormattingEditsForRange2) {
      return (filePath, start, end, options) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generatedRange = (0, transform_1.toGeneratedRange)(language, serviceScript, sourceScript, start, end, language_core_1.isFormattingEnabled);
          if (generatedRange !== void 0) {
            const edits = getFormattingEditsForRange2(targetScript.id, generatedRange[0], generatedRange[1], options);
            return edits.map((edit) => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, false, language_core_1.isFormattingEnabled)?.[1]).filter((edit) => !!edit);
          }
          return [];
        } else {
          return getFormattingEditsForRange2(fileName, start, end, options);
        }
      };
    }
    function getFormattingEditsAfterKeystroke(language, getFormattingEditsAfterKeystroke2) {
      return (filePath, position, key, options) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isFormattingEnabled);
          if (generatePosition !== void 0) {
            const edits = getFormattingEditsAfterKeystroke2(targetScript.id, generatePosition, key, options);
            return edits.map((edit) => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, false, language_core_1.isFormattingEnabled)?.[1]).filter((edit) => !!edit);
          }
          return [];
        } else {
          return getFormattingEditsAfterKeystroke2(fileName, position, key, options);
        }
      };
    }
    function getEditsForFileRename(language, getEditsForFileRename2) {
      return (oldFilePath, newFilePath, formatOptions, preferences) => {
        const edits = getEditsForFileRename2(oldFilePath, newFilePath, formatOptions, preferences);
        return (0, transform_1.transformFileTextChanges)(language, edits, false, language_core_1.isRenameEnabled);
      };
    }
    function getLinkedEditingRangeAtPosition(language, getLinkedEditingRangeAtPosition2) {
      return (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isLinkedEditingEnabled);
          if (generatePosition !== void 0) {
            const info = getLinkedEditingRangeAtPosition2(targetScript.id, generatePosition);
            if (info) {
              return {
                ranges: info.ranges.map((span) => (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, false, language_core_1.isLinkedEditingEnabled)?.[1]).filter((span) => !!span),
                wordPattern: info.wordPattern
              };
            }
          }
        } else {
          return getLinkedEditingRangeAtPosition2(fileName, position);
        }
      };
    }
    function prepareCallHierarchy(language, prepareCallHierarchy2) {
      return (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCallHierarchyEnabled);
          if (generatePosition !== void 0) {
            const item = prepareCallHierarchy2(targetScript.id, generatePosition);
            if (Array.isArray(item)) {
              return item.map((item2) => (0, transform_1.transformCallHierarchyItem)(language, item2, true, language_core_1.isCallHierarchyEnabled));
            } else if (item) {
              return (0, transform_1.transformCallHierarchyItem)(language, item, true, language_core_1.isCallHierarchyEnabled);
            }
          }
        } else {
          return prepareCallHierarchy2(fileName, position);
        }
      };
    }
    function provideCallHierarchyIncomingCalls(language, provideCallHierarchyIncomingCalls2) {
      return (filePath, position) => {
        let calls = [];
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCallHierarchyEnabled);
          if (generatePosition !== void 0) {
            calls = provideCallHierarchyIncomingCalls2(targetScript.id, generatePosition);
          }
        } else {
          calls = provideCallHierarchyIncomingCalls2(fileName, position);
        }
        return calls.map((call) => {
          const from = (0, transform_1.transformCallHierarchyItem)(language, call.from, true, language_core_1.isCallHierarchyEnabled);
          const fromSpans = call.fromSpans.map((span) => (0, transform_1.transformSpan)(language, call.from.file, span, true, language_core_1.isCallHierarchyEnabled)?.textSpan).filter((span) => !!span);
          return {
            from,
            fromSpans
          };
        });
      };
    }
    function provideCallHierarchyOutgoingCalls(language, provideCallHierarchyOutgoingCalls2) {
      return (filePath, position) => {
        let calls = [];
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCallHierarchyEnabled);
          if (generatePosition !== void 0) {
            calls = provideCallHierarchyOutgoingCalls2(targetScript.id, generatePosition);
          }
        } else {
          calls = provideCallHierarchyOutgoingCalls2(fileName, position);
        }
        return calls.map((call) => {
          const to = (0, transform_1.transformCallHierarchyItem)(language, call.to, true, language_core_1.isCallHierarchyEnabled);
          const fromSpans = call.fromSpans.map((span) => serviceScript ? (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, true, language_core_1.isCallHierarchyEnabled)?.[1] : span).filter((span) => !!span);
          return {
            to,
            fromSpans
          };
        });
      };
    }
    function organizeImports(language, organizeImports2) {
      return (args, formatOptions, preferences) => {
        const unresolved = organizeImports2(args, formatOptions, preferences);
        return (0, transform_1.transformFileTextChanges)(language, unresolved, false, language_core_1.isCodeActionsEnabled);
      };
    }
    function getQuickInfoAtPosition(language, getQuickInfoAtPosition2) {
      return (filePath, position, ...args) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const infos = [];
          for (const [generatePosition] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1.isHoverEnabled)) {
            const info = getQuickInfoAtPosition2(targetScript.id, generatePosition, ...args);
            if (info) {
              const textSpan = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.textSpan, true, language_core_1.isHoverEnabled)?.[1];
              if (textSpan) {
                infos.push({
                  ...info,
                  textSpan
                });
              }
            }
          }
          if (infos.length === 1) {
            return infos[0];
          } else if (infos.length >= 2) {
            const combine = { ...infos[0] };
            combine.displayParts = combine.displayParts?.slice();
            combine.documentation = combine.documentation?.slice();
            combine.tags = combine.tags?.slice();
            const displayPartsStrs = /* @__PURE__ */ new Set([displayPartsToString(infos[0].displayParts)]);
            const documentationStrs = /* @__PURE__ */ new Set([displayPartsToString(infos[0].documentation)]);
            const tagsStrs = /* @__PURE__ */ new Set();
            for (const tag of infos[0].tags ?? []) {
              tagsStrs.add(tag.name + "__volar__" + displayPartsToString(tag.text));
            }
            for (let i = 1; i < infos.length; i++) {
              const { displayParts, documentation, tags } = infos[i];
              if (displayParts?.length && !displayPartsStrs.has(displayPartsToString(displayParts))) {
                displayPartsStrs.add(displayPartsToString(displayParts));
                combine.displayParts ??= [];
                combine.displayParts.push({ ...displayParts[0], text: "\n\n" + displayParts[0].text });
                combine.displayParts.push(...displayParts.slice(1));
              }
              if (documentation?.length && !documentationStrs.has(displayPartsToString(documentation))) {
                documentationStrs.add(displayPartsToString(documentation));
                combine.documentation ??= [];
                combine.documentation.push({ ...documentation[0], text: "\n\n" + documentation[0].text });
                combine.documentation.push(...documentation.slice(1));
              }
              for (const tag of tags ?? []) {
                if (!tagsStrs.has(tag.name + "__volar__" + displayPartsToString(tag.text))) {
                  tagsStrs.add(tag.name + "__volar__" + displayPartsToString(tag.text));
                  combine.tags ??= [];
                  combine.tags.push(tag);
                }
              }
            }
            return combine;
          }
        } else {
          return getQuickInfoAtPosition2(fileName, position, ...args);
        }
      };
    }
    function getSignatureHelpItems(language, getSignatureHelpItems2) {
      return (filePath, position, options) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isSignatureHelpEnabled);
          if (generatePosition !== void 0) {
            const result = getSignatureHelpItems2(targetScript.id, generatePosition, options);
            if (result) {
              const applicableSpan = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.applicableSpan, true, language_core_1.isSignatureHelpEnabled)?.[1];
              if (applicableSpan) {
                return {
                  ...result,
                  applicableSpan
                };
              }
            }
          }
        } else {
          return getSignatureHelpItems2(fileName, position, options);
        }
      };
    }
    function getDocumentHighlights(language, getDocumentHighlights2) {
      return (filePath, position, filesToSearch) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isHighlightEnabled, (fileName2, position2) => getDocumentHighlights2(fileName2, position2, filesToSearch), function* (result) {
          for (const ref of result) {
            for (const reference of ref.highlightSpans) {
              yield [reference.fileName ?? ref.fileName, reference.textSpan.start];
            }
          }
        });
        const resolved = unresolved.flat().map((highlights) => {
          return {
            ...highlights,
            highlightSpans: highlights.highlightSpans.map((span) => {
              const { textSpan } = (0, transform_1.transformSpan)(language, span.fileName ?? highlights.fileName, span.textSpan, false, language_core_1.isHighlightEnabled) ?? {};
              if (textSpan) {
                return {
                  ...span,
                  contextSpan: (0, transform_1.transformSpan)(language, span.fileName ?? highlights.fileName, span.contextSpan, false, language_core_1.isHighlightEnabled)?.textSpan,
                  textSpan
                };
              }
            }).filter((span) => !!span)
          };
        });
        return resolved;
      };
    }
    function getApplicableRefactors(language, getApplicableRefactors2) {
      return (filePath, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          if (typeof positionOrRange === "number") {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled);
            if (generatePosition !== void 0) {
              return getApplicableRefactors2(targetScript.id, generatePosition, preferences, triggerReason, kind, includeInteractiveActions);
            }
          } else {
            for (const [generatedStart, generatedEnd] of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange.pos, positionOrRange.end, language_core_1.isCodeActionsEnabled)) {
              return getApplicableRefactors2(targetScript.id, { pos: generatedStart, end: generatedEnd }, preferences, triggerReason, kind, includeInteractiveActions);
            }
          }
          return [];
        } else {
          return getApplicableRefactors2(fileName, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions);
        }
      };
    }
    function getEditsForRefactor(language, getEditsForRefactor2) {
      return (filePath, formatOptions, positionOrRange, refactorName, actionName, preferences, interactiveRefactorArguments) => {
        let edits;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          if (typeof positionOrRange === "number") {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled);
            if (generatePosition !== void 0) {
              edits = getEditsForRefactor2(targetScript.id, formatOptions, generatePosition, refactorName, actionName, preferences, interactiveRefactorArguments);
            }
          } else {
            for (const [generatedStart, generatedEnd] of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange.pos, positionOrRange.end, language_core_1.isCodeActionsEnabled)) {
              edits = getEditsForRefactor2(targetScript.id, formatOptions, { pos: generatedStart, end: generatedEnd }, refactorName, actionName, preferences, interactiveRefactorArguments);
            }
          }
        } else {
          edits = getEditsForRefactor2(fileName, formatOptions, positionOrRange, refactorName, actionName, preferences, interactiveRefactorArguments);
        }
        if (edits) {
          edits.edits = (0, transform_1.transformFileTextChanges)(language, edits.edits, false, language_core_1.isCodeActionsEnabled);
          return edits;
        }
      };
    }
    function getCombinedCodeFix(language, getCombinedCodeFix2) {
      return (...args) => {
        const codeActions = getCombinedCodeFix2(...args);
        codeActions.changes = (0, transform_1.transformFileTextChanges)(language, codeActions.changes, false, language_core_1.isCodeActionsEnabled);
        return codeActions;
      };
    }
    function getRenameInfo(language, getRenameInfo2) {
      return (filePath, position, options) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return {
            canRename: false,
            localizedErrorMessage: "Cannot rename"
          };
        }
        if (serviceScript) {
          let failed;
          for (const [generateOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1.isRenameEnabled)) {
            const info = getRenameInfo2(targetScript.id, generateOffset, options);
            if (info.canRename) {
              const span = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.triggerSpan, false, language_core_1.isRenameEnabled)?.[1];
              if (span) {
                info.triggerSpan = span;
                return info;
              }
            } else {
              failed = info;
            }
          }
          if (failed) {
            return failed;
          }
          return {
            canRename: false,
            localizedErrorMessage: "Failed to get rename locations"
          };
        } else {
          return getRenameInfo2(fileName, position, options);
        }
      };
    }
    function getCodeFixesAtPosition(language, getCodeFixesAtPosition2) {
      return (filePath, start, end, errorCodes, formatOptions, preferences) => {
        let fixes = [];
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generateRange = (0, transform_1.toGeneratedRange)(language, serviceScript, sourceScript, start, end, language_core_1.isCodeActionsEnabled);
          if (generateRange !== void 0) {
            fixes = getCodeFixesAtPosition2(targetScript.id, generateRange[0], generateRange[1], errorCodes, formatOptions, preferences);
          }
        } else {
          fixes = getCodeFixesAtPosition2(fileName, start, end, errorCodes, formatOptions, preferences);
        }
        fixes = fixes.map((fix) => {
          fix.changes = (0, transform_1.transformFileTextChanges)(language, fix.changes, false, language_core_1.isCodeActionsEnabled);
          return fix;
        });
        return fixes;
      };
    }
    function getEncodedSemanticClassifications(language, getEncodedSemanticClassifications2) {
      return (filePath, span, format) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return {
            spans: [],
            endOfLineState: 0
          };
        }
        if (serviceScript) {
          const map = language.maps.get(serviceScript.code, targetScript);
          const mapped = (0, language_core_1.findOverlapCodeRange)(span.start, span.start + span.length, map, language_core_1.isSemanticTokensEnabled);
          if (!mapped) {
            return {
              spans: [],
              endOfLineState: 0
            };
          }
          const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
          const start = mapped.start + mappingOffset;
          const end = mapped.end + mappingOffset;
          const result = getEncodedSemanticClassifications2(targetScript.id, { start, length: end - start }, format);
          const spans = [];
          for (let i = 0; i < result.spans.length; i += 3) {
            for (const [_, sourceStart, sourceEnd] of (0, transform_1.toSourceRanges)(sourceScript, language, serviceScript, result.spans[i], result.spans[i] + result.spans[i + 1], false, language_core_1.isSemanticTokensEnabled)) {
              spans.push(sourceStart, sourceEnd - sourceStart, result.spans[i + 2]);
              break;
            }
          }
          result.spans = spans;
          return result;
        } else {
          return getEncodedSemanticClassifications2(fileName, span, format);
        }
      };
    }
    function getSyntacticDiagnostics(language, languageService, getSyntacticDiagnostics2) {
      return (filePath) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        return getSyntacticDiagnostics2(targetScript?.id ?? fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter((d) => !!d).filter((d) => !serviceScript || language.scripts.get(d.file.fileName) === sourceScript);
      };
    }
    function getSemanticDiagnostics(language, languageService, getSemanticDiagnostics2) {
      return (filePath) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        return getSemanticDiagnostics2(targetScript?.id ?? fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
      };
    }
    function getSuggestionDiagnostics(language, languageService, getSuggestionDiagnostics2) {
      return (filePath) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        return getSuggestionDiagnostics2(targetScript?.id ?? fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
      };
    }
    function getDefinitionAndBoundSpan(language, getDefinitionAndBoundSpan2) {
      return (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isDefinitionEnabled, (fileName2, position2) => getDefinitionAndBoundSpan2(fileName2, position2), function* (result) {
          for (const ref of result.definitions ?? []) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const textSpan = unresolved.map((s) => (0, transform_1.transformSpan)(language, fileName, s.textSpan, true, language_core_1.isDefinitionEnabled)?.textSpan).filter((s) => !!s)[0];
        if (!textSpan) {
          return;
        }
        const definitions = unresolved.map((s) => s.definitions?.map((s2) => (0, transform_1.transformDocumentSpan)(language, s2, true, language_core_1.isDefinitionEnabled, s2.fileName !== fileName)).filter((s2) => !!s2) ?? []).flat();
        return {
          textSpan,
          definitions: (0, dedupe_1.dedupeDocumentSpans)(definitions)
        };
      };
    }
    function findReferences(language, findReferences2) {
      return (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isReferencesEnabled, (fileName2, position2) => findReferences2(fileName2, position2), function* (result) {
          for (const ref of result) {
            for (const reference of ref.references) {
              yield [reference.fileName, reference.textSpan.start];
            }
          }
        });
        const resolved = unresolved.flat().map((symbol) => {
          const definition = (0, transform_1.transformDocumentSpan)(language, symbol.definition, true, language_core_1.isDefinitionEnabled, true);
          return {
            definition,
            references: symbol.references.map((r) => (0, transform_1.transformDocumentSpan)(language, r, true, language_core_1.isReferencesEnabled)).filter((r) => !!r)
          };
        });
        return resolved;
      };
    }
    function getDefinitionAtPosition(language, getDefinitionAtPosition2) {
      return (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isDefinitionEnabled, (fileName2, position2) => getDefinitionAtPosition2(fileName2, position2), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isDefinitionEnabled, s.fileName !== fileName)).filter((s) => !!s);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
    }
    function getTypeDefinitionAtPosition(language, getTypeDefinitionAtPosition2) {
      return (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isTypeDefinitionEnabled, (fileName2, position2) => getTypeDefinitionAtPosition2(fileName2, position2), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isTypeDefinitionEnabled)).filter((s) => !!s);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
    }
    function getImplementationAtPosition(language, getImplementationAtPosition2) {
      return (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isImplementationEnabled, (fileName2, position2) => getImplementationAtPosition2(fileName2, position2), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isImplementationEnabled)).filter((s) => !!s);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
    }
    function findRenameLocations(language, findRenameLocations2) {
      return (filePath, position, findInStrings, findInComments, preferences) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isRenameEnabled, (fileName2, position2) => findRenameLocations2(fileName2, position2, findInStrings, findInComments, preferences), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, false, language_core_1.isRenameEnabled)).filter((s) => !!s);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
    }
    function getReferencesAtPosition(language, getReferencesAtPosition2) {
      return (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isReferencesEnabled, (fileName2, position2) => getReferencesAtPosition2(fileName2, position2), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isReferencesEnabled)).filter((s) => !!s);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
    }
    function getCompletionsAtPosition(language, getCompletionsAtPosition2) {
      return (filePath, position, options, formattingSettings) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          let mainResult;
          const additionalResults = [];
          for (const [generatedOffset, mapping] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1.isCompletionEnabled)) {
            const isAdditional = typeof mapping.data.completion === "object" && mapping.data.completion.isAdditional;
            if (!isAdditional && mainResult?.entries.length) {
              continue;
            }
            const result = getCompletionsAtPosition2(targetScript.id, generatedOffset, options, formattingSettings);
            if (!result) {
              continue;
            }
            if (typeof mapping.data.completion === "object" && mapping.data.completion.onlyImport) {
              result.entries = result.entries.filter((entry) => !!entry.sourceDisplay);
            }
            for (const entry of result.entries) {
              entry.replacementSpan = entry.replacementSpan && (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, entry.replacementSpan, false, language_core_1.isCompletionEnabled)?.[1];
            }
            result.optionalReplacementSpan = result.optionalReplacementSpan && (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.optionalReplacementSpan, false, language_core_1.isCompletionEnabled)?.[1];
            if (isAdditional) {
              additionalResults.push(result);
            } else {
              mainResult = result;
            }
          }
          const results = additionalResults;
          if (mainResult) {
            results.unshift(mainResult);
          }
          if (results.length) {
            return {
              ...results[0],
              entries: results.map((additionalResult) => additionalResult.entries).flat()
            };
          }
        } else {
          return getCompletionsAtPosition2(fileName, position, options, formattingSettings);
        }
      };
    }
    function getCompletionEntryDetails(language, getCompletionEntryDetails2) {
      return (filePath, position, entryName, formatOptions, source, preferences, data) => {
        let details;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCompletionEnabled);
          if (generatePosition !== void 0) {
            details = getCompletionEntryDetails2(targetScript.id, generatePosition, entryName, formatOptions, source, preferences, data);
          }
        } else {
          return getCompletionEntryDetails2(fileName, position, entryName, formatOptions, source, preferences, data);
        }
        if (details?.codeActions) {
          for (const codeAction of details.codeActions) {
            codeAction.changes = (0, transform_1.transformFileTextChanges)(language, codeAction.changes, false, language_core_1.isCompletionEnabled);
          }
        }
        return details;
      };
    }
    function provideInlayHints(language, provideInlayHints2) {
      return (filePath, span, preferences) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript?.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const map = language.maps.get(serviceScript.code, sourceScript);
          const mapped = (0, language_core_1.findOverlapCodeRange)(span.start, span.start + span.length, map, language_core_1.isSemanticTokensEnabled);
          if (!mapped) {
            return [];
          }
          const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
          const start = mapped.start + mappingOffset;
          const end = mapped.end + mappingOffset;
          const result = provideInlayHints2(targetScript.id, { start, length: end - start }, preferences);
          const hints = [];
          for (const hint of result) {
            const sourcePosition = (0, transform_1.toSourceOffset)(sourceScript, language, serviceScript, hint.position, language_core_1.isInlayHintsEnabled);
            if (sourcePosition !== void 0) {
              hints.push({
                ...hint,
                position: sourcePosition[1]
              });
            }
          }
          return hints;
        } else {
          return provideInlayHints2(fileName, span, preferences);
        }
      };
    }
    function getFileReferences(language, getFileReferences2) {
      return (filePath) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = getFileReferences2(fileName);
        const resolved = unresolved.map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isReferencesEnabled)).filter((s) => !!s);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
    }
    function getNavigateToItems(language, getNavigateToItems2) {
      return (...args) => {
        const unresolved = getNavigateToItems2(...args);
        const resolved = unresolved.map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isReferencesEnabled)).filter((s) => !!s);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
    }
    function linkedCodeFeatureWorker(language, fileName, position, filter, worker, getLinkedCodes) {
      const results = [];
      const processedFilePositions = /* @__PURE__ */ new Set();
      const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
      if (serviceScript) {
        for (const [generatedOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, filter)) {
          process2(targetScript.id, generatedOffset);
        }
      } else {
        process2(fileName, position);
      }
      return results;
      function process2(fileName2, position2) {
        if (processedFilePositions.has(fileName2 + ":" + position2)) {
          return;
        }
        processedFilePositions.add(fileName2 + ":" + position2);
        const result = worker(fileName2, position2);
        if (!result) {
          return;
        }
        results.push(result);
        for (const ref of getLinkedCodes(result)) {
          processedFilePositions.add(ref[0] + ":" + ref[1]);
          const [serviceScript2] = (0, utils_1.getServiceScript)(language, ref[0]);
          if (!serviceScript2) {
            continue;
          }
          const linkedCodeMap = language.linkedCodeMaps.get(serviceScript2.code);
          if (!linkedCodeMap) {
            continue;
          }
          const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript2);
          for (const linkedCodeOffset of linkedCodeMap.getLinkedOffsets(ref[1] - mappingOffset)) {
            process2(ref[0], linkedCodeOffset + mappingOffset);
          }
        }
      }
    }
    function displayPartsToString(displayParts) {
      if (displayParts) {
        return displayParts.map((displayPart) => displayPart.text).join("");
      }
      return "";
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/protocol/createProject.js
var require_createProject = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/protocol/createProject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLanguageServiceHost = createLanguageServiceHost;
    var language_core_1 = require_language_core();
    var path3 = require_path_browserify();
    var utils_1 = require_utils2();
    var resolveModuleName_1 = require_resolveModuleName();
    function createLanguageServiceHost(ts, sys, language, asScriptId, projectHost) {
      const pluginExtensions = language.plugins.map((plugin) => plugin.typescript?.extraFileExtensions.map((ext) => "." + ext.extension) ?? []).flat();
      const scriptVersions = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
      let lastProjectVersion;
      let tsProjectVersion = 0;
      let tsFileRegistry = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
      let tsFileDirRegistry = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
      let extraScriptRegistry = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
      let lastTsVirtualFileSnapshots = /* @__PURE__ */ new Set();
      let lastOtherVirtualFileSnapshots = /* @__PURE__ */ new Set();
      let languageServiceHost = {
        ...sys,
        getCurrentDirectory() {
          return projectHost.getCurrentDirectory();
        },
        useCaseSensitiveFileNames() {
          return sys.useCaseSensitiveFileNames;
        },
        getNewLine() {
          return sys.newLine;
        },
        getTypeRootsVersion: () => {
          return "version" in sys ? sys.version : -1;
        },
        getDirectories(dirName) {
          return sys.getDirectories(dirName);
        },
        readDirectory(dirName, extensions, excludes, includes, depth) {
          const exts = new Set(extensions);
          for (const ext of pluginExtensions) {
            exts.add(ext);
          }
          extensions = [...exts];
          return sys.readDirectory(dirName, extensions, excludes, includes, depth);
        },
        getCompilationSettings() {
          const options = projectHost.getCompilationSettings();
          if (pluginExtensions.length) {
            options.allowNonTsExtensions ??= true;
            if (!options.allowNonTsExtensions) {
              console.warn("`allowNonTsExtensions` must be `true`.");
            }
          }
          return options;
        },
        getLocalizedDiagnosticMessages: projectHost.getLocalizedDiagnosticMessages,
        getProjectReferences: projectHost.getProjectReferences,
        getDefaultLibFileName: (options) => {
          try {
            return ts.getDefaultLibFilePath(options);
          } catch {
            return `/node_modules/typescript/lib/${ts.getDefaultLibFileName(options)}`;
          }
        },
        readFile(fileName) {
          const snapshot = getScriptSnapshot(fileName);
          if (snapshot) {
            return snapshot.getText(0, snapshot.getLength());
          }
        },
        directoryExists(directoryName) {
          sync();
          if (tsFileDirRegistry.has(directoryName)) {
            return true;
          }
          return sys.directoryExists(directoryName);
        },
        fileExists(fileName) {
          return getScriptVersion(fileName) !== "";
        },
        getProjectVersion() {
          sync();
          return tsProjectVersion + ("version" in sys ? `:${sys.version}` : "");
        },
        getScriptFileNames() {
          sync();
          return [...tsFileRegistry.keys()];
        },
        getScriptKind(fileName) {
          sync();
          if (extraScriptRegistry.has(fileName)) {
            return extraScriptRegistry.get(fileName).scriptKind;
          }
          const sourceScript = language.scripts.get(asScriptId(fileName));
          if (sourceScript?.generated) {
            const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
            if (serviceScript) {
              return serviceScript.scriptKind;
            }
          }
          switch (path3.extname(fileName)) {
            case ".js":
            case ".cjs":
            case ".mjs":
              return ts.ScriptKind.JS;
            case ".jsx":
              return ts.ScriptKind.JSX;
            case ".ts":
            case ".cts":
            case ".mts":
              return ts.ScriptKind.TS;
            case ".tsx":
              return ts.ScriptKind.TSX;
            case ".json":
              return ts.ScriptKind.JSON;
            default:
              return ts.ScriptKind.Unknown;
          }
        },
        getScriptVersion,
        getScriptSnapshot
      };
      for (const plugin of language.plugins) {
        if (plugin.typescript?.resolveLanguageServiceHost) {
          languageServiceHost = plugin.typescript.resolveLanguageServiceHost(languageServiceHost);
        }
      }
      if (pluginExtensions.length) {
        const moduleResolutionCache = ts.createModuleResolutionCache(languageServiceHost.getCurrentDirectory(), languageServiceHost.useCaseSensitiveFileNames?.() ? (s) => s : (s) => s.toLowerCase(), languageServiceHost.getCompilationSettings());
        const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts, sys.getFileSize, languageServiceHost, language.plugins, (fileName) => language.scripts.get(asScriptId(fileName)));
        let lastSysVersion = "version" in sys ? sys.version : void 0;
        languageServiceHost.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, containingSourceFile) => {
          const disposeFixup = (0, utils_1.fixupImpliedNodeFormatForFile)(ts, pluginExtensions, containingSourceFile, moduleResolutionCache.getPackageJsonInfoCache(), languageServiceHost, options);
          try {
            if ("version" in sys && lastSysVersion !== sys.version) {
              lastSysVersion = sys.version;
              moduleResolutionCache.clear();
            }
            return moduleLiterals.map((moduleLiteral) => {
              const mode = ts.getModeForUsageLocation(containingSourceFile, moduleLiteral, options);
              return resolveModuleName(moduleLiteral.text, containingFile, options, moduleResolutionCache, redirectedReference, mode);
            });
          } finally {
            disposeFixup?.();
          }
        };
        languageServiceHost.resolveModuleNames = (moduleNames, containingFile, _reusedNames, redirectedReference, options) => {
          if ("version" in sys && lastSysVersion !== sys.version) {
            lastSysVersion = sys.version;
            moduleResolutionCache.clear();
          }
          return moduleNames.map((moduleName) => {
            return resolveModuleName(moduleName, containingFile, options, moduleResolutionCache, redirectedReference).resolvedModule;
          });
        };
        languageServiceHost.getModuleResolutionCache = () => moduleResolutionCache;
      }
      return {
        languageServiceHost,
        getExtraServiceScript
      };
      function getExtraServiceScript(fileName) {
        sync();
        return extraScriptRegistry.get(fileName);
      }
      function sync() {
        const newProjectVersion = projectHost.getProjectVersion?.();
        const shouldUpdate = newProjectVersion === void 0 || newProjectVersion !== lastProjectVersion;
        if (!shouldUpdate) {
          return;
        }
        lastProjectVersion = newProjectVersion;
        extraScriptRegistry.clear();
        const newTsVirtualFileSnapshots = /* @__PURE__ */ new Set();
        const newOtherVirtualFileSnapshots = /* @__PURE__ */ new Set();
        const tsFileNamesSet = /* @__PURE__ */ new Set();
        for (const fileName of projectHost.getScriptFileNames()) {
          const sourceScript = language.scripts.get(asScriptId(fileName));
          if (sourceScript?.generated) {
            const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
            if (serviceScript) {
              newTsVirtualFileSnapshots.add(serviceScript.code.snapshot);
              tsFileNamesSet.add(fileName);
            }
            for (const extraServiceScript of sourceScript.generated.languagePlugin.typescript?.getExtraServiceScripts?.(fileName, sourceScript.generated.root) ?? []) {
              newTsVirtualFileSnapshots.add(extraServiceScript.code.snapshot);
              tsFileNamesSet.add(extraServiceScript.fileName);
              extraScriptRegistry.set(extraServiceScript.fileName, extraServiceScript);
            }
            for (const code of (0, language_core_1.forEachEmbeddedCode)(sourceScript.generated.root)) {
              newOtherVirtualFileSnapshots.add(code.snapshot);
            }
          } else {
            tsFileNamesSet.add(fileName);
          }
        }
        if (!setEquals(lastTsVirtualFileSnapshots, newTsVirtualFileSnapshots)) {
          tsProjectVersion++;
        } else if (setEquals(lastOtherVirtualFileSnapshots, newOtherVirtualFileSnapshots)) {
          tsProjectVersion++;
        }
        lastTsVirtualFileSnapshots = newTsVirtualFileSnapshots;
        lastOtherVirtualFileSnapshots = newOtherVirtualFileSnapshots;
        tsFileRegistry.clear();
        tsFileDirRegistry.clear();
        for (const fileName of tsFileNamesSet) {
          tsFileRegistry.set(fileName, true);
          const parts = fileName.split("/");
          for (let i = 1; i < parts.length; i++) {
            const dirName = parts.slice(0, i).join("/");
            tsFileDirRegistry.set(dirName, true);
          }
        }
      }
      function getScriptSnapshot(fileName) {
        sync();
        if (extraScriptRegistry.has(fileName)) {
          return extraScriptRegistry.get(fileName).code.snapshot;
        }
        const sourceScript = language.scripts.get(asScriptId(fileName));
        if (sourceScript?.generated) {
          const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
          if (serviceScript) {
            return serviceScript.code.snapshot;
          }
        } else if (sourceScript) {
          return sourceScript.snapshot;
        }
      }
      function getScriptVersion(fileName) {
        sync();
        if (!scriptVersions.has(fileName)) {
          scriptVersions.set(fileName, { lastVersion: 0, map: /* @__PURE__ */ new WeakMap() });
        }
        const version = scriptVersions.get(fileName);
        if (extraScriptRegistry.has(fileName)) {
          const snapshot = extraScriptRegistry.get(fileName).code.snapshot;
          if (!version.map.has(snapshot)) {
            version.map.set(snapshot, version.lastVersion++);
          }
          return version.map.get(snapshot).toString();
        }
        const sourceScript = language.scripts.get(asScriptId(fileName));
        if (sourceScript?.generated) {
          const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
          if (serviceScript) {
            if (!version.map.has(serviceScript.code.snapshot)) {
              version.map.set(serviceScript.code.snapshot, version.lastVersion++);
            }
            return version.map.get(serviceScript.code.snapshot).toString();
          }
        }
        const openedFile = language.scripts.get(asScriptId(fileName), false);
        if (openedFile && !openedFile.generated) {
          if (!version.map.has(openedFile.snapshot)) {
            version.map.set(openedFile.snapshot, version.lastVersion++);
          }
          return version.map.get(openedFile.snapshot).toString();
        }
        if (sys.fileExists(fileName)) {
          return sys.getModifiedTime?.(fileName)?.valueOf().toString() ?? "0";
        }
        return "";
      }
    }
    function setEquals(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      for (const item of a) {
        if (!b.has(item)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/typescript/core.js
var require_core = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/typescript/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.every = every;
    exports2.findIndex = findIndex;
    exports2.indexOfAnyCharCode = indexOfAnyCharCode;
    exports2.map = map;
    exports2.flatten = flatten;
    exports2.flatMap = flatMap;
    exports2.some = some;
    exports2.sort = sort;
    exports2.lastOrUndefined = lastOrUndefined;
    exports2.last = last;
    exports2.equateStringsCaseInsensitive = equateStringsCaseInsensitive;
    exports2.equateStringsCaseSensitive = equateStringsCaseSensitive;
    exports2.compareStringsCaseSensitive = compareStringsCaseSensitive;
    exports2.getStringComparer = getStringComparer;
    exports2.endsWith = endsWith;
    exports2.stringContains = stringContains;
    exports2.createGetCanonicalFileName = createGetCanonicalFileName;
    exports2.startsWith = startsWith;
    var emptyArray = [];
    function every(array, callback) {
      if (array) {
        for (let i = 0; i < array.length; i++) {
          if (!callback(array[i], i)) {
            return false;
          }
        }
      }
      return true;
    }
    function findIndex(array, predicate, startIndex) {
      if (array === void 0) {
        return -1;
      }
      for (let i = startIndex ?? 0; i < array.length; i++) {
        if (predicate(array[i], i)) {
          return i;
        }
      }
      return -1;
    }
    function contains(array, value, equalityComparer = equateValues) {
      if (array) {
        for (const v of array) {
          if (equalityComparer(v, value)) {
            return true;
          }
        }
      }
      return false;
    }
    function indexOfAnyCharCode(text, charCodes, start) {
      for (let i = start || 0; i < text.length; i++) {
        if (contains(charCodes, text.charCodeAt(i))) {
          return i;
        }
      }
      return -1;
    }
    function map(array, f) {
      let result;
      if (array) {
        result = [];
        for (let i = 0; i < array.length; i++) {
          result.push(f(array[i], i));
        }
      }
      return result;
    }
    function flatten(array) {
      const result = [];
      for (const v of array) {
        if (v) {
          if (isArray(v)) {
            addRange(result, v);
          } else {
            result.push(v);
          }
        }
      }
      return result;
    }
    function flatMap(array, mapfn) {
      let result;
      if (array) {
        for (let i = 0; i < array.length; i++) {
          const v = mapfn(array[i], i);
          if (v) {
            if (isArray(v)) {
              result = addRange(result, v);
            } else {
              result = append(result, v);
            }
          }
        }
      }
      return result || emptyArray;
    }
    function some(array, predicate) {
      if (array) {
        if (predicate) {
          for (const v of array) {
            if (predicate(v)) {
              return true;
            }
          }
        } else {
          return array.length > 0;
        }
      }
      return false;
    }
    function append(to, value) {
      if (value === void 0) {
        return to;
      }
      if (to === void 0) {
        return [value];
      }
      to.push(value);
      return to;
    }
    function toOffset(array, offset) {
      return offset < 0 ? array.length + offset : offset;
    }
    function addRange(to, from, start, end) {
      if (from === void 0 || from.length === 0) {
        return to;
      }
      if (to === void 0) {
        return from.slice(start, end);
      }
      start = start === void 0 ? 0 : toOffset(from, start);
      end = end === void 0 ? from.length : toOffset(from, end);
      for (let i = start; i < end && i < from.length; i++) {
        if (from[i] !== void 0) {
          to.push(from[i]);
        }
      }
      return to;
    }
    function sort(array, comparer) {
      return array.length === 0 ? array : array.slice().sort(comparer);
    }
    function lastOrUndefined(array) {
      return array === void 0 || array.length === 0 ? void 0 : array[array.length - 1];
    }
    function last(array) {
      return array[array.length - 1];
    }
    function isArray(value) {
      return Array.isArray ? Array.isArray(value) : value instanceof Array;
    }
    function identity(x) {
      return x;
    }
    function toLowerCase(x) {
      return x.toLowerCase();
    }
    var fileNameLowerCaseRegExp = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g;
    function toFileNameLowerCase(x) {
      return fileNameLowerCaseRegExp.test(x) ? x.replace(fileNameLowerCaseRegExp, toLowerCase) : x;
    }
    function equateValues(a, b) {
      return a === b;
    }
    function equateStringsCaseInsensitive(a, b) {
      return a === b || a !== void 0 && b !== void 0 && a.toUpperCase() === b.toUpperCase();
    }
    function equateStringsCaseSensitive(a, b) {
      return equateValues(a, b);
    }
    function compareComparableValues(a, b) {
      return a === b ? 0 : a === void 0 ? -1 : b === void 0 ? 1 : a < b ? -1 : 1;
    }
    function compareStringsCaseInsensitive(a, b) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return -1;
      }
      if (b === void 0) {
        return 1;
      }
      a = a.toUpperCase();
      b = b.toUpperCase();
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function compareStringsCaseSensitive(a, b) {
      return compareComparableValues(a, b);
    }
    function getStringComparer(ignoreCase) {
      return ignoreCase ? compareStringsCaseInsensitive : compareStringsCaseSensitive;
    }
    function endsWith(str, suffix) {
      const expectedPos = str.length - suffix.length;
      return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;
    }
    function stringContains(str, substring) {
      return str.indexOf(substring) !== -1;
    }
    function createGetCanonicalFileName(useCaseSensitiveFileNames) {
      return useCaseSensitiveFileNames ? identity : toFileNameLowerCase;
    }
    function startsWith(str, prefix) {
      return str.lastIndexOf(prefix, 0) === 0;
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/typescript/path.js
var require_path = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/typescript/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.directorySeparator = void 0;
    exports2.isRootedDiskPath = isRootedDiskPath;
    exports2.hasExtension = hasExtension;
    exports2.fileExtensionIsOneOf = fileExtensionIsOneOf;
    exports2.getDirectoryPath = getDirectoryPath;
    exports2.combinePaths = combinePaths;
    exports2.getNormalizedPathComponents = getNormalizedPathComponents;
    exports2.normalizePath = normalizePath;
    exports2.removeTrailingDirectorySeparator = removeTrailingDirectorySeparator;
    exports2.containsPath = containsPath;
    var core_1 = require_core();
    exports2.directorySeparator = "/";
    var altDirectorySeparator = "\\";
    var urlSchemeSeparator = "://";
    var backslashRegExp = /\\/g;
    function isAnyDirectorySeparator(charCode) {
      return charCode === 47 || charCode === 92;
    }
    function isRootedDiskPath(path3) {
      return getEncodedRootLength(path3) > 0;
    }
    function hasExtension(fileName) {
      return (0, core_1.stringContains)(getBaseFileName(fileName), ".");
    }
    function fileExtensionIs(path3, extension) {
      return path3.length > extension.length && (0, core_1.endsWith)(path3, extension);
    }
    function fileExtensionIsOneOf(path3, extensions) {
      for (const extension of extensions) {
        if (fileExtensionIs(path3, extension)) {
          return true;
        }
      }
      return false;
    }
    function hasTrailingDirectorySeparator(path3) {
      return path3.length > 0 && isAnyDirectorySeparator(path3.charCodeAt(path3.length - 1));
    }
    function isVolumeCharacter(charCode) {
      return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90;
    }
    function getFileUrlVolumeSeparatorEnd(url, start) {
      const ch0 = url.charCodeAt(start);
      if (ch0 === 58) {
        return start + 1;
      }
      if (ch0 === 37 && url.charCodeAt(start + 1) === 51) {
        const ch2 = url.charCodeAt(start + 2);
        if (ch2 === 97 || ch2 === 65) {
          return start + 3;
        }
      }
      return -1;
    }
    function getEncodedRootLength(path3) {
      if (!path3) {
        return 0;
      }
      const ch0 = path3.charCodeAt(0);
      if (ch0 === 47 || ch0 === 92) {
        if (path3.charCodeAt(1) !== ch0) {
          return 1;
        }
        const p1 = path3.indexOf(ch0 === 47 ? exports2.directorySeparator : altDirectorySeparator, 2);
        if (p1 < 0) {
          return path3.length;
        }
        return p1 + 1;
      }
      if (isVolumeCharacter(ch0) && path3.charCodeAt(1) === 58) {
        const ch2 = path3.charCodeAt(2);
        if (ch2 === 47 || ch2 === 92) {
          return 3;
        }
        if (path3.length === 2) {
          return 2;
        }
      }
      const schemeEnd = path3.indexOf(urlSchemeSeparator);
      if (schemeEnd !== -1) {
        const authorityStart = schemeEnd + urlSchemeSeparator.length;
        const authorityEnd = path3.indexOf(exports2.directorySeparator, authorityStart);
        if (authorityEnd !== -1) {
          const scheme = path3.slice(0, schemeEnd);
          const authority = path3.slice(authorityStart, authorityEnd);
          if (scheme === "file" && (authority === "" || authority === "localhost") && isVolumeCharacter(path3.charCodeAt(authorityEnd + 1))) {
            const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path3, authorityEnd + 2);
            if (volumeSeparatorEnd !== -1) {
              if (path3.charCodeAt(volumeSeparatorEnd) === 47) {
                return ~(volumeSeparatorEnd + 1);
              }
              if (volumeSeparatorEnd === path3.length) {
                return ~volumeSeparatorEnd;
              }
            }
          }
          return ~(authorityEnd + 1);
        }
        return ~path3.length;
      }
      return 0;
    }
    function getRootLength(path3) {
      const rootLength = getEncodedRootLength(path3);
      return rootLength < 0 ? ~rootLength : rootLength;
    }
    function getDirectoryPath(path3) {
      path3 = normalizeSlashes(path3);
      const rootLength = getRootLength(path3);
      if (rootLength === path3.length) {
        return path3;
      }
      path3 = removeTrailingDirectorySeparator(path3);
      return path3.slice(0, Math.max(rootLength, path3.lastIndexOf(exports2.directorySeparator)));
    }
    function getBaseFileName(path3, extensions, ignoreCase) {
      path3 = normalizeSlashes(path3);
      const rootLength = getRootLength(path3);
      if (rootLength === path3.length) {
        return "";
      }
      path3 = removeTrailingDirectorySeparator(path3);
      const name = path3.slice(Math.max(getRootLength(path3), path3.lastIndexOf(exports2.directorySeparator) + 1));
      const extension = extensions !== void 0 && ignoreCase !== void 0 ? getAnyExtensionFromPath(name, extensions, ignoreCase) : void 0;
      return extension ? name.slice(0, name.length - extension.length) : name;
    }
    function tryGetExtensionFromPath(path3, extension, stringEqualityComparer) {
      if (!(0, core_1.startsWith)(extension, ".")) {
        extension = "." + extension;
      }
      if (path3.length >= extension.length && path3.charCodeAt(path3.length - extension.length) === 46) {
        const pathExtension = path3.slice(path3.length - extension.length);
        if (stringEqualityComparer(pathExtension, extension)) {
          return pathExtension;
        }
      }
    }
    function getAnyExtensionFromPathWorker(path3, extensions, stringEqualityComparer) {
      if (typeof extensions === "string") {
        return tryGetExtensionFromPath(path3, extensions, stringEqualityComparer) || "";
      }
      for (const extension of extensions) {
        const result = tryGetExtensionFromPath(path3, extension, stringEqualityComparer);
        if (result) {
          return result;
        }
      }
      return "";
    }
    function getAnyExtensionFromPath(path3, extensions, ignoreCase) {
      if (extensions) {
        return getAnyExtensionFromPathWorker(removeTrailingDirectorySeparator(path3), extensions, ignoreCase ? core_1.equateStringsCaseInsensitive : core_1.equateStringsCaseSensitive);
      }
      const baseFileName = getBaseFileName(path3);
      const extensionIndex = baseFileName.lastIndexOf(".");
      if (extensionIndex >= 0) {
        return baseFileName.substring(extensionIndex);
      }
      return "";
    }
    function pathComponents(path3, rootLength) {
      const root = path3.substring(0, rootLength);
      const rest = path3.substring(rootLength).split(exports2.directorySeparator);
      if (rest.length && !(0, core_1.lastOrUndefined)(rest)) {
        rest.pop();
      }
      return [root, ...rest];
    }
    function getPathComponents(path3, currentDirectory = "") {
      path3 = combinePaths(currentDirectory, path3);
      return pathComponents(path3, getRootLength(path3));
    }
    function getPathFromPathComponents(pathComponents2) {
      if (pathComponents2.length === 0) {
        return "";
      }
      const root = pathComponents2[0] && ensureTrailingDirectorySeparator(pathComponents2[0]);
      return root + pathComponents2.slice(1).join(exports2.directorySeparator);
    }
    function normalizeSlashes(path3) {
      return path3.indexOf("\\") !== -1 ? path3.replace(backslashRegExp, exports2.directorySeparator) : path3;
    }
    function reducePathComponents(components) {
      if (!(0, core_1.some)(components)) {
        return [];
      }
      const reduced = [components[0]];
      for (let i = 1; i < components.length; i++) {
        const component = components[i];
        if (!component) {
          continue;
        }
        if (component === ".") {
          continue;
        }
        if (component === "..") {
          if (reduced.length > 1) {
            if (reduced[reduced.length - 1] !== "..") {
              reduced.pop();
              continue;
            }
          } else if (reduced[0]) {
            continue;
          }
        }
        reduced.push(component);
      }
      return reduced;
    }
    function combinePaths(path3, ...paths) {
      if (path3) {
        path3 = normalizeSlashes(path3);
      }
      for (let relativePath of paths) {
        if (!relativePath) {
          continue;
        }
        relativePath = normalizeSlashes(relativePath);
        if (!path3 || getRootLength(relativePath) !== 0) {
          path3 = relativePath;
        } else {
          path3 = ensureTrailingDirectorySeparator(path3) + relativePath;
        }
      }
      return path3;
    }
    function getNormalizedPathComponents(path3, currentDirectory) {
      return reducePathComponents(getPathComponents(path3, currentDirectory));
    }
    function normalizePath(path3) {
      path3 = normalizeSlashes(path3);
      if (!relativePathSegmentRegExp.test(path3)) {
        return path3;
      }
      const simplified = path3.replace(/\/\.\//g, "/").replace(/^\.\//, "");
      if (simplified !== path3) {
        path3 = simplified;
        if (!relativePathSegmentRegExp.test(path3)) {
          return path3;
        }
      }
      const normalized = getPathFromPathComponents(reducePathComponents(getPathComponents(path3)));
      return normalized && hasTrailingDirectorySeparator(path3) ? ensureTrailingDirectorySeparator(normalized) : normalized;
    }
    function removeTrailingDirectorySeparator(path3) {
      if (hasTrailingDirectorySeparator(path3)) {
        return path3.substr(0, path3.length - 1);
      }
      return path3;
    }
    function ensureTrailingDirectorySeparator(path3) {
      if (!hasTrailingDirectorySeparator(path3)) {
        return path3 + exports2.directorySeparator;
      }
      return path3;
    }
    var relativePathSegmentRegExp = /(?:\/\/)|(?:^|\/)\.\.?(?:$|\/)/;
    function containsPath(parent, child, currentDirectory, ignoreCase) {
      if (typeof currentDirectory === "string") {
        parent = combinePaths(currentDirectory, parent);
        child = combinePaths(currentDirectory, child);
      } else if (typeof currentDirectory === "boolean") {
        ignoreCase = currentDirectory;
      }
      if (parent === void 0 || child === void 0) {
        return false;
      }
      if (parent === child) {
        return true;
      }
      const parentComponents = reducePathComponents(getPathComponents(parent));
      const childComponents = reducePathComponents(getPathComponents(child));
      if (childComponents.length < parentComponents.length) {
        return false;
      }
      const componentEqualityComparer = ignoreCase ? core_1.equateStringsCaseInsensitive : core_1.equateStringsCaseSensitive;
      for (let i = 0; i < parentComponents.length; i++) {
        const equalityComparer = i === 0 ? core_1.equateStringsCaseInsensitive : componentEqualityComparer;
        if (!equalityComparer(parentComponents[i], childComponents[i])) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/typescript/utilities.js
var require_utilities = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/typescript/utilities.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.matchFiles = matchFiles;
    var core_1 = require_core();
    var path_1 = require_path();
    var reservedCharacterPattern = /[^\w\s\/]/g;
    var wildcardCharCodes = [
      42,
      63
      /* CharacterCodes.question */
    ];
    var commonPackageFolders = ["node_modules", "bower_components", "jspm_packages"];
    var implicitExcludePathRegexPattern = `(?!(${commonPackageFolders.join("|")})(/|$))`;
    var filesMatcher = {
      /**
       * Matches any single directory segment unless it is the last segment and a .min.js file
       * Breakdown:
       *  [^./]                   # matches everything up to the first . character (excluding directory separators)
       *  (\\.(?!min\\.js$))?     # matches . characters but not if they are part of the .min.js file extension
       */
      singleAsteriskRegexFragment: "([^./]|(\\.(?!min\\.js$))?)*",
      /**
       * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
       * files or directories, does not match subdirectories that start with a . character
       */
      doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,
      replaceWildcardCharacter: (match) => replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment)
    };
    var directoriesMatcher = {
      singleAsteriskRegexFragment: "[^/]*",
      /**
       * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
       * files or directories, does not match subdirectories that start with a . character
       */
      doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,
      replaceWildcardCharacter: (match) => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment)
    };
    var excludeMatcher = {
      singleAsteriskRegexFragment: "[^/]*",
      doubleAsteriskRegexFragment: "(/.+?)?",
      replaceWildcardCharacter: (match) => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)
    };
    var wildcardMatchers = {
      files: filesMatcher,
      directories: directoriesMatcher,
      exclude: excludeMatcher
    };
    function getRegularExpressionForWildcard(specs, basePath, usage) {
      const patterns = getRegularExpressionsForWildcards(specs, basePath, usage);
      if (!patterns || !patterns.length) {
        return void 0;
      }
      const pattern = patterns.map((pattern2) => `(${pattern2})`).join("|");
      const terminator = usage === "exclude" ? "($|/)" : "$";
      return `^(${pattern})${terminator}`;
    }
    function getRegularExpressionsForWildcards(specs, basePath, usage) {
      if (specs === void 0 || specs.length === 0) {
        return void 0;
      }
      return (0, core_1.flatMap)(specs, (spec) => spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]));
    }
    function isImplicitGlob(lastPathComponent) {
      return !/[.*?]/.test(lastPathComponent);
    }
    function getSubPatternFromSpec(spec, basePath, usage, { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter: replaceWildcardCharacter2 }) {
      let subpattern = "";
      let hasWrittenComponent = false;
      const components = (0, path_1.getNormalizedPathComponents)(spec, basePath);
      const lastComponent = (0, core_1.last)(components);
      if (usage !== "exclude" && lastComponent === "**") {
        return void 0;
      }
      components[0] = (0, path_1.removeTrailingDirectorySeparator)(components[0]);
      if (isImplicitGlob(lastComponent)) {
        components.push("**", "*");
      }
      let optionalCount = 0;
      for (let component of components) {
        if (component === "**") {
          subpattern += doubleAsteriskRegexFragment;
        } else {
          if (usage === "directories") {
            subpattern += "(";
            optionalCount++;
          }
          if (hasWrittenComponent) {
            subpattern += path_1.directorySeparator;
          }
          if (usage !== "exclude") {
            let componentPattern = "";
            if (component.charCodeAt(0) === 42) {
              componentPattern += "([^./]" + singleAsteriskRegexFragment + ")?";
              component = component.substr(1);
            } else if (component.charCodeAt(0) === 63) {
              componentPattern += "[^./]";
              component = component.substr(1);
            }
            componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter2);
            if (componentPattern !== component) {
              subpattern += implicitExcludePathRegexPattern;
            }
            subpattern += componentPattern;
          } else {
            subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter2);
          }
        }
        hasWrittenComponent = true;
      }
      while (optionalCount > 0) {
        subpattern += ")?";
        optionalCount--;
      }
      return subpattern;
    }
    function replaceWildcardCharacter(match, singleAsteriskRegexFragment) {
      return match === "*" ? singleAsteriskRegexFragment : match === "?" ? "[^/]" : "\\" + match;
    }
    function getFileMatcherPatterns(path3, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {
      path3 = (0, path_1.normalizePath)(path3);
      currentDirectory = (0, path_1.normalizePath)(currentDirectory);
      const absolutePath = (0, path_1.combinePaths)(currentDirectory, path3);
      return {
        includeFilePatterns: (0, core_1.map)(getRegularExpressionsForWildcards(includes, absolutePath, "files"), (pattern) => `^${pattern}$`),
        includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, "files"),
        includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, "directories"),
        excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, "exclude"),
        basePaths: getBasePaths(path3, includes, useCaseSensitiveFileNames)
      };
    }
    function getRegexFromPattern(pattern, useCaseSensitiveFileNames) {
      return new RegExp(pattern, useCaseSensitiveFileNames ? "" : "i");
    }
    function matchFiles(path3, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getFileSystemEntries, realpath) {
      path3 = (0, path_1.normalizePath)(path3);
      currentDirectory = (0, path_1.normalizePath)(currentDirectory);
      const patterns = getFileMatcherPatterns(path3, excludes, includes, useCaseSensitiveFileNames, currentDirectory);
      const includeFileRegexes = patterns.includeFilePatterns && patterns.includeFilePatterns.map((pattern) => getRegexFromPattern(pattern, useCaseSensitiveFileNames));
      const includeDirectoryRegex = patterns.includeDirectoryPattern && getRegexFromPattern(patterns.includeDirectoryPattern, useCaseSensitiveFileNames);
      const excludeRegex = patterns.excludePattern && getRegexFromPattern(patterns.excludePattern, useCaseSensitiveFileNames);
      const results = includeFileRegexes ? includeFileRegexes.map(() => []) : [[]];
      const visited = /* @__PURE__ */ new Map();
      const toCanonical = (0, core_1.createGetCanonicalFileName)(useCaseSensitiveFileNames);
      for (const basePath of patterns.basePaths) {
        visitDirectory(basePath, (0, path_1.combinePaths)(currentDirectory, basePath), depth);
      }
      return (0, core_1.flatten)(results);
      function visitDirectory(path4, absolutePath, depth2) {
        const canonicalPath = toCanonical(realpath(absolutePath));
        if (visited.has(canonicalPath)) {
          return;
        }
        visited.set(canonicalPath, true);
        const { files, directories } = getFileSystemEntries(path4);
        for (const current of (0, core_1.sort)(files, core_1.compareStringsCaseSensitive)) {
          const name = (0, path_1.combinePaths)(path4, current);
          const absoluteName = (0, path_1.combinePaths)(absolutePath, current);
          if (extensions && !(0, path_1.fileExtensionIsOneOf)(name, extensions)) {
            continue;
          }
          if (excludeRegex && excludeRegex.test(absoluteName)) {
            continue;
          }
          if (!includeFileRegexes) {
            results[0].push(name);
          } else {
            const includeIndex = (0, core_1.findIndex)(includeFileRegexes, (re) => re.test(absoluteName));
            if (includeIndex !== -1) {
              results[includeIndex].push(name);
            }
          }
        }
        if (depth2 !== void 0) {
          depth2--;
          if (depth2 === 0) {
            return;
          }
        }
        for (const current of (0, core_1.sort)(directories, core_1.compareStringsCaseSensitive)) {
          const name = (0, path_1.combinePaths)(path4, current);
          const absoluteName = (0, path_1.combinePaths)(absolutePath, current);
          if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) && (!excludeRegex || !excludeRegex.test(absoluteName))) {
            visitDirectory(name, absoluteName, depth2);
          }
        }
      }
    }
    function getBasePaths(path3, includes, useCaseSensitiveFileNames) {
      const basePaths = [path3];
      if (includes) {
        const includeBasePaths = [];
        for (const include of includes) {
          const absolute = (0, path_1.isRootedDiskPath)(include) ? include : (0, path_1.normalizePath)((0, path_1.combinePaths)(path3, include));
          includeBasePaths.push(getIncludeBasePath(absolute));
        }
        includeBasePaths.sort((0, core_1.getStringComparer)(!useCaseSensitiveFileNames));
        for (const includeBasePath of includeBasePaths) {
          if ((0, core_1.every)(basePaths, (basePath) => !(0, path_1.containsPath)(basePath, includeBasePath, path3, !useCaseSensitiveFileNames))) {
            basePaths.push(includeBasePath);
          }
        }
      }
      return basePaths;
    }
    function getIncludeBasePath(absolute) {
      const wildcardOffset = (0, core_1.indexOfAnyCharCode)(absolute, wildcardCharCodes);
      if (wildcardOffset < 0) {
        return !(0, path_1.hasExtension)(absolute) ? absolute : (0, path_1.removeTrailingDirectorySeparator)((0, path_1.getDirectoryPath)(absolute));
      }
      return absolute.substring(0, absolute.lastIndexOf(path_1.directorySeparator, wildcardOffset));
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/protocol/createSys.js
var require_createSys = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/lib/protocol/createSys.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSys = createSys;
    var path3 = require_path_browserify();
    var vscode_uri_1 = require_umd();
    var utilities_1 = require_utilities();
    var currentCwd = "";
    function createSys(sys, env, getCurrentDirectory, uriConverter) {
      let version = 0;
      const caseSensitive = sys?.useCaseSensitiveFileNames ?? false;
      const root = {
        name: "",
        dirs: /* @__PURE__ */ new Map(),
        files: /* @__PURE__ */ new Map(),
        requestedRead: false
      };
      const promises = /* @__PURE__ */ new Set();
      const fileWatcher = env.onDidChangeWatchedFiles?.(({ changes }) => {
        version++;
        for (const change of changes) {
          const changeUri = vscode_uri_1.URI.parse(change.uri);
          const fileName = uriConverter.asFileName(changeUri);
          const dirName = path3.dirname(fileName);
          const baseName = path3.basename(fileName);
          const fileExists2 = change.type === 1 || change.type === 2;
          const dir = getDir(dirName, fileExists2);
          dir.files.set(normalizeFileId(baseName), fileExists2 ? {
            name: baseName,
            stat: {
              type: 1,
              ctime: Date.now(),
              mtime: Date.now(),
              size: -1
            },
            requestedStat: false,
            requestedText: false
          } : {
            name: baseName,
            stat: void 0,
            text: void 0,
            requestedStat: true,
            requestedText: true
          });
        }
      });
      return {
        dispose() {
          fileWatcher?.dispose();
        },
        args: sys?.args ?? [],
        newLine: sys?.newLine ?? "\n",
        useCaseSensitiveFileNames: caseSensitive,
        realpath: sys?.realpath,
        write: sys?.write ?? (() => {
        }),
        writeFile: sys?.writeFile ?? (() => {
        }),
        createDirectory: sys?.createDirectory ?? (() => {
        }),
        exit: sys?.exit ?? (() => {
        }),
        getExecutingFilePath: sys?.getExecutingFilePath ?? (() => getCurrentDirectory + "/__fake__.js"),
        getCurrentDirectory,
        getModifiedTime,
        readFile,
        readDirectory,
        getDirectories,
        resolvePath,
        fileExists,
        directoryExists,
        get version() {
          return version;
        },
        async sync() {
          while (promises.size) {
            await Promise.all(promises);
          }
          return version;
        }
      };
      function resolvePath(fsPath) {
        if (sys) {
          const currentDirectory = getCurrentDirectory();
          if (currentCwd !== currentDirectory) {
            currentCwd = currentDirectory;
            if (sys.directoryExists(currentDirectory)) {
              try {
                process.chdir(currentDirectory);
              } catch {
              }
            }
          }
          return sys.resolvePath(fsPath).replace(/\\/g, "/");
        }
        return path3.resolve(fsPath).replace(/\\/g, "/");
      }
      function readFile(fileName, encoding) {
        fileName = resolvePath(fileName);
        const dirPath = path3.dirname(fileName);
        const dir = getDir(dirPath);
        const name = path3.basename(fileName);
        readFileWorker(fileName, encoding, dir);
        return dir.files.get(normalizeFileId(name))?.text;
      }
      function directoryExists(dirName) {
        dirName = resolvePath(dirName);
        const dir = getDir(dirName);
        if (dir.exists === void 0) {
          dir.exists = false;
          const result = env.fs?.stat(uriConverter.asUri(dirName));
          if (typeof result === "object" && "then" in result) {
            const promise = result;
            promises.add(promise);
            result.then((result2) => {
              promises.delete(promise);
              dir.exists = result2?.type === 2;
              if (dir.exists) {
                version++;
              }
            });
          } else {
            dir.exists = result?.type === 2;
          }
        }
        return dir.exists;
      }
      function getModifiedTime(fileName) {
        fileName = resolvePath(fileName);
        const file = getFile(fileName);
        if (!file.requestedStat) {
          file.requestedStat = true;
          handleStat(fileName, file);
        }
        return file.stat ? new Date(file.stat.mtime) : /* @__PURE__ */ new Date(-1);
      }
      function fileExists(fileName) {
        fileName = resolvePath(fileName);
        const file = getFile(fileName);
        const exists = () => file.text !== void 0 || file.stat?.type === 1;
        if (exists()) {
          return true;
        }
        if (!file.requestedStat) {
          file.requestedStat = true;
          handleStat(fileName, file);
        }
        return exists();
      }
      function handleStat(fileName, file) {
        const result = env.fs?.stat(uriConverter.asUri(fileName));
        if (typeof result === "object" && "then" in result) {
          const promise = result;
          promises.add(promise);
          result.then((result2) => {
            promises.delete(promise);
            if (file.stat?.type !== result2?.type || file.stat?.mtime !== result2?.mtime) {
              version++;
            }
            file.stat = result2;
          });
        } else {
          file.stat = result;
        }
      }
      function getFile(fileName) {
        fileName = resolvePath(fileName);
        const dirPath = path3.dirname(fileName);
        const baseName = path3.basename(fileName);
        const dir = getDir(dirPath);
        let file = dir.files.get(normalizeFileId(baseName));
        if (!file) {
          dir.files.set(normalizeFileId(baseName), file = {
            name: baseName,
            requestedStat: false,
            requestedText: false
          });
        }
        return file;
      }
      function getDirectories(dirName) {
        dirName = resolvePath(dirName);
        readDirectoryWorker(dirName);
        const dir = getDir(dirName);
        return [...dir.dirs.values()].filter((dir2) => dir2.exists).map((dir2) => dir2.name);
      }
      function readDirectory(dirName, extensions, excludes, includes, depth) {
        dirName = resolvePath(dirName);
        const currentDirectory = getCurrentDirectory();
        const matches = (0, utilities_1.matchFiles)(dirName, extensions, excludes, includes, caseSensitive, currentDirectory, depth, (dirPath) => {
          dirPath = resolvePath(dirPath);
          readDirectoryWorker(dirPath);
          const dir = getDir(dirPath);
          return {
            files: [...dir.files.values()].filter((file) => file.stat?.type === 1).map((file) => file.name),
            directories: [...dir.dirs.values()].filter((dir2) => dir2.exists).map((dir2) => dir2.name)
          };
        }, sys?.realpath ? ((path4) => sys.realpath(path4)) : ((path4) => path4));
        return [...new Set(matches)];
      }
      function readFileWorker(fileName, encoding, dir) {
        const name = path3.basename(fileName);
        let file = dir.files.get(normalizeFileId(name));
        if (!file) {
          dir.files.set(normalizeFileId(name), file = {
            name,
            requestedStat: false,
            requestedText: false
          });
        }
        if (file.requestedText) {
          return;
        }
        file.requestedText = true;
        const uri = uriConverter.asUri(fileName);
        const result = env.fs?.readFile(uri, encoding);
        if (typeof result === "object" && "then" in result) {
          const promise = result;
          promises.add(promise);
          result.then((result2) => {
            promises.delete(promise);
            if (result2 !== void 0) {
              file.text = result2;
              if (file.stat) {
                file.stat.mtime++;
              }
              version++;
            }
          });
        } else if (result !== void 0) {
          file.text = result;
        }
      }
      function readDirectoryWorker(dirName) {
        const dir = getDir(dirName);
        if (dir.requestedRead) {
          return;
        }
        dir.requestedRead = true;
        const result = env.fs?.readDirectory(uriConverter.asUri(dirName || "."));
        if (typeof result === "object" && "then" in result) {
          const promise = result;
          promises.add(promise);
          result.then((result2) => {
            promises.delete(promise);
            if (onReadDirectoryResult(dirName, dir, result2)) {
              version++;
            }
          });
        } else {
          onReadDirectoryResult(dirName, dir, result ?? []);
        }
      }
      function onReadDirectoryResult(dirName, dir, result) {
        result = result.filter(([name]) => name !== "." && name !== "..");
        let updated = false;
        for (const [name, _fileType] of result) {
          let fileType = _fileType;
          if (fileType === 64) {
            const stat = env.fs?.stat(uriConverter.asUri(dirName + "/" + name));
            if (typeof stat === "object" && "then" in stat) {
              const promise = stat;
              promises.add(promise);
              stat.then((stat2) => {
                promises.delete(promise);
                if (stat2?.type === 1) {
                  let file = dir.files.get(normalizeFileId(name));
                  if (!file) {
                    dir.files.set(normalizeFileId(name), file = {
                      name,
                      requestedStat: false,
                      requestedText: false
                    });
                  }
                  if (stat2.type !== file.stat?.type || stat2.mtime !== file.stat?.mtime) {
                    version++;
                  }
                  file.stat = stat2;
                  file.requestedStat = true;
                } else if (stat2?.type === 2) {
                  const childDir = getDirFromDir(dir, name);
                  if (!childDir.exists) {
                    childDir.exists = true;
                    version++;
                  }
                }
              });
            } else if (stat) {
              fileType = stat.type;
            }
          }
          if (fileType === 1) {
            let file = dir.files.get(normalizeFileId(name));
            if (!file) {
              dir.files.set(normalizeFileId(name), file = {
                name,
                requestedStat: false,
                requestedText: false
              });
            }
            if (!file.stat) {
              file.stat = {
                type: 1,
                mtime: 0,
                ctime: 0,
                size: 0
              };
              updated = true;
            }
          } else if (fileType === 2) {
            const childDir = getDirFromDir(dir, name);
            if (!childDir.exists) {
              childDir.exists = true;
              updated = true;
            }
          }
        }
        return updated;
      }
      function getDir(dirName, markExists = false) {
        const dirNames = [];
        let currentDirPath = dirName;
        let currentDirName = path3.basename(currentDirPath);
        let lastDirPath;
        while (lastDirPath !== currentDirPath) {
          lastDirPath = currentDirPath;
          dirNames.push(currentDirName);
          currentDirPath = path3.dirname(currentDirPath);
          currentDirName = path3.basename(currentDirPath);
        }
        let currentDir = root;
        for (let i = dirNames.length - 1; i >= 0; i--) {
          const nextDirName = dirNames[i];
          currentDir = getDirFromDir(currentDir, nextDirName);
          if (markExists && !currentDir.exists) {
            currentDir.exists = true;
            version++;
          }
        }
        return currentDir;
      }
      function getDirFromDir(dir, name) {
        let target = dir.dirs.get(normalizeFileId(name));
        if (!target) {
          dir.dirs.set(normalizeFileId(name), target = {
            name,
            dirs: /* @__PURE__ */ new Map(),
            files: /* @__PURE__ */ new Map()
          });
        }
        return target;
      }
      function normalizeFileId(fileName) {
        return caseSensitive ? fileName : fileName.toLowerCase();
      }
    }
  }
});

// node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/index.js
var require_typescript = __commonJS({
  "node_modules/.pnpm/@volar+typescript@2.4.26/node_modules/@volar/typescript/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_common2(), exports2);
    __exportStar2(require_decorateLanguageServiceHost(), exports2);
    __exportStar2(require_decorateProgram(), exports2);
    __exportStar2(require_proxyCreateProgram(), exports2);
    __exportStar2(require_proxyLanguageService(), exports2);
    __exportStar2(require_createProject(), exports2);
    __exportStar2(require_createSys(), exports2);
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/project/typescriptProjectLs.js
var require_typescriptProjectLs = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/project/typescriptProjectLs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTypeScriptLS = createTypeScriptLS;
    var language_service_1 = require_language_service();
    var typescript_1 = require_typescript();
    var utilities_1 = require_utilities();
    var path3 = require_path_browserify();
    var vscode2 = require_main4();
    var vscode_uri_1 = require_umd();
    var fsFileSnapshots = (0, language_service_1.createUriMap)();
    async function createTypeScriptLS(ts, tsLocalized, tsconfig, server2, serviceEnv, workspaceFolder, uriConverter, create) {
      let commandLine;
      let projectVersion = 0;
      const getCurrentDirectory = () => uriConverter.asFileName(workspaceFolder);
      const sys = (0, typescript_1.createSys)(ts.sys, serviceEnv, getCurrentDirectory, uriConverter);
      const projectHost = {
        getCurrentDirectory,
        getProjectVersion() {
          return projectVersion.toString();
        },
        getScriptFileNames() {
          return commandLine.fileNames;
        },
        getCompilationSettings() {
          return commandLine.options;
        },
        getLocalizedDiagnosticMessages: tsLocalized ? () => tsLocalized : void 0,
        getProjectReferences() {
          return commandLine.projectReferences;
        }
      };
      const { languagePlugins, setup } = await create({
        env: serviceEnv,
        configFileName: typeof tsconfig === "string" ? tsconfig : void 0,
        projectHost,
        sys,
        uriConverter
      });
      const unsavedRootFileUris = (0, language_service_1.createUriMap)();
      const disposables = [
        server2.documents.onDidOpen(({ document }) => updateFsCacheFromSyncedDocument(document)),
        server2.documents.onDidSave(({ document }) => updateFsCacheFromSyncedDocument(document)),
        server2.documents.onDidChangeContent(() => projectVersion++),
        serviceEnv.onDidChangeWatchedFiles?.(async ({ changes }) => {
          const createdOrDeleted = changes.some((change) => change.type !== vscode2.FileChangeType.Changed);
          if (createdOrDeleted) {
            await updateCommandLine();
          }
          projectVersion++;
        }),
        server2.documents.onDidOpen(async ({ document }) => {
          const uri = vscode_uri_1.URI.parse(document.uri);
          const isWorkspaceFile = workspaceFolder.scheme === uri.scheme;
          if (!isWorkspaceFile) {
            return;
          }
          const stat = await serviceEnv.fs?.stat(uri);
          const isUnsaved = stat?.type !== 1;
          if (isUnsaved) {
            const lastProjectVersion = projectVersion;
            await updateCommandLine();
            if (lastProjectVersion !== projectVersion) {
              unsavedRootFileUris.set(uri, true);
            }
          }
        }),
        server2.documents.onDidClose(async ({ document }) => {
          const uri = vscode_uri_1.URI.parse(document.uri);
          if (unsavedRootFileUris.has(uri)) {
            unsavedRootFileUris.delete(uri);
            await updateCommandLine();
          }
        })
      ].filter((d) => !!d);
      await updateCommandLine();
      const language = (0, language_service_1.createLanguage)([
        { getLanguageId: (uri) => server2.documents.get(uri)?.languageId },
        ...languagePlugins,
        { getLanguageId: (uri) => (0, typescript_1.resolveFileLanguageId)(uri.path) }
      ], (0, language_service_1.createUriMap)(sys.useCaseSensitiveFileNames), (uri, includeFsFiles) => {
        const syncedDocument = server2.documents.get(uri);
        let snapshot;
        if (syncedDocument) {
          snapshot = syncedDocument.getSnapshot();
        } else if (includeFsFiles) {
          const cache = fsFileSnapshots.get(uri);
          const fileName = uriConverter.asFileName(uri);
          const modifiedTime = sys.getModifiedTime?.(fileName)?.valueOf();
          if (!cache || cache[0] !== modifiedTime) {
            if (sys.fileExists(fileName)) {
              const text = sys.readFile(fileName);
              const snapshot2 = text !== void 0 ? ts.ScriptSnapshot.fromString(text) : void 0;
              fsFileSnapshots.set(uri, [modifiedTime, snapshot2]);
            } else {
              fsFileSnapshots.set(uri, [modifiedTime, void 0]);
            }
          }
          snapshot = fsFileSnapshots.get(uri)?.[1];
        }
        if (snapshot) {
          language.scripts.set(uri, snapshot);
        } else {
          language.scripts.delete(uri);
        }
      });
      const project = {
        typescript: {
          configFileName: typeof tsconfig === "string" ? tsconfig : void 0,
          sys,
          uriConverter,
          ...(0, typescript_1.createLanguageServiceHost)(ts, sys, language, (s) => uriConverter.asUri(s), projectHost)
        }
      };
      setup?.({ language, project });
      const languageService = (0, language_service_1.createLanguageService)(language, server2.languageServicePlugins, serviceEnv, project);
      return {
        languageService,
        tryAddFile(fileName) {
          if (!commandLine.fileNames.includes(fileName)) {
            commandLine.fileNames.push(fileName);
            projectVersion++;
          }
        },
        dispose: () => {
          sys.dispose();
          languageService?.dispose();
          disposables.forEach(({ dispose }) => dispose());
          disposables.length = 0;
        },
        getCommandLine: () => commandLine
      };
      function updateFsCacheFromSyncedDocument(document) {
        const uri = vscode_uri_1.URI.parse(document.uri);
        const fileName = uriConverter.asFileName(uri);
        if (fsFileSnapshots.has(uri) || sys.fileExists(fileName)) {
          const modifiedTime = sys.getModifiedTime?.(fileName);
          fsFileSnapshots.set(uri, [modifiedTime?.valueOf(), document.getSnapshot()]);
        }
      }
      async function updateCommandLine() {
        const oldFileNames = new Set(commandLine?.fileNames ?? []);
        commandLine = await parseConfig(ts, sys, uriConverter.asFileName(workspaceFolder), tsconfig, languagePlugins.map((plugin) => plugin.typescript?.extraFileExtensions ?? []).flat());
        const newFileNames = new Set(commandLine.fileNames);
        if (oldFileNames.size !== newFileNames.size || [...oldFileNames].some((fileName) => !newFileNames.has(fileName))) {
          projectVersion++;
        }
      }
      async function parseConfig(ts2, sys2, workspacePath, tsconfig2, extraFileExtensions) {
        let commandLine2 = {
          errors: [],
          fileNames: [],
          options: {}
        };
        let sysVersion;
        let newSysVersion = await sys2.sync();
        while (sysVersion !== newSysVersion) {
          sysVersion = newSysVersion;
          try {
            commandLine2 = parseConfigWorker(ts2, sys2, workspacePath, tsconfig2, extraFileExtensions);
          } catch {
          }
          newSysVersion = await sys2.sync();
        }
        return commandLine2;
      }
      function parseConfigWorker(ts2, _host, workspacePath, tsconfig2, extraFileExtensions) {
        let content = {
          errors: [],
          fileNames: [],
          options: {}
        };
        const maybeUnsavedFileNames = server2.documents.all().map((document) => vscode_uri_1.URI.parse(document.uri)).filter((uri) => uri.scheme === workspaceFolder.scheme).map((uri) => uriConverter.asFileName(uri));
        const host = {
          ..._host,
          readDirectory(rootDir, extensions, excludes, includes, depth) {
            const fsFiles = _host.readDirectory(rootDir, extensions, excludes, includes, depth);
            const unsavedFiles = (0, utilities_1.matchFiles)(rootDir, extensions, excludes, includes, sys.useCaseSensitiveFileNames, getCurrentDirectory(), depth, (dirPath) => {
              dirPath = dirPath.replace(/\\/g, "/");
              const files = [];
              const dirs = [];
              for (const fileName of maybeUnsavedFileNames) {
                const match = sys.useCaseSensitiveFileNames ? fileName.startsWith(dirPath + "/") : fileName.toLowerCase().startsWith(dirPath.toLowerCase() + "/");
                if (match) {
                  const name = fileName.slice(dirPath.length + 1);
                  if (name.includes("/")) {
                    const dir = name.split("/")[0];
                    if (!dirs.includes(dir)) {
                      dirs.push(dir);
                    }
                  } else {
                    files.push(name);
                  }
                }
              }
              return {
                files,
                directories: dirs
              };
            }, (path4) => path4);
            if (!unsavedFiles.length) {
              return fsFiles;
            }
            return [.../* @__PURE__ */ new Set([...fsFiles, ...unsavedFiles])];
          }
        };
        if (typeof tsconfig2 === "string") {
          const config = ts2.readJsonConfigFile(tsconfig2, host.readFile);
          content = ts2.parseJsonSourceFileConfigFileContent(config, host, path3.dirname(tsconfig2), {}, tsconfig2, void 0, extraFileExtensions);
        } else {
          content = ts2.parseJsonConfigFileContent({ files: [] }, host, workspacePath, tsconfig2, workspacePath + "/jsconfig.json", void 0, extraFileExtensions);
        }
        content.options.outDir = void 0;
        content.fileNames = content.fileNames.map((fileName) => fileName.replace(/\\/g, "/"));
        return content;
      }
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/project/typescriptProject.js
var require_typescriptProject = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/lib/project/typescriptProject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTypeScriptProject = createTypeScriptProject;
    exports2.createUriConverter = createUriConverter;
    exports2.sortTSConfigs = sortTSConfigs;
    exports2.isFileInDir = isFileInDir;
    exports2.getWorkspaceFolder = getWorkspaceFolder;
    var language_service_1 = require_language_service();
    var path3 = require_path_browserify();
    var vscode2 = require_main4();
    var vscode_uri_1 = require_umd();
    var inferredCompilerOptions_1 = require_inferredCompilerOptions();
    var simpleProject_1 = require_simpleProject();
    var typescriptProjectLs_1 = require_typescriptProjectLs();
    var rootTsConfigNames = ["tsconfig.json", "jsconfig.json"];
    function createTypeScriptProject(ts, tsLocalized, create) {
      let server2;
      let uriConverter;
      const configProjects = (0, language_service_1.createUriMap)();
      const inferredProjects = (0, language_service_1.createUriMap)();
      const rootTsConfigs = /* @__PURE__ */ new Set();
      const searchedDirs = /* @__PURE__ */ new Set();
      return {
        setup(_server) {
          uriConverter = createUriConverter(_server.workspaceFolders.all);
          server2 = _server;
          server2.fileWatcher.onDidChangeWatchedFiles(({ changes }) => {
            const tsConfigChanges = changes.filter((change) => rootTsConfigNames.includes(change.uri.substring(change.uri.lastIndexOf("/") + 1)));
            for (const change of tsConfigChanges) {
              const changeUri = vscode_uri_1.URI.parse(change.uri);
              const changeFileName = uriConverter.asFileName(changeUri);
              if (change.type === vscode2.FileChangeType.Created) {
                rootTsConfigs.add(changeFileName);
              } else if ((change.type === vscode2.FileChangeType.Changed || change.type === vscode2.FileChangeType.Deleted) && configProjects.has(changeUri)) {
                if (change.type === vscode2.FileChangeType.Deleted) {
                  rootTsConfigs.delete(changeFileName);
                }
                const project = configProjects.get(changeUri);
                configProjects.delete(changeUri);
                project?.then((project2) => project2.dispose());
              }
            }
            server2.languageFeatures.requestRefresh(!!tsConfigChanges.length);
          });
        },
        async getLanguageService(uri) {
          const tsconfig = await findMatchTSConfig(server2, uri);
          if (tsconfig) {
            const project2 = await getOrCreateConfiguredProject(server2, tsconfig);
            return project2.languageService;
          }
          const workspaceFolder = getWorkspaceFolder(uri, server2.workspaceFolders);
          const project = await getOrCreateInferredProject(server2, uri, workspaceFolder);
          return project.languageService;
        },
        async getExistingLanguageServices() {
          const projects = await Promise.all([
            ...configProjects.values() ?? [],
            ...inferredProjects.values() ?? []
          ]);
          return projects.map((project) => project.languageService);
        },
        reload() {
          for (const project of [
            ...configProjects.values() ?? [],
            ...inferredProjects.values() ?? []
          ]) {
            project.then((p) => p.dispose());
          }
          configProjects.clear();
          inferredProjects.clear();
        }
      };
      async function findMatchTSConfig(server3, uri) {
        const fileName = uriConverter.asFileName(uri);
        let dir = path3.dirname(fileName);
        while (true) {
          if (searchedDirs.has(dir)) {
            break;
          }
          searchedDirs.add(dir);
          for (const tsConfigName of rootTsConfigNames) {
            const tsconfigPath = path3.join(dir, tsConfigName);
            if ((await server3.fileSystem.stat?.(uriConverter.asUri(tsconfigPath)))?.type === language_service_1.FileType.File) {
              rootTsConfigs.add(tsconfigPath);
            }
          }
          dir = path3.dirname(dir);
        }
        await prepareClosestootCommandLine();
        return await findDirectIncludeTsconfig() ?? await findIndirectReferenceTsconfig();
        async function prepareClosestootCommandLine() {
          let matches = [];
          for (const rootTsConfig of rootTsConfigs) {
            if (isFileInDir(fileName, path3.dirname(rootTsConfig))) {
              matches.push(rootTsConfig);
            }
          }
          matches = matches.sort((a, b) => sortTSConfigs(fileName, a, b));
          if (matches.length) {
            await getCommandLine(matches[0]);
          }
        }
        function findIndirectReferenceTsconfig() {
          return findTSConfig(async (tsconfig) => {
            const tsconfigUri = uriConverter.asUri(tsconfig);
            const project = await configProjects.get(tsconfigUri);
            const languageService = project?.languageService.context.inject("typescript/languageService");
            return !!languageService?.getProgram()?.getSourceFile(fileName);
          });
        }
        function findDirectIncludeTsconfig() {
          return findTSConfig(async (tsconfig) => {
            const map = (0, language_service_1.createUriMap)();
            const commandLine = await getCommandLine(tsconfig);
            for (const fileName2 of commandLine?.fileNames ?? []) {
              const uri2 = uriConverter.asUri(fileName2);
              map.set(uri2, true);
            }
            return map.has(uri);
          });
        }
        async function findTSConfig(match) {
          const checked = /* @__PURE__ */ new Set();
          for (const rootTsConfig of [...rootTsConfigs].sort((a, b) => sortTSConfigs(fileName, a, b))) {
            const tsconfigUri = uriConverter.asUri(rootTsConfig);
            const project = await configProjects.get(tsconfigUri);
            if (project) {
              let chains = await getReferencesChains(project.getCommandLine(), rootTsConfig, []);
              chains = chains.reverse();
              for (const chain of chains) {
                for (let i = chain.length - 1; i >= 0; i--) {
                  const tsconfig = chain[i];
                  if (checked.has(tsconfig)) {
                    continue;
                  }
                  checked.add(tsconfig);
                  if (await match(tsconfig)) {
                    return tsconfig;
                  }
                }
              }
            }
          }
        }
        async function getReferencesChains(commandLine, tsConfig, before) {
          if (commandLine.projectReferences?.length) {
            const newChains = [];
            for (const projectReference of commandLine.projectReferences) {
              let tsConfigPath = projectReference.path.replace(/\\/g, "/");
              if ((await server3.fileSystem.stat?.(uriConverter.asUri(tsConfigPath)))?.type === language_service_1.FileType.File) {
                const newTsConfigPath = path3.join(tsConfigPath, "tsconfig.json");
                const newJsConfigPath = path3.join(tsConfigPath, "jsconfig.json");
                if ((await server3.fileSystem.stat?.(uriConverter.asUri(newTsConfigPath)))?.type === language_service_1.FileType.File) {
                  tsConfigPath = newTsConfigPath;
                } else if ((await server3.fileSystem.stat?.(uriConverter.asUri(newJsConfigPath)))?.type === language_service_1.FileType.File) {
                  tsConfigPath = newJsConfigPath;
                }
              }
              const beforeIndex = before.indexOf(tsConfigPath);
              if (beforeIndex >= 0) {
                newChains.push(before.slice(0, Math.max(beforeIndex, 1)));
              } else {
                const referenceCommandLine = await getCommandLine(tsConfigPath);
                if (referenceCommandLine) {
                  for (const chain of await getReferencesChains(referenceCommandLine, tsConfigPath, [...before, tsConfig])) {
                    newChains.push(chain);
                  }
                }
              }
            }
            return newChains;
          } else {
            return [[...before, tsConfig]];
          }
        }
        async function getCommandLine(tsConfig) {
          const project = await getOrCreateConfiguredProject(server3, tsConfig);
          return project?.getCommandLine();
        }
      }
      function getOrCreateConfiguredProject(server3, tsconfig) {
        tsconfig = tsconfig.replace(/\\/g, "/");
        const tsconfigUri = uriConverter.asUri(tsconfig);
        let projectPromise = configProjects.get(tsconfigUri);
        if (!projectPromise) {
          const workspaceFolder = getWorkspaceFolder(tsconfigUri, server3.workspaceFolders);
          const serviceEnv = (0, simpleProject_1.createLanguageServiceEnvironment)(server3, [workspaceFolder]);
          projectPromise = (0, typescriptProjectLs_1.createTypeScriptLS)(ts, tsLocalized, tsconfig, server3, serviceEnv, workspaceFolder, uriConverter, create);
          configProjects.set(tsconfigUri, projectPromise);
        }
        return projectPromise;
      }
      async function getOrCreateInferredProject(server3, uri, workspaceFolder) {
        if (!inferredProjects.has(workspaceFolder)) {
          inferredProjects.set(workspaceFolder, (async () => {
            const inferOptions = await (0, inferredCompilerOptions_1.getInferredCompilerOptions)(server3);
            const serviceEnv = (0, simpleProject_1.createLanguageServiceEnvironment)(server3, [workspaceFolder]);
            return (0, typescriptProjectLs_1.createTypeScriptLS)(ts, tsLocalized, inferOptions, server3, serviceEnv, workspaceFolder, uriConverter, create);
          })());
        }
        const project = await inferredProjects.get(workspaceFolder);
        project.tryAddFile(uriConverter.asFileName(uri));
        return project;
      }
    }
    function createUriConverter(rootFolders) {
      const encodeds = /* @__PURE__ */ new Map();
      const isFileScheme = rootFolders.every((folder) => folder.scheme === "file");
      const fragmentPrefix = "/" + encodeURIComponent("#");
      return {
        asFileName,
        asUri
      };
      function asFileName(parsed) {
        if (rootFolders.every((folder) => folder.scheme === parsed.scheme && folder.authority === parsed.authority)) {
          if (isFileScheme) {
            return parsed.fsPath.replace(/\\/g, "/");
          } else {
            return parsed.path;
          }
        }
        const encoded = encodeURIComponent(`${parsed.scheme}://${parsed.authority}`);
        encodeds.set(encoded, parsed);
        const fragment = parsed.fragment ? fragmentPrefix + encodeURIComponent(parsed.fragment) : "";
        return `/${encoded}${parsed.path}${fragment}`;
      }
      function asUri(fileName) {
        for (const [encoded, uri] of encodeds) {
          const prefix = `/${encoded}`;
          if (fileName === prefix) {
            return vscode_uri_1.URI.from({
              scheme: uri.scheme,
              authority: uri.authority
            });
          }
          if (uri.authority) {
            if (fileName.startsWith(prefix + "/")) {
              return vscode_uri_1.URI.from({
                scheme: uri.scheme,
                authority: uri.authority,
                ...getComponents(fileName, prefix.length)
              });
            }
          } else {
            if (fileName.startsWith(prefix)) {
              return vscode_uri_1.URI.from({
                scheme: uri.scheme,
                authority: uri.authority,
                ...getComponents(fileName, prefix.length)
              });
            }
          }
        }
        if (!isFileScheme) {
          for (const folder of rootFolders) {
            return vscode_uri_1.URI.parse(`${folder.scheme}://${folder.authority}${fileName}`);
          }
        }
        return vscode_uri_1.URI.file(fileName);
      }
      function getComponents(fileName, prefixLength) {
        const fragmentPosition = fileName.lastIndexOf(fragmentPrefix);
        if (fragmentPosition >= prefixLength) {
          if (fileName.indexOf("/", fragmentPosition + fragmentPrefix.length) < 0) {
            return {
              path: fileName.substring(prefixLength, fragmentPosition),
              fragment: decodeURIComponent(fileName.substring(fragmentPosition + fragmentPrefix.length))
            };
          }
        }
        return {
          path: fileName.substring(prefixLength)
        };
      }
    }
    function sortTSConfigs(file, a, b) {
      const inA = isFileInDir(file, path3.dirname(a));
      const inB = isFileInDir(file, path3.dirname(b));
      if (inA !== inB) {
        const aWeight = inA ? 1 : 0;
        const bWeight = inB ? 1 : 0;
        return bWeight - aWeight;
      }
      const aLength = a.split("/").length;
      const bLength = b.split("/").length;
      if (aLength === bLength) {
        const aWeight = path3.basename(a) === "tsconfig.json" ? 1 : 0;
        const bWeight = path3.basename(b) === "tsconfig.json" ? 1 : 0;
        return bWeight - aWeight;
      }
      return bLength - aLength;
    }
    function isFileInDir(fileName, dir) {
      const relative = path3.relative(dir, fileName);
      return !!relative && !relative.startsWith("..") && !path3.isAbsolute(relative);
    }
    function getWorkspaceFolder(uri, workspaceFolders) {
      while (true) {
        if (workspaceFolders.has(uri)) {
          return uri;
        }
        const next = uri.with({ path: uri.path.substring(0, uri.path.lastIndexOf("/")) });
        if (next.path === uri.path) {
          break;
        }
        uri = next;
      }
      for (const folder of workspaceFolders.all) {
        return folder;
      }
      return uri.with({ path: "/" });
    }
  }
});

// node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/node.js
var require_node5 = __commonJS({
  "node_modules/.pnpm/@volar+language-server@2.4.26/node_modules/@volar/language-server/node.js"(exports, module) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConnection = createConnection;
    exports.createServer = createServer;
    exports.loadTsdkByPath = loadTsdkByPath;
    var vscode = require_node3();
    var http_1 = require_http();
    var node_1 = require_node4();
    var server_1 = require_server2();
    __exportStar(require_node3(), exports);
    __exportStar(require_language_server(), exports);
    __exportStar(require_simpleProject(), exports);
    __exportStar(require_typescriptProject(), exports);
    __exportStar(require_server2(), exports);
    function createConnection() {
      return vscode.createConnection(vscode.ProposedFeatures.all);
    }
    function createServer(connection2) {
      const server2 = (0, server_1.createServerBase)(connection2, {
        timer: {
          setImmediate
        }
      });
      server2.fileSystem.install("file", node_1.provider);
      server2.fileSystem.install("http", http_1.provider);
      server2.fileSystem.install("https", http_1.provider);
      server2.onInitialized(() => (0, http_1.listenEditorSettings)(server2));
      return server2;
    }
    function loadTsdkByPath(tsdk, locale) {
      locale = locale?.toLowerCase();
      const _require = eval("require");
      return {
        typescript: loadLib(),
        diagnosticMessages: loadLocalizedDiagnosticMessages()
      };
      function loadLib() {
        for (const name of ["./typescript.js", "./tsserverlibrary.js"]) {
          try {
            return _require(_require.resolve(name, { paths: [tsdk] }));
          } catch {
          }
        }
        for (const name of ["typescript.js", "tsserverlibrary.js"]) {
          try {
            return _require(tsdk + "/" + name);
          } catch {
          }
        }
        throw new Error(`Can't find typescript.js or tsserverlibrary.js in ${JSON.stringify(tsdk)}`);
      }
      function loadLocalizedDiagnosticMessages() {
        if (locale === "en") {
          return;
        }
        try {
          const path3 = _require.resolve(`./${locale}/diagnosticMessages.generated.json`, { paths: [tsdk] });
          return _require(path3);
        } catch {
        }
      }
    }
  }
});

// node_modules/.pnpm/vscode-html-languageservice@5.6.1/node_modules/vscode-html-languageservice/lib/umd/htmlLanguageService.js
var require_htmlLanguageService = __commonJS({
  "node_modules/.pnpm/vscode-html-languageservice@5.6.1/node_modules/vscode-html-languageservice/lib/umd/htmlLanguageService.js"(exports2, module2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./parser/htmlScanner", "./parser/htmlParser", "./services/htmlCompletion", "./services/htmlHover", "./services/htmlFormatter", "./services/htmlLinks", "./services/htmlHighlighting", "./services/htmlSymbolsProvider", "./services/htmlRename", "./services/htmlMatchingTagPosition", "./services/htmlLinkedEditing", "./services/htmlFolding", "./services/htmlSelectionRange", "./languageFacts/dataProvider", "./languageFacts/dataManager", "./languageFacts/data/webCustomData", "./htmlLanguageTypes"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.getLanguageService = getLanguageService;
      exports3.newHTMLDataProvider = newHTMLDataProvider;
      exports3.getDefaultHTMLDataProvider = getDefaultHTMLDataProvider;
      const htmlScanner_1 = require2("./parser/htmlScanner");
      const htmlParser_1 = require2("./parser/htmlParser");
      const htmlCompletion_1 = require2("./services/htmlCompletion");
      const htmlHover_1 = require2("./services/htmlHover");
      const htmlFormatter_1 = require2("./services/htmlFormatter");
      const htmlLinks_1 = require2("./services/htmlLinks");
      const htmlHighlighting_1 = require2("./services/htmlHighlighting");
      const htmlSymbolsProvider_1 = require2("./services/htmlSymbolsProvider");
      const htmlRename_1 = require2("./services/htmlRename");
      const htmlMatchingTagPosition_1 = require2("./services/htmlMatchingTagPosition");
      const htmlLinkedEditing_1 = require2("./services/htmlLinkedEditing");
      const htmlFolding_1 = require2("./services/htmlFolding");
      const htmlSelectionRange_1 = require2("./services/htmlSelectionRange");
      const dataProvider_1 = require2("./languageFacts/dataProvider");
      const dataManager_1 = require2("./languageFacts/dataManager");
      const webCustomData_1 = require2("./languageFacts/data/webCustomData");
      __exportStar2(require2("./htmlLanguageTypes"), exports3);
      const defaultLanguageServiceOptions = {};
      function getLanguageService(options = defaultLanguageServiceOptions) {
        const dataManager = new dataManager_1.HTMLDataManager(options);
        const htmlHover = new htmlHover_1.HTMLHover(options, dataManager);
        const htmlCompletion = new htmlCompletion_1.HTMLCompletion(options, dataManager);
        const htmlParser = new htmlParser_1.HTMLParser(dataManager);
        const htmlSelectionRange = new htmlSelectionRange_1.HTMLSelectionRange(htmlParser);
        const htmlFolding = new htmlFolding_1.HTMLFolding(dataManager);
        const htmlDocumentLinks = new htmlLinks_1.HTMLDocumentLinks(dataManager);
        return {
          setDataProviders: dataManager.setDataProviders.bind(dataManager),
          createScanner: htmlScanner_1.createScanner,
          parseHTMLDocument: htmlParser.parseDocument.bind(htmlParser),
          doComplete: htmlCompletion.doComplete.bind(htmlCompletion),
          doComplete2: htmlCompletion.doComplete2.bind(htmlCompletion),
          setCompletionParticipants: htmlCompletion.setCompletionParticipants.bind(htmlCompletion),
          doHover: htmlHover.doHover.bind(htmlHover),
          format: htmlFormatter_1.format,
          findDocumentHighlights: htmlHighlighting_1.findDocumentHighlights,
          findDocumentLinks: htmlDocumentLinks.findDocumentLinks.bind(htmlDocumentLinks),
          findDocumentSymbols: htmlSymbolsProvider_1.findDocumentSymbols,
          findDocumentSymbols2: htmlSymbolsProvider_1.findDocumentSymbols2,
          getFoldingRanges: htmlFolding.getFoldingRanges.bind(htmlFolding),
          getSelectionRanges: htmlSelectionRange.getSelectionRanges.bind(htmlSelectionRange),
          doQuoteComplete: htmlCompletion.doQuoteComplete.bind(htmlCompletion),
          doTagComplete: htmlCompletion.doTagComplete.bind(htmlCompletion),
          doRename: htmlRename_1.doRename,
          findMatchingTagPosition: htmlMatchingTagPosition_1.findMatchingTagPosition,
          findOnTypeRenameRanges: htmlLinkedEditing_1.findLinkedEditingRanges,
          findLinkedEditingRanges: htmlLinkedEditing_1.findLinkedEditingRanges
        };
      }
      function newHTMLDataProvider(id, customData) {
        return new dataProvider_1.HTMLDataProvider(id, customData);
      }
      function getDefaultHTMLDataProvider() {
        return newHTMLDataProvider("default", webCustomData_1.htmlData);
      }
    });
  }
});

// node_modules/.pnpm/volar-service-html@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-html/index.js
var require_volar_service_html = __commonJS({
  "node_modules/.pnpm/volar-service-html@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-html/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveReference = resolveReference;
    exports2.create = create;
    var html = require_htmlLanguageService();
    var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
    var vscode_uri_1 = require_umd();
    function resolveReference(ref, baseUri, workspaceFolders) {
      if (ref.match(/^\w[\w\d+.-]*:/)) {
        return ref;
      }
      if (ref[0] === "/") {
        const folderUri = getRootFolder();
        if (folderUri) {
          return folderUri + ref.substr(1);
        }
      }
      const baseUriDir = baseUri.path.endsWith("/") ? baseUri : vscode_uri_1.Utils.dirname(baseUri);
      return vscode_uri_1.Utils.resolvePath(baseUriDir, ref).toString(true);
      function getRootFolder() {
        for (const folder of workspaceFolders) {
          let folderURI = folder.toString();
          if (!folderURI.endsWith("/")) {
            folderURI = folderURI + "/";
          }
          if (baseUri.toString().startsWith(folderURI)) {
            return folderURI;
          }
        }
      }
    }
    function create({ documentSelector = ["html"], configurationSections = {
      autoCreateQuotes: "html.autoCreateQuotes",
      autoClosingTags: "html.autoClosingTags"
    }, useDefaultDataProvider = true, getDocumentContext = (context) => {
      return {
        resolveReference(ref, base) {
          let baseUri = vscode_uri_1.URI.parse(base);
          const decoded = context.decodeEmbeddedDocumentUri(baseUri);
          if (decoded) {
            baseUri = decoded[0];
          }
          return resolveReference(ref, baseUri, context.env.workspaceFolders);
        }
      };
    }, isFormattingEnabled = async (_document, context) => {
      return await context.env.getConfiguration?.("html.format.enable") ?? true;
    }, getFormattingOptions = async (_document, options, context) => {
      const formatSettings = {
        ...options,
        endWithNewline: options.insertFinalNewline ? true : options.trimFinalNewlines ? false : void 0,
        ...await context.env.getConfiguration?.("html.format")
      };
      if (formatSettings.contentUnformatted) {
        formatSettings.contentUnformatted = formatSettings.contentUnformatted + ",script";
      } else {
        formatSettings.contentUnformatted = "script";
      }
      return formatSettings;
    }, getCompletionConfiguration = async (_document, context) => {
      return await context.env.getConfiguration?.("html.completion");
    }, getHoverSettings = async (_document, context) => {
      return await context.env.getConfiguration?.("html.hover");
    }, getCustomData = async (context) => {
      const customData = await context.env.getConfiguration?.("html.customData") ?? [];
      const newData = [];
      for (const customDataPath of customData) {
        for (const workspaceFolder of context.env.workspaceFolders) {
          const uri = vscode_uri_1.Utils.resolvePath(workspaceFolder, customDataPath);
          const json = await context.env.fs?.readFile?.(uri);
          if (json) {
            try {
              const data = JSON.parse(json);
              newData.push(html.newHTMLDataProvider(customDataPath, data));
            } catch (error) {
              console.error(error);
            }
            break;
          }
        }
      }
      return newData;
    }, onDidChangeCustomData = (listener, context) => {
      const disposable = context.env.onDidChangeConfiguration?.(listener);
      return {
        dispose() {
          disposable?.dispose();
        }
      };
    } } = {}) {
      return {
        name: "html",
        capabilities: {
          completionProvider: {
            // https://github.com/microsoft/vscode/blob/09850876e652688fb142e2e19fd00fd38c0bc4ba/extensions/html-language-features/server/src/htmlServer.ts#L183
            triggerCharacters: [".", ":", "<", '"', "=", "/"]
          },
          renameProvider: {
            prepareProvider: true
          },
          hoverProvider: true,
          documentHighlightProvider: true,
          documentLinkProvider: {},
          documentSymbolProvider: true,
          foldingRangeProvider: true,
          selectionRangeProvider: true,
          documentFormattingProvider: true,
          linkedEditingRangeProvider: true,
          autoInsertionProvider: {
            triggerCharacters: ["=", ">", "/"],
            configurationSections: [
              configurationSections.autoCreateQuotes,
              configurationSections.autoClosingTags,
              configurationSections.autoClosingTags
            ]
          }
        },
        create(context) {
          const htmlDocuments = /* @__PURE__ */ new WeakMap();
          const fileSystemProvider = {
            stat: async (uri) => await context.env.fs?.stat(vscode_uri_1.URI.parse(uri)) ?? { type: html.FileType.Unknown, ctime: 0, mtime: 0, size: 0 },
            readDirectory: async (uri) => await context.env.fs?.readDirectory(vscode_uri_1.URI.parse(uri)) ?? []
          };
          const documentContext = getDocumentContext(context);
          const htmlLs = html.getLanguageService({
            fileSystemProvider,
            clientCapabilities: context.env.clientCapabilities,
            useDefaultDataProvider
          });
          const disposable = onDidChangeCustomData(() => initializing = void 0, context);
          let initializing;
          return {
            dispose() {
              disposable.dispose();
            },
            provide: {
              "html/htmlDocument": (document) => {
                if (matchDocument(documentSelector, document)) {
                  return getHtmlDocument(document);
                }
              },
              "html/languageService": () => htmlLs,
              "html/documentContext": () => documentContext
            },
            async provideCompletionItems(document, position) {
              return worker(document, async (htmlDocument) => {
                const configs = await getCompletionConfiguration(document, context);
                return htmlLs.doComplete2(document, position, htmlDocument, documentContext, configs);
              });
            },
            provideRenameRange(document, position) {
              return worker(document, (htmlDocument) => {
                const offset = document.offsetAt(position);
                return htmlLs.findDocumentHighlights(document, position, htmlDocument)?.find((h) => offset >= document.offsetAt(h.range.start) && offset <= document.offsetAt(h.range.end))?.range;
              });
            },
            provideRenameEdits(document, position, newName) {
              return worker(document, (htmlDocument) => {
                return htmlLs.doRename(document, position, newName, htmlDocument);
              });
            },
            async provideHover(document, position) {
              return worker(document, async (htmlDocument) => {
                const hoverSettings = await getHoverSettings(document, context);
                return htmlLs.doHover(document, position, htmlDocument, hoverSettings);
              });
            },
            provideDocumentHighlights(document, position) {
              return worker(document, (htmlDocument) => {
                return htmlLs.findDocumentHighlights(document, position, htmlDocument);
              });
            },
            provideDocumentLinks(document) {
              return worker(document, () => {
                return htmlLs.findDocumentLinks(document, documentContext);
              });
            },
            provideDocumentSymbols(document) {
              return worker(document, (htmlDocument) => {
                return htmlLs.findDocumentSymbols2(document, htmlDocument);
              });
            },
            provideFoldingRanges(document) {
              return worker(document, () => {
                return htmlLs.getFoldingRanges(document, context.env.clientCapabilities?.textDocument?.foldingRange);
              });
            },
            provideSelectionRanges(document, positions) {
              return worker(document, () => {
                return htmlLs.getSelectionRanges(document, positions);
              });
            },
            async provideDocumentFormattingEdits(document, formatRange, options, codeOptions) {
              return worker(document, async () => {
                if (!await isFormattingEnabled(document, context)) {
                  return;
                }
                const endPos = formatRange.end;
                let endOffset = document.offsetAt(endPos);
                const content = document.getText();
                if (endPos.character === 0 && endPos.line > 0 && endOffset !== content.length) {
                  const prevLineStart = document.offsetAt({ line: endPos.line - 1, character: 0 });
                  while (isEOL2(content, endOffset - 1) && endOffset > prevLineStart) {
                    endOffset--;
                  }
                  formatRange = {
                    start: formatRange.start,
                    end: document.positionAt(endOffset)
                  };
                }
                const formatSettings = await getFormattingOptions(document, options, context);
                let formatDocument = document;
                let prefixes = [];
                let suffixes = [];
                if (codeOptions?.initialIndentLevel) {
                  for (let i = 0; i < codeOptions.initialIndentLevel; i++) {
                    if (i === codeOptions.initialIndentLevel - 1) {
                      prefixes.push("<template>");
                      suffixes.unshift("</template>");
                    } else {
                      prefixes.push("<template>\n");
                      suffixes.unshift("\n</template>");
                    }
                  }
                  formatDocument = vscode_languageserver_textdocument_1.TextDocument.create(document.uri, document.languageId, document.version, prefixes.join("") + document.getText() + suffixes.join(""));
                  formatRange = {
                    start: formatDocument.positionAt(0),
                    end: formatDocument.positionAt(formatDocument.getText().length)
                  };
                }
                let edits = htmlLs.format(formatDocument, formatRange, formatSettings);
                if (codeOptions) {
                  let newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(formatDocument, edits);
                  for (const prefix of prefixes) {
                    newText = newText.trimStart().slice(prefix.trim().length);
                  }
                  for (const suffix of suffixes.reverse()) {
                    newText = newText.trimEnd().slice(0, -suffix.trim().length);
                  }
                  if (!codeOptions.initialIndentLevel && codeOptions.level > 0) {
                    newText = ensureNewLines(newText);
                  }
                  edits = [{
                    range: {
                      start: document.positionAt(0),
                      end: document.positionAt(document.getText().length)
                    },
                    newText
                  }];
                }
                return edits;
                function ensureNewLines(newText) {
                  const verifyDocument = vscode_languageserver_textdocument_1.TextDocument.create(document.uri, document.languageId, document.version, "<template>" + newText + "</template>");
                  const verifyEdits = htmlLs.format(verifyDocument, void 0, formatSettings);
                  let verifyText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(verifyDocument, verifyEdits);
                  verifyText = verifyText.trim().slice("<template>".length, -"</template>".length);
                  if (startWithNewLine(verifyText) !== startWithNewLine(newText)) {
                    if (startWithNewLine(verifyText)) {
                      newText = "\n" + newText;
                    } else if (newText.startsWith("\n")) {
                      newText = newText.slice(1);
                    } else if (newText.startsWith("\r\n")) {
                      newText = newText.slice(2);
                    }
                  }
                  if (endWithNewLine(verifyText) !== endWithNewLine(newText)) {
                    if (endWithNewLine(verifyText)) {
                      newText = newText + "\n";
                    } else if (newText.endsWith("\n")) {
                      newText = newText.slice(0, -1);
                    } else if (newText.endsWith("\r\n")) {
                      newText = newText.slice(0, -2);
                    }
                  }
                  return newText;
                }
                function startWithNewLine(text) {
                  return text.startsWith("\n") || text.startsWith("\r\n");
                }
                function endWithNewLine(text) {
                  return text.endsWith("\n") || text.endsWith("\r\n");
                }
              });
            },
            provideLinkedEditingRanges(document, position) {
              return worker(document, (htmlDocument) => {
                const ranges = htmlLs.findLinkedEditingRanges(document, position, htmlDocument);
                if (!ranges) {
                  return;
                }
                return { ranges };
              });
            },
            async provideAutoInsertSnippet(document, selection, lastChange) {
              if (document.offsetAt(selection) !== lastChange.rangeOffset + lastChange.text.length) {
                return;
              }
              return worker(document, async (htmlDocument) => {
                if (lastChange.rangeLength === 0 && !/\n/.test(lastChange.text)) {
                  if (lastChange.text.endsWith("=")) {
                    const enabled = await context.env.getConfiguration?.(configurationSections.autoCreateQuotes) ?? true;
                    if (enabled) {
                      const completionConfiguration = await getCompletionConfiguration(document, context);
                      const text = htmlLs.doQuoteComplete(document, selection, htmlDocument, completionConfiguration);
                      return text ?? void 0;
                    }
                  }
                  if (lastChange.text.endsWith(">") || lastChange.text.endsWith("/")) {
                    const enabled = await context.env.getConfiguration?.(configurationSections.autoClosingTags) ?? true;
                    if (enabled) {
                      const text = htmlLs.doTagComplete(document, selection, htmlDocument);
                      return text ?? void 0;
                    }
                  }
                }
              });
            }
          };
          function getHtmlDocument(document) {
            const cache = htmlDocuments.get(document);
            if (cache) {
              const [cacheVersion, cacheDoc] = cache;
              if (cacheVersion === document.version) {
                return cacheDoc;
              }
            }
            const doc = htmlLs.parseHTMLDocument(document);
            htmlDocuments.set(document, [document.version, doc]);
            return doc;
          }
          async function worker(document, callback) {
            if (!matchDocument(documentSelector, document)) {
              return;
            }
            const htmlDocument = getHtmlDocument(document);
            if (!htmlDocument) {
              return;
            }
            await (initializing ??= initialize());
            return callback(htmlDocument);
          }
          async function initialize() {
            const customData = await getCustomData(context);
            htmlLs.setDataProviders(useDefaultDataProvider, customData);
          }
        }
      };
    }
    function isEOL2(content, offset) {
      return isNewlineCharacter(content.charCodeAt(offset));
    }
    var CR = "\r".charCodeAt(0);
    var NL = "\n".charCodeAt(0);
    function isNewlineCharacter(charCode) {
      return charCode === CR || charCode === NL;
    }
    function matchDocument(selector, document) {
      for (const sel of selector) {
        if (sel === document.languageId || typeof sel === "object" && sel.language === document.languageId) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/.pnpm/vscode-css-languageservice@6.3.9/node_modules/vscode-css-languageservice/lib/umd/cssLanguageService.js
var require_cssLanguageService = __commonJS({
  "node_modules/.pnpm/vscode-css-languageservice@6.3.9/node_modules/vscode-css-languageservice/lib/umd/cssLanguageService.js"(exports2, module2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./parser/cssParser", "./services/cssCompletion", "./services/cssHover", "./services/cssNavigation", "./services/cssCodeActions", "./services/cssValidation", "./parser/scssParser", "./services/scssCompletion", "./parser/lessParser", "./services/lessCompletion", "./services/cssFolding", "./services/cssFormatter", "./languageFacts/dataManager", "./languageFacts/dataProvider", "./services/cssSelectionRange", "./services/scssNavigation", "./data/webCustomData", "./cssLanguageTypes"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.getDefaultCSSDataProvider = getDefaultCSSDataProvider;
      exports3.newCSSDataProvider = newCSSDataProvider;
      exports3.getCSSLanguageService = getCSSLanguageService;
      exports3.getSCSSLanguageService = getSCSSLanguageService;
      exports3.getLESSLanguageService = getLESSLanguageService;
      const cssParser_1 = require2("./parser/cssParser");
      const cssCompletion_1 = require2("./services/cssCompletion");
      const cssHover_1 = require2("./services/cssHover");
      const cssNavigation_1 = require2("./services/cssNavigation");
      const cssCodeActions_1 = require2("./services/cssCodeActions");
      const cssValidation_1 = require2("./services/cssValidation");
      const scssParser_1 = require2("./parser/scssParser");
      const scssCompletion_1 = require2("./services/scssCompletion");
      const lessParser_1 = require2("./parser/lessParser");
      const lessCompletion_1 = require2("./services/lessCompletion");
      const cssFolding_1 = require2("./services/cssFolding");
      const cssFormatter_1 = require2("./services/cssFormatter");
      const dataManager_1 = require2("./languageFacts/dataManager");
      const dataProvider_1 = require2("./languageFacts/dataProvider");
      const cssSelectionRange_1 = require2("./services/cssSelectionRange");
      const scssNavigation_1 = require2("./services/scssNavigation");
      const webCustomData_1 = require2("./data/webCustomData");
      __exportStar2(require2("./cssLanguageTypes"), exports3);
      function getDefaultCSSDataProvider() {
        return newCSSDataProvider(webCustomData_1.cssData);
      }
      function newCSSDataProvider(data) {
        return new dataProvider_1.CSSDataProvider(data);
      }
      function createFacade(parser, completion, hover, navigation, codeActions, validation, cssDataManager) {
        return {
          configure: (settings) => {
            validation.configure(settings);
            completion.configure(settings?.completion);
            hover.configure(settings?.hover);
            navigation.configure(settings?.importAliases);
          },
          setDataProviders: cssDataManager.setDataProviders.bind(cssDataManager),
          doValidation: validation.doValidation.bind(validation),
          parseStylesheet: parser.parseStylesheet.bind(parser),
          doComplete: completion.doComplete.bind(completion),
          doComplete2: completion.doComplete2.bind(completion),
          setCompletionParticipants: completion.setCompletionParticipants.bind(completion),
          doHover: hover.doHover.bind(hover),
          format: cssFormatter_1.format,
          findDefinition: navigation.findDefinition.bind(navigation),
          findReferences: navigation.findReferences.bind(navigation),
          findDocumentHighlights: navigation.findDocumentHighlights.bind(navigation),
          findDocumentLinks: navigation.findDocumentLinks.bind(navigation),
          findDocumentLinks2: navigation.findDocumentLinks2.bind(navigation),
          findDocumentSymbols: navigation.findSymbolInformations.bind(navigation),
          findDocumentSymbols2: navigation.findDocumentSymbols.bind(navigation),
          doCodeActions: codeActions.doCodeActions.bind(codeActions),
          doCodeActions2: codeActions.doCodeActions2.bind(codeActions),
          findDocumentColors: navigation.findDocumentColors.bind(navigation),
          getColorPresentations: navigation.getColorPresentations.bind(navigation),
          prepareRename: navigation.prepareRename.bind(navigation),
          doRename: navigation.doRename.bind(navigation),
          getFoldingRanges: cssFolding_1.getFoldingRanges,
          getSelectionRanges: cssSelectionRange_1.getSelectionRanges
        };
      }
      const defaultLanguageServiceOptions = {};
      function getCSSLanguageService(options = defaultLanguageServiceOptions) {
        const cssDataManager = new dataManager_1.CSSDataManager(options);
        return createFacade(new cssParser_1.Parser(), new cssCompletion_1.CSSCompletion(null, options, cssDataManager), new cssHover_1.CSSHover(options && options.clientCapabilities, cssDataManager), new cssNavigation_1.CSSNavigation(options && options.fileSystemProvider, false), new cssCodeActions_1.CSSCodeActions(cssDataManager), new cssValidation_1.CSSValidation(cssDataManager), cssDataManager);
      }
      function getSCSSLanguageService(options = defaultLanguageServiceOptions) {
        const cssDataManager = new dataManager_1.CSSDataManager(options);
        return createFacade(new scssParser_1.SCSSParser(), new scssCompletion_1.SCSSCompletion(options, cssDataManager), new cssHover_1.CSSHover(options && options.clientCapabilities, cssDataManager), new scssNavigation_1.SCSSNavigation(options && options.fileSystemProvider), new cssCodeActions_1.CSSCodeActions(cssDataManager), new cssValidation_1.CSSValidation(cssDataManager), cssDataManager);
      }
      function getLESSLanguageService(options = defaultLanguageServiceOptions) {
        const cssDataManager = new dataManager_1.CSSDataManager(options);
        return createFacade(new lessParser_1.LESSParser(), new lessCompletion_1.LESSCompletion(options, cssDataManager), new cssHover_1.CSSHover(options && options.clientCapabilities, cssDataManager), new cssNavigation_1.CSSNavigation(options && options.fileSystemProvider, true), new cssCodeActions_1.CSSCodeActions(cssDataManager), new cssValidation_1.CSSValidation(cssDataManager), cssDataManager);
      }
    });
  }
});

// node_modules/.pnpm/volar-service-css@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-css/index.js
var require_volar_service_css = __commonJS({
  "node_modules/.pnpm/volar-service-css@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-css/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveReference = resolveReference;
    exports2.create = create;
    var css = require_cssLanguageService();
    var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
    var vscode_uri_1 = require_umd();
    function resolveReference(ref, baseUri, workspaceFolders) {
      if (ref.match(/^\w[\w\d+.-]*:/)) {
        return ref;
      }
      if (ref[0] === "/") {
        const folderUri = getRootFolder();
        if (folderUri) {
          return folderUri + ref.substr(1);
        }
      }
      const baseUriDir = baseUri.path.endsWith("/") ? baseUri : vscode_uri_1.Utils.dirname(baseUri);
      return vscode_uri_1.Utils.resolvePath(baseUriDir, ref).toString(true);
      function getRootFolder() {
        for (const folder of workspaceFolders) {
          let folderURI = folder.toString();
          if (!folderURI.endsWith("/")) {
            folderURI = folderURI + "/";
          }
          if (baseUri.toString().startsWith(folderURI)) {
            return folderURI;
          }
        }
      }
    }
    function create({ cssDocumentSelector = ["css"], scssDocumentSelector = ["scss"], lessDocumentSelector = ["less"], useDefaultDataProvider = true, getDocumentContext = (context) => {
      return {
        resolveReference(ref, base) {
          let baseUri = vscode_uri_1.URI.parse(base);
          const decoded = context.decodeEmbeddedDocumentUri(baseUri);
          if (decoded) {
            baseUri = decoded[0];
          }
          return resolveReference(ref, baseUri, context.env.workspaceFolders);
        }
      };
    }, isFormattingEnabled = async (document, context) => {
      return await context.env.getConfiguration?.(document.languageId + ".format.enable") ?? true;
    }, getFormattingOptions = async (document, options, context) => {
      return {
        ...options,
        ...await context.env.getConfiguration?.(document.languageId + ".format")
      };
    }, getLanguageSettings = async (document, context) => {
      return await context.env.getConfiguration?.(document.languageId);
    }, getCustomData = async (context) => {
      const customData = await context.env.getConfiguration?.("css.customData") ?? [];
      const newData = [];
      for (const customDataPath of customData) {
        for (const workspaceFolder of context.env.workspaceFolders) {
          const uri = vscode_uri_1.Utils.resolvePath(workspaceFolder, customDataPath);
          const json = await context.env.fs?.readFile?.(uri);
          if (json) {
            try {
              const data = JSON.parse(json);
              newData.push(css.newCSSDataProvider(data));
            } catch (error) {
              console.error(error);
            }
            break;
          }
        }
      }
      return newData;
    }, onDidChangeCustomData = (listener, context) => {
      const disposable = context.env.onDidChangeConfiguration?.(listener);
      return {
        dispose() {
          disposable?.dispose();
        }
      };
    } } = {}) {
      return {
        name: "css",
        capabilities: {
          completionProvider: {
            // https://github.com/microsoft/vscode/blob/09850876e652688fb142e2e19fd00fd38c0bc4ba/extensions/css-language-features/server/src/cssServer.ts#L97
            triggerCharacters: ["/", "-", ":"]
          },
          renameProvider: {
            prepareProvider: true
          },
          codeActionProvider: {},
          definitionProvider: true,
          diagnosticProvider: {
            interFileDependencies: false,
            workspaceDiagnostics: false
          },
          hoverProvider: true,
          referencesProvider: true,
          documentHighlightProvider: true,
          documentLinkProvider: {},
          documentSymbolProvider: true,
          colorProvider: true,
          foldingRangeProvider: true,
          selectionRangeProvider: true,
          documentFormattingProvider: true
        },
        create(context) {
          const stylesheets = /* @__PURE__ */ new WeakMap();
          const fileSystemProvider = {
            stat: async (uri) => await context.env.fs?.stat(vscode_uri_1.URI.parse(uri)) ?? { type: css.FileType.Unknown, ctime: 0, mtime: 0, size: 0 },
            readDirectory: async (uri) => await context.env.fs?.readDirectory(vscode_uri_1.URI.parse(uri)) ?? []
          };
          const documentContext = getDocumentContext(context);
          const disposable = onDidChangeCustomData(() => initializing = void 0, context);
          let cssLs;
          let scssLs;
          let lessLs;
          let customData = [];
          let initializing;
          return {
            dispose() {
              disposable.dispose();
            },
            provide: {
              "css/stylesheet": getStylesheet,
              "css/languageService": getCssLs
            },
            async provideCompletionItems(document, position) {
              return worker(document, async (stylesheet, cssLs2) => {
                const settings = await getLanguageSettings(document, context);
                return await cssLs2.doComplete2(document, position, stylesheet, documentContext, settings?.completion);
              });
            },
            provideRenameRange(document, position) {
              return worker(document, (stylesheet, cssLs2) => {
                return cssLs2.prepareRename(document, position, stylesheet);
              });
            },
            provideRenameEdits(document, position, newName) {
              return worker(document, (stylesheet, cssLs2) => {
                return cssLs2.doRename(document, position, newName, stylesheet);
              });
            },
            provideCodeActions(document, range, context2) {
              return worker(document, (stylesheet, cssLs2) => {
                return cssLs2.doCodeActions2(document, range, context2, stylesheet);
              });
            },
            provideDefinition(document, position) {
              return worker(document, (stylesheet, cssLs2) => {
                const location = cssLs2.findDefinition(document, position, stylesheet);
                if (location) {
                  return [
                    {
                      targetUri: location.uri,
                      targetRange: location.range,
                      targetSelectionRange: location.range
                    }
                  ];
                }
              });
            },
            async provideDiagnostics(document) {
              return worker(document, async (stylesheet, cssLs2) => {
                const settings = await getLanguageSettings(document, context);
                return cssLs2.doValidation(document, stylesheet, settings);
              });
            },
            async provideHover(document, position) {
              return worker(document, async (stylesheet, cssLs2) => {
                const settings = await getLanguageSettings(document, context);
                return cssLs2.doHover(document, position, stylesheet, settings?.hover);
              });
            },
            provideReferences(document, position) {
              return worker(document, (stylesheet, cssLs2) => {
                return cssLs2.findReferences(document, position, stylesheet);
              });
            },
            provideDocumentHighlights(document, position) {
              return worker(document, (stylesheet, cssLs2) => {
                return cssLs2.findDocumentHighlights(document, position, stylesheet);
              });
            },
            async provideDocumentLinks(document) {
              return await worker(document, (stylesheet, cssLs2) => {
                return cssLs2.findDocumentLinks2(document, stylesheet, documentContext);
              });
            },
            provideDocumentSymbols(document) {
              return worker(document, (stylesheet, cssLs2) => {
                return cssLs2.findDocumentSymbols2(document, stylesheet);
              });
            },
            provideDocumentColors(document) {
              return worker(document, (stylesheet, cssLs2) => {
                return cssLs2.findDocumentColors(document, stylesheet);
              });
            },
            provideColorPresentations(document, color, range) {
              return worker(document, (stylesheet, cssLs2) => {
                return cssLs2.getColorPresentations(document, stylesheet, color, range);
              });
            },
            provideFoldingRanges(document) {
              return worker(document, (_stylesheet, cssLs2) => {
                return cssLs2.getFoldingRanges(document, context.env.clientCapabilities?.textDocument?.foldingRange);
              });
            },
            provideSelectionRanges(document, positions) {
              return worker(document, (stylesheet, cssLs2) => {
                return cssLs2.getSelectionRanges(document, positions, stylesheet);
              });
            },
            async provideDocumentFormattingEdits(document, formatRange, options, codeOptions) {
              return worker(document, async (_stylesheet, cssLs2) => {
                if (!await isFormattingEnabled(document, context)) {
                  return;
                }
                const formatOptions = await getFormattingOptions(document, options, context);
                let formatDocument = document;
                let prefixes = [];
                let suffixes = [];
                if (codeOptions?.initialIndentLevel) {
                  for (let i = 0; i < codeOptions.initialIndentLevel; i++) {
                    if (i === codeOptions.initialIndentLevel - 1) {
                      prefixes.push("_", "{");
                      suffixes.unshift("}");
                    } else {
                      prefixes.push("_", "{\n");
                      suffixes.unshift("\n}");
                    }
                  }
                  formatDocument = vscode_languageserver_textdocument_1.TextDocument.create(document.uri, document.languageId, document.version, prefixes.join("") + document.getText() + suffixes.join(""));
                  formatRange = {
                    start: formatDocument.positionAt(0),
                    end: formatDocument.positionAt(formatDocument.getText().length)
                  };
                }
                let edits = cssLs2.format(formatDocument, formatRange, formatOptions);
                if (codeOptions) {
                  let newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(formatDocument, edits);
                  for (const prefix of prefixes) {
                    newText = newText.trimStart().slice(prefix.trim().length);
                  }
                  for (const suffix of suffixes.reverse()) {
                    newText = newText.trimEnd().slice(0, -suffix.trim().length);
                  }
                  if (!codeOptions.initialIndentLevel && codeOptions.level > 0) {
                    newText = ensureNewLines(newText);
                  }
                  edits = [{
                    range: {
                      start: document.positionAt(0),
                      end: document.positionAt(document.getText().length)
                    },
                    newText
                  }];
                }
                return edits;
                function ensureNewLines(newText) {
                  const verifyDocument = vscode_languageserver_textdocument_1.TextDocument.create(document.uri, document.languageId, document.version, "_ {" + newText + "}");
                  const verifyEdits = cssLs2.format(verifyDocument, void 0, formatOptions);
                  let verifyText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(verifyDocument, verifyEdits);
                  verifyText = verifyText.trimStart().slice("_".length);
                  verifyText = verifyText.trim().slice("{".length, -"}".length);
                  if (startWithNewLine(verifyText) !== startWithNewLine(newText)) {
                    if (startWithNewLine(verifyText)) {
                      newText = "\n" + newText;
                    } else if (newText.startsWith("\n")) {
                      newText = newText.slice(1);
                    } else if (newText.startsWith("\r\n")) {
                      newText = newText.slice(2);
                    }
                  }
                  if (endWithNewLine(verifyText) !== endWithNewLine(newText)) {
                    if (endWithNewLine(verifyText)) {
                      newText = newText + "\n";
                    } else if (newText.endsWith("\n")) {
                      newText = newText.slice(0, -1);
                    } else if (newText.endsWith("\r\n")) {
                      newText = newText.slice(0, -2);
                    }
                  }
                  return newText;
                }
                function startWithNewLine(text) {
                  return text.startsWith("\n") || text.startsWith("\r\n");
                }
                function endWithNewLine(text) {
                  return text.endsWith("\n") || text.endsWith("\r\n");
                }
              });
            }
          };
          function getCssLs(document) {
            if (matchDocument(cssDocumentSelector, document)) {
              if (!cssLs) {
                cssLs = css.getCSSLanguageService({
                  fileSystemProvider,
                  clientCapabilities: context.env.clientCapabilities,
                  useDefaultDataProvider,
                  customDataProviders: customData
                });
                cssLs.setDataProviders(useDefaultDataProvider, customData);
              }
              return cssLs;
            } else if (matchDocument(scssDocumentSelector, document)) {
              if (!scssLs) {
                scssLs = css.getSCSSLanguageService({
                  fileSystemProvider,
                  clientCapabilities: context.env.clientCapabilities,
                  useDefaultDataProvider,
                  customDataProviders: customData
                });
                scssLs.setDataProviders(useDefaultDataProvider, customData);
              }
              return scssLs;
            } else if (matchDocument(lessDocumentSelector, document)) {
              if (!lessLs) {
                lessLs = css.getLESSLanguageService({
                  fileSystemProvider,
                  clientCapabilities: context.env.clientCapabilities,
                  useDefaultDataProvider,
                  customDataProviders: customData
                });
                lessLs.setDataProviders(useDefaultDataProvider, customData);
              }
              return lessLs;
            }
          }
          async function worker(document, callback) {
            const cssLs2 = getCssLs(document);
            if (!cssLs2) {
              return;
            }
            await (initializing ??= initialize());
            return callback(getStylesheet(document, cssLs2), cssLs2);
          }
          function getStylesheet(document, ls) {
            const cache = stylesheets.get(document);
            if (cache) {
              const [cacheVersion, cacheStylesheet] = cache;
              if (cacheVersion === document.version) {
                return cacheStylesheet;
              }
            }
            const stylesheet = ls.parseStylesheet(document);
            stylesheets.set(document, [document.version, stylesheet]);
            return stylesheet;
          }
          async function initialize() {
            customData = await getCustomData(context);
            cssLs?.setDataProviders(useDefaultDataProvider, customData);
            scssLs?.setDataProviders(useDefaultDataProvider, customData);
            lessLs?.setDataProviders(useDefaultDataProvider, customData);
          }
        }
      };
    }
    function matchDocument(selector, document) {
      for (const sel of selector) {
        if (sel === document.languageId || typeof sel === "object" && sel.language === document.languageId) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/.pnpm/vscode-nls@5.2.0/node_modules/vscode-nls/lib/common/ral.js
var require_ral2 = __commonJS({
  "node_modules/.pnpm/vscode-nls@5.2.0/node_modules/vscode-nls/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error("No runtime abstraction layer installed");
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error("No runtime abstraction layer provided");
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/.pnpm/vscode-nls@5.2.0/node_modules/vscode-nls/lib/common/common.js
var require_common3 = __commonJS({
  "node_modules/.pnpm/vscode-nls@5.2.0/node_modules/vscode-nls/lib/common/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.config = exports2.loadMessageBundle = exports2.localize = exports2.format = exports2.setPseudo = exports2.isPseudo = exports2.isDefined = exports2.BundleFormat = exports2.MessageFormat = void 0;
    var ral_1 = require_ral2();
    var MessageFormat;
    (function(MessageFormat2) {
      MessageFormat2["file"] = "file";
      MessageFormat2["bundle"] = "bundle";
      MessageFormat2["both"] = "both";
    })(MessageFormat = exports2.MessageFormat || (exports2.MessageFormat = {}));
    var BundleFormat;
    (function(BundleFormat2) {
      BundleFormat2["standalone"] = "standalone";
      BundleFormat2["languagePack"] = "languagePack";
    })(BundleFormat = exports2.BundleFormat || (exports2.BundleFormat = {}));
    var LocalizeInfo;
    (function(LocalizeInfo2) {
      function is(value) {
        var candidate = value;
        return candidate && isDefined(candidate.key) && isDefined(candidate.comment);
      }
      LocalizeInfo2.is = is;
    })(LocalizeInfo || (LocalizeInfo = {}));
    function isDefined(value) {
      return typeof value !== "undefined";
    }
    exports2.isDefined = isDefined;
    exports2.isPseudo = false;
    function setPseudo(pseudo) {
      exports2.isPseudo = pseudo;
    }
    exports2.setPseudo = setPseudo;
    function format(message, args) {
      var result;
      if (exports2.isPseudo) {
        message = "\uFF3B" + message.replace(/[aouei]/g, "$&$&") + "\uFF3D";
      }
      if (args.length === 0) {
        result = message;
      } else {
        result = message.replace(/\{(\d+)\}/g, function(match, rest) {
          var index = rest[0];
          var arg = args[index];
          var replacement = match;
          if (typeof arg === "string") {
            replacement = arg;
          } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
            replacement = String(arg);
          }
          return replacement;
        });
      }
      return result;
    }
    exports2.format = format;
    function localize(_key, message) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      return format(message, args);
    }
    exports2.localize = localize;
    function loadMessageBundle(file) {
      return (0, ral_1.default)().loadMessageBundle(file);
    }
    exports2.loadMessageBundle = loadMessageBundle;
    function config(opts) {
      return (0, ral_1.default)().config(opts);
    }
    exports2.config = config;
  }
});

// node_modules/.pnpm/vscode-nls@5.2.0/node_modules/vscode-nls/lib/node/main.js
var require_main6 = __commonJS({
  "node_modules/.pnpm/vscode-nls@5.2.0/node_modules/vscode-nls/lib/node/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.config = exports2.loadMessageBundle = exports2.BundleFormat = exports2.MessageFormat = void 0;
    var path3 = require("path");
    var fs2 = require("fs");
    var ral_1 = require_ral2();
    var common_1 = require_common3();
    var common_2 = require_common3();
    Object.defineProperty(exports2, "MessageFormat", { enumerable: true, get: function() {
      return common_2.MessageFormat;
    } });
    Object.defineProperty(exports2, "BundleFormat", { enumerable: true, get: function() {
      return common_2.BundleFormat;
    } });
    var toString = Object.prototype.toString;
    function isNumber(value) {
      return toString.call(value) === "[object Number]";
    }
    function isString(value) {
      return toString.call(value) === "[object String]";
    }
    function isBoolean(value) {
      return value === true || value === false;
    }
    function readJsonFileSync(filename) {
      return JSON.parse(fs2.readFileSync(filename, "utf8"));
    }
    var resolvedBundles;
    var options;
    function initializeSettings() {
      options = { locale: void 0, language: void 0, languagePackSupport: false, cacheLanguageResolution: true, messageFormat: common_1.MessageFormat.bundle };
      if (isString(process.env.VSCODE_NLS_CONFIG)) {
        try {
          var vscodeOptions_1 = JSON.parse(process.env.VSCODE_NLS_CONFIG);
          var language = void 0;
          if (vscodeOptions_1.availableLanguages) {
            var value = vscodeOptions_1.availableLanguages["*"];
            if (isString(value)) {
              language = value;
            }
          }
          if (isString(vscodeOptions_1.locale)) {
            options.locale = vscodeOptions_1.locale.toLowerCase();
          }
          if (language === void 0) {
            options.language = options.locale;
          } else if (language !== "en") {
            options.language = language;
          }
          if (isBoolean(vscodeOptions_1._languagePackSupport)) {
            options.languagePackSupport = vscodeOptions_1._languagePackSupport;
          }
          if (isString(vscodeOptions_1._cacheRoot)) {
            options.cacheRoot = vscodeOptions_1._cacheRoot;
          }
          if (isString(vscodeOptions_1._languagePackId)) {
            options.languagePackId = vscodeOptions_1._languagePackId;
          }
          if (isString(vscodeOptions_1._translationsConfigFile)) {
            options.translationsConfigFile = vscodeOptions_1._translationsConfigFile;
            try {
              options.translationsConfig = readJsonFileSync(options.translationsConfigFile);
            } catch (error) {
              if (vscodeOptions_1._corruptedFile) {
                var dirname2 = path3.dirname(vscodeOptions_1._corruptedFile);
                fs2.exists(dirname2, function(exists) {
                  if (exists) {
                    fs2.writeFile(vscodeOptions_1._corruptedFile, "corrupted", "utf8", function(err) {
                      console.error(err);
                    });
                  }
                });
              }
            }
          }
        } catch (_a) {
        }
      }
      (0, common_1.setPseudo)(options.locale === "pseudo");
      resolvedBundles = /* @__PURE__ */ Object.create(null);
    }
    initializeSettings();
    function supportsLanguagePack() {
      return options.languagePackSupport === true && options.cacheRoot !== void 0 && options.languagePackId !== void 0 && options.translationsConfigFile !== void 0 && options.translationsConfig !== void 0;
    }
    function createScopedLocalizeFunction(messages) {
      return function(key, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        if (isNumber(key)) {
          if (key >= messages.length) {
            console.error("Broken localize call found. Index out of bounds. Stacktrace is\n: ".concat(new Error("").stack));
            return;
          }
          return (0, common_1.format)(messages[key], args);
        } else {
          if (isString(message)) {
            console.warn("Message ".concat(message, " didn't get externalized correctly."));
            return (0, common_1.format)(message, args);
          } else {
            console.error("Broken localize call found. Stacktrace is\n: ".concat(new Error("").stack));
          }
        }
      };
    }
    function resolveLanguage(file) {
      var resolvedLanguage;
      if (options.cacheLanguageResolution && resolvedLanguage) {
        resolvedLanguage = resolvedLanguage;
      } else {
        if (common_1.isPseudo || !options.language) {
          resolvedLanguage = ".nls.json";
        } else {
          var locale2 = options.language;
          while (locale2) {
            var candidate = ".nls." + locale2 + ".json";
            if (fs2.existsSync(file + candidate)) {
              resolvedLanguage = candidate;
              break;
            } else {
              var index = locale2.lastIndexOf("-");
              if (index > 0) {
                locale2 = locale2.substring(0, index);
              } else {
                resolvedLanguage = ".nls.json";
                locale2 = null;
              }
            }
          }
        }
        if (options.cacheLanguageResolution) {
          resolvedLanguage = resolvedLanguage;
        }
      }
      return file + resolvedLanguage;
    }
    function findInTheBoxBundle(root) {
      var language = options.language;
      while (language) {
        var candidate = path3.join(root, "nls.bundle.".concat(language, ".json"));
        if (fs2.existsSync(candidate)) {
          return candidate;
        } else {
          var index = language.lastIndexOf("-");
          if (index > 0) {
            language = language.substring(0, index);
          } else {
            language = void 0;
          }
        }
      }
      if (language === void 0) {
        var candidate = path3.join(root, "nls.bundle.json");
        if (fs2.existsSync(candidate)) {
          return candidate;
        }
      }
      return void 0;
    }
    function createDefaultNlsBundle(folder) {
      var metaData = readJsonFileSync(path3.join(folder, "nls.metadata.json"));
      var result = /* @__PURE__ */ Object.create(null);
      for (var module_1 in metaData) {
        var entry = metaData[module_1];
        result[module_1] = entry.messages;
      }
      return result;
    }
    function createNLSBundle(header, metaDataPath) {
      var languagePackLocation = options.translationsConfig[header.id];
      if (!languagePackLocation) {
        return void 0;
      }
      var languagePack = readJsonFileSync(languagePackLocation).contents;
      var metaData = readJsonFileSync(path3.join(metaDataPath, "nls.metadata.json"));
      var result = /* @__PURE__ */ Object.create(null);
      for (var module_2 in metaData) {
        var entry = metaData[module_2];
        var translations = languagePack["".concat(header.outDir, "/").concat(module_2)];
        if (translations) {
          var resultMessages = [];
          for (var i = 0; i < entry.keys.length; i++) {
            var messageKey = entry.keys[i];
            var key = isString(messageKey) ? messageKey : messageKey.key;
            var translatedMessage = translations[key];
            if (translatedMessage === void 0) {
              translatedMessage = entry.messages[i];
            }
            resultMessages.push(translatedMessage);
          }
          result[module_2] = resultMessages;
        } else {
          result[module_2] = entry.messages;
        }
      }
      return result;
    }
    function touch(file) {
      var d = /* @__PURE__ */ new Date();
      fs2.utimes(file, d, d, function() {
      });
    }
    function cacheBundle(key, bundle) {
      resolvedBundles[key] = bundle;
      return bundle;
    }
    function loadNlsBundleOrCreateFromI18n(header, bundlePath) {
      var result;
      var bundle = path3.join(options.cacheRoot, "".concat(header.id, "-").concat(header.hash, ".json"));
      var useMemoryOnly = false;
      var writeBundle = false;
      try {
        result = JSON.parse(fs2.readFileSync(bundle, { encoding: "utf8", flag: "r" }));
        touch(bundle);
        return result;
      } catch (err) {
        if (err.code === "ENOENT") {
          writeBundle = true;
        } else if (err instanceof SyntaxError) {
          console.log("Syntax error parsing message bundle: ".concat(err.message, "."));
          fs2.unlink(bundle, function(err2) {
            if (err2) {
              console.error("Deleting corrupted bundle ".concat(bundle, " failed."));
            }
          });
          useMemoryOnly = true;
        } else {
          throw err;
        }
      }
      result = createNLSBundle(header, bundlePath);
      if (!result || useMemoryOnly) {
        return result;
      }
      if (writeBundle) {
        try {
          fs2.writeFileSync(bundle, JSON.stringify(result), { encoding: "utf8", flag: "wx" });
        } catch (err) {
          if (err.code === "EEXIST") {
            return result;
          }
          throw err;
        }
      }
      return result;
    }
    function loadDefaultNlsBundle(bundlePath) {
      try {
        return createDefaultNlsBundle(bundlePath);
      } catch (err) {
        console.log("Generating default bundle from meta data failed.", err);
        return void 0;
      }
    }
    function loadNlsBundle(header, bundlePath) {
      var result;
      if (supportsLanguagePack()) {
        try {
          result = loadNlsBundleOrCreateFromI18n(header, bundlePath);
        } catch (err) {
          console.log("Load or create bundle failed ", err);
        }
      }
      if (!result) {
        if (options.languagePackSupport) {
          return loadDefaultNlsBundle(bundlePath);
        }
        var candidate = findInTheBoxBundle(bundlePath);
        if (candidate) {
          try {
            return readJsonFileSync(candidate);
          } catch (err) {
            console.log("Loading in the box message bundle failed.", err);
          }
        }
        result = loadDefaultNlsBundle(bundlePath);
      }
      return result;
    }
    function tryFindMetaDataHeaderFile(file) {
      var result;
      var dirname2 = path3.dirname(file);
      while (true) {
        result = path3.join(dirname2, "nls.metadata.header.json");
        if (fs2.existsSync(result)) {
          break;
        }
        var parent = path3.dirname(dirname2);
        if (parent === dirname2) {
          result = void 0;
          break;
        } else {
          dirname2 = parent;
        }
      }
      return result;
    }
    function loadMessageBundle(file) {
      if (!file) {
        return common_1.localize;
      }
      var ext = path3.extname(file);
      if (ext) {
        file = file.substr(0, file.length - ext.length);
      }
      if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.bundle) {
        var headerFile = tryFindMetaDataHeaderFile(file);
        if (headerFile) {
          var bundlePath = path3.dirname(headerFile);
          var bundle = resolvedBundles[bundlePath];
          if (bundle === void 0) {
            try {
              var header = JSON.parse(fs2.readFileSync(headerFile, "utf8"));
              try {
                var nlsBundle = loadNlsBundle(header, bundlePath);
                bundle = cacheBundle(bundlePath, nlsBundle ? { header, nlsBundle } : null);
              } catch (err) {
                console.error("Failed to load nls bundle", err);
                bundle = cacheBundle(bundlePath, null);
              }
            } catch (err) {
              console.error("Failed to read header file", err);
              bundle = cacheBundle(bundlePath, null);
            }
          }
          if (bundle) {
            var module_3 = file.substr(bundlePath.length + 1).replace(/\\/g, "/");
            var messages = bundle.nlsBundle[module_3];
            if (messages === void 0) {
              console.error("Messages for file ".concat(file, " not found. See console for details."));
              return function() {
                return "Messages not found.";
              };
            }
            return createScopedLocalizeFunction(messages);
          }
        }
      }
      if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.file) {
        try {
          var json = readJsonFileSync(resolveLanguage(file));
          if (Array.isArray(json)) {
            return createScopedLocalizeFunction(json);
          } else {
            if ((0, common_1.isDefined)(json.messages) && (0, common_1.isDefined)(json.keys)) {
              return createScopedLocalizeFunction(json.messages);
            } else {
              console.error("String bundle '".concat(file, "' uses an unsupported format."));
              return function() {
                return "File bundle has unsupported format. See console for details";
              };
            }
          }
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.error("Failed to load single file bundle", err);
          }
        }
      }
      console.error("Failed to load message bundle for file ".concat(file));
      return function() {
        return "Failed to load message bundle. See console for details.";
      };
    }
    exports2.loadMessageBundle = loadMessageBundle;
    function config(opts) {
      if (opts) {
        if (isString(opts.locale)) {
          options.locale = opts.locale.toLowerCase();
          options.language = options.locale;
          resolvedBundles = /* @__PURE__ */ Object.create(null);
        }
        if (opts.messageFormat !== void 0) {
          options.messageFormat = opts.messageFormat;
        }
        if (opts.bundleFormat === common_1.BundleFormat.standalone && options.languagePackSupport === true) {
          options.languagePackSupport = false;
        }
      }
      (0, common_1.setPseudo)(options.locale === "pseudo");
      return loadMessageBundle;
    }
    exports2.config = config;
    ral_1.default.install(Object.freeze({
      loadMessageBundle,
      config
    }));
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/shared.js
var require_shared = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getConfigTitle = getConfigTitle;
    exports2.isTsDocument = isTsDocument;
    exports2.isJsonDocument = isJsonDocument;
    exports2.safeCall = safeCall;
    function getConfigTitle(document) {
      if (document.languageId === "javascriptreact") {
        return "javascript";
      }
      if (document.languageId === "typescriptreact") {
        return "typescript";
      }
      return document.languageId;
    }
    function isTsDocument(document) {
      return document.languageId === "javascript" || document.languageId === "typescript" || document.languageId === "javascriptreact" || document.languageId === "typescriptreact";
    }
    function isJsonDocument(document) {
      return document.languageId === "json" || document.languageId === "jsonc";
    }
    function safeCall(cb) {
      try {
        return cb();
      } catch {
      }
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/plugins/directiveComment.js
var require_directiveComment = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/plugins/directiveComment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.create = create;
    var nls = require_main6();
    var shared_1 = require_shared();
    var localize = nls.loadMessageBundle();
    var directives = [
      {
        value: "@ts-check",
        description: localize("ts-check", "Enables semantic checking in a JavaScript file. Must be at the top of a file.")
      },
      {
        value: "@ts-nocheck",
        description: localize("ts-nocheck", "Disables semantic checking in a JavaScript file. Must be at the top of a file.")
      },
      {
        value: "@ts-ignore",
        description: localize("ts-ignore", "Suppresses @ts-check errors on the next line of a file.")
      },
      {
        value: "@ts-expect-error",
        description: localize("ts-expect-error", "Suppresses @ts-check errors on the next line of a file, expecting at least one to exist.")
      }
    ];
    function create() {
      return {
        name: "typescript-directive-comment",
        capabilities: {
          completionProvider: {
            triggerCharacters: ["@"]
          }
        },
        create() {
          return {
            provideCompletionItems(document, position) {
              if (!(0, shared_1.isTsDocument)(document)) {
                return;
              }
              const prefix = document.getText({
                start: { line: position.line, character: 0 },
                end: position
              });
              const match = prefix.match(/^\s*\/\/+\s?(@[a-zA-Z\-]*)?$/);
              if (match) {
                const items = directives.map((directive) => {
                  const item = { label: directive.value };
                  item.insertTextFormat = 2;
                  item.detail = directive.description;
                  const range = {
                    start: {
                      line: position.line,
                      character: Math.max(0, position.character - (match[1] ? match[1].length : 0))
                    },
                    end: position
                  };
                  item.textEdit = {
                    range,
                    newText: directive.value
                  };
                  return item;
                });
                return {
                  isIncomplete: false,
                  items
                };
              }
            }
          };
        }
      };
    }
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      if (typeof a === "number" && typeof b === "number") {
        return a === b ? 0 : a < b ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/protocol.const.js
var require_protocol_const = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/protocol.const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventName = exports2.DisplayPartKind = exports2.KindModifiers = exports2.DiagnosticCategory = exports2.Kind = void 0;
    var Kind = class {
    };
    exports2.Kind = Kind;
    Kind.alias = "alias";
    Kind.callSignature = "call";
    Kind.class = "class";
    Kind.const = "const";
    Kind.constructorImplementation = "constructor";
    Kind.constructSignature = "construct";
    Kind.directory = "directory";
    Kind.enum = "enum";
    Kind.enumMember = "enum member";
    Kind.externalModuleName = "external module name";
    Kind.function = "function";
    Kind.indexSignature = "index";
    Kind.interface = "interface";
    Kind.keyword = "keyword";
    Kind.let = "let";
    Kind.localFunction = "local function";
    Kind.localVariable = "local var";
    Kind.method = "method";
    Kind.memberGetAccessor = "getter";
    Kind.memberSetAccessor = "setter";
    Kind.memberVariable = "property";
    Kind.module = "module";
    Kind.primitiveType = "primitive type";
    Kind.script = "script";
    Kind.type = "type";
    Kind.variable = "var";
    Kind.warning = "warning";
    Kind.string = "string";
    Kind.parameter = "parameter";
    Kind.typeParameter = "type parameter";
    var DiagnosticCategory = class {
    };
    exports2.DiagnosticCategory = DiagnosticCategory;
    DiagnosticCategory.error = "error";
    DiagnosticCategory.warning = "warning";
    DiagnosticCategory.suggestion = "suggestion";
    var KindModifiers = class {
    };
    exports2.KindModifiers = KindModifiers;
    KindModifiers.optional = "optional";
    KindModifiers.deprecated = "deprecated";
    KindModifiers.color = "color";
    KindModifiers.dtsFile = ".d.ts";
    KindModifiers.tsFile = ".ts";
    KindModifiers.tsxFile = ".tsx";
    KindModifiers.jsFile = ".js";
    KindModifiers.jsxFile = ".jsx";
    KindModifiers.jsonFile = ".json";
    KindModifiers.fileExtensionKindModifiers = [
      KindModifiers.dtsFile,
      KindModifiers.tsFile,
      KindModifiers.tsxFile,
      KindModifiers.jsFile,
      KindModifiers.jsxFile,
      KindModifiers.jsonFile
    ];
    var DisplayPartKind = class {
    };
    exports2.DisplayPartKind = DisplayPartKind;
    DisplayPartKind.functionName = "functionName";
    DisplayPartKind.methodName = "methodName";
    DisplayPartKind.parameterName = "parameterName";
    DisplayPartKind.propertyName = "propertyName";
    DisplayPartKind.punctuation = "punctuation";
    DisplayPartKind.text = "text";
    var EventName;
    (function(EventName2) {
      EventName2["syntaxDiag"] = "syntaxDiag";
      EventName2["semanticDiag"] = "semanticDiag";
      EventName2["suggestionDiag"] = "suggestionDiag";
      EventName2["configFileDiag"] = "configFileDiag";
      EventName2["telemetry"] = "telemetry";
      EventName2["projectLanguageServiceState"] = "projectLanguageServiceState";
      EventName2["projectsUpdatedInBackground"] = "projectsUpdatedInBackground";
      EventName2["beginInstallTypes"] = "beginInstallTypes";
      EventName2["endInstallTypes"] = "endInstallTypes";
      EventName2["typesInstallerInitializationFailed"] = "typesInstallerInitializationFailed";
      EventName2["surveyReady"] = "surveyReady";
      EventName2["projectLoadingStart"] = "projectLoadingStart";
      EventName2["projectLoadingFinish"] = "projectLoadingFinish";
    })(EventName || (exports2.EventName = EventName = {}));
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/modifiers.js
var require_modifiers = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/modifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseKindModifier = parseKindModifier;
    function parseKindModifier(kindModifiers) {
      return new Set(kindModifiers.split(/,|\s+/g));
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/previewer.js
var require_previewer = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/previewer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.plainWithLinks = plainWithLinks;
    exports2.tagsMarkdownPreview = tagsMarkdownPreview;
    exports2.markdownDocumentation = markdownDocumentation;
    exports2.addMarkdownDocumentation = addMarkdownDocumentation;
    function replaceLinks(text) {
      return text.replace(/\{@(link|linkplain|linkcode) (https?:\/\/[^ |}]+?)(?:[| ]([^{}\n]+?))?\}/gi, (_, tag, link, text2) => {
        switch (tag) {
          case "linkcode":
            return `[\`${text2 ? text2.trim() : link}\`](${link})`;
          default:
            return `[${text2 ? text2.trim() : link}](${link})`;
        }
      });
    }
    function processInlineTags(text) {
      return replaceLinks(text);
    }
    function getTagBodyText(tag, fileNameToUri, getTextDocument) {
      if (!tag.text) {
        return void 0;
      }
      function makeCodeblock(text2) {
        if (text2.match(/^\s*[~`]{3}/g)) {
          return text2;
        }
        return "```\n" + text2 + "\n```";
      }
      const text = convertLinkTags(tag.text, fileNameToUri, getTextDocument);
      switch (tag.name) {
        case "example":
          const captionTagMatches = text.match(/<caption>(.*?)<\/caption>\s*(\r\n|\n)/);
          if (captionTagMatches && captionTagMatches.index === 0) {
            return captionTagMatches[1] + "\n\n" + makeCodeblock(text.slice(captionTagMatches[0].length));
          } else {
            return makeCodeblock(text);
          }
        case "author":
          const emailMatch = text.match(/(.+)\s<([-.\w]+@[-.\w]+)>/);
          if (emailMatch === null) {
            return text;
          } else {
            return `${emailMatch[1]} ${emailMatch[2]}`;
          }
        case "default":
          return makeCodeblock(text);
      }
      return processInlineTags(text);
    }
    function getTagDocumentation(tag, fileNameToUri, getTextDocument) {
      switch (tag.name) {
        case "augments":
        case "extends":
        case "param":
        case "template":
          const body = convertLinkTags(tag.text, fileNameToUri, getTextDocument).split(/^(\S+)\s*-?\s*/);
          if (body?.length === 3) {
            const param = body[1];
            const doc = body[2];
            const label2 = `*@${tag.name}* \`${param}\``;
            if (!doc) {
              return label2;
            }
            return label2 + (doc.match(/\r\n|\n/g) ? "  \n" + processInlineTags(doc) : ` \u2014 ${processInlineTags(doc)}`);
          }
      }
      const label = `*@${tag.name}*`;
      const text = getTagBodyText(tag, fileNameToUri, getTextDocument);
      if (!text) {
        return label;
      }
      return label + (text.match(/\r\n|\n/g) ? "  \n" + text : ` \u2014 ${text}`);
    }
    function plainWithLinks(parts, fileNameToUri, getTextDocument) {
      return processInlineTags(convertLinkTags(parts, fileNameToUri, getTextDocument));
    }
    function convertLinkTags(parts, fileNameToUri, getTextDocument) {
      if (!parts) {
        return "";
      }
      if (typeof parts === "string") {
        return parts;
      }
      const out = [];
      let currentLink;
      for (const part of parts) {
        switch (part.kind) {
          case "link":
            if (currentLink) {
              const text = currentLink.text ?? currentLink.name;
              let target = currentLink.target;
              if (typeof currentLink.target === "object" && "fileName" in currentLink.target) {
                const _target = currentLink.target;
                const fileDoc = getTextDocument(fileNameToUri(_target.fileName));
                if (fileDoc) {
                  const start = fileDoc.positionAt(_target.textSpan.start);
                  const end = fileDoc.positionAt(_target.textSpan.start + _target.textSpan.length);
                  target = {
                    file: _target.fileName,
                    start: {
                      line: start.line + 1,
                      offset: start.character + 1
                    },
                    end: {
                      line: end.line + 1,
                      offset: end.character + 1
                    }
                  };
                } else {
                  target = {
                    file: _target.fileName,
                    start: {
                      line: 1,
                      offset: 1
                    },
                    end: {
                      line: 1,
                      offset: 1
                    }
                  };
                }
              }
              if (target) {
                const link = fileNameToUri(target.file) + `#L${target.start.line},${target.start.offset}`;
                out.push(`[${text}](${link})`);
              } else {
                if (text) {
                  out.push(text);
                }
              }
              currentLink = void 0;
            } else {
              currentLink = {};
            }
            break;
          case "linkName":
            if (currentLink) {
              currentLink.name = part.text;
              currentLink.target = part.target;
            }
            break;
          case "linkText":
            if (currentLink) {
              currentLink.text = part.text;
            }
            break;
          default:
            out.push(part.text);
            break;
        }
      }
      return processInlineTags(out.join(""));
    }
    function tagsMarkdownPreview(tags, fileNameToUri, getTextDocument) {
      return tags.map((tag) => getTagDocumentation(tag, fileNameToUri, getTextDocument)).join("  \n\n");
    }
    function markdownDocumentation(documentation, tags, fileNameToUri, getTextDocument) {
      return addMarkdownDocumentation("", documentation, tags, fileNameToUri, getTextDocument);
    }
    function addMarkdownDocumentation(out, documentation, tags, fileNameToUri, getTextDocument) {
      if (documentation) {
        out += plainWithLinks(documentation, fileNameToUri, getTextDocument);
      }
      if (tags) {
        const tagsPreview = tagsMarkdownPreview(tags, fileNameToUri, getTextDocument);
        if (tagsPreview) {
          out += "\n\n" + tagsPreview;
        }
      }
      return out;
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/typeConverters.js
var require_typeConverters = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/typeConverters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SymbolKind = void 0;
    var PConst = require_protocol_const();
    var SymbolKind;
    (function(SymbolKind2) {
      function fromProtocolScriptElementKind(kind) {
        switch (kind) {
          case PConst.Kind.module:
            return 2;
          case PConst.Kind.class:
            return 5;
          case PConst.Kind.enum:
            return 10;
          case PConst.Kind.enumMember:
            return 22;
          case PConst.Kind.interface:
            return 11;
          case PConst.Kind.indexSignature:
            return 6;
          case PConst.Kind.callSignature:
            return 6;
          case PConst.Kind.method:
            return 6;
          case PConst.Kind.memberVariable:
            return 7;
          case PConst.Kind.memberGetAccessor:
            return 7;
          case PConst.Kind.memberSetAccessor:
            return 7;
          case PConst.Kind.variable:
            return 13;
          case PConst.Kind.let:
            return 13;
          case PConst.Kind.const:
            return 13;
          case PConst.Kind.localVariable:
            return 13;
          case PConst.Kind.alias:
            return 13;
          case PConst.Kind.function:
            return 12;
          case PConst.Kind.localFunction:
            return 12;
          case PConst.Kind.constructSignature:
            return 9;
          case PConst.Kind.constructorImplementation:
            return 9;
          case PConst.Kind.typeParameter:
            return 26;
          case PConst.Kind.string:
            return 15;
          default:
            return 13;
        }
      }
      SymbolKind2.fromProtocolScriptElementKind = fromProtocolScriptElementKind;
    })(SymbolKind || (exports2.SymbolKind = SymbolKind = {}));
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/lspConverters.js
var require_lspConverters = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/lspConverters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertDiagnostic = convertDiagnostic;
    exports2.applyCompletionEntryDetails = applyCompletionEntryDetails;
    exports2.convertCompletionInfo = convertCompletionInfo;
    exports2.getLineText = getLineText;
    exports2.convertNavigateToItem = convertNavigateToItem;
    exports2.convertInlayHint = convertInlayHint;
    exports2.convertHighlightSpan = convertHighlightSpan;
    exports2.convertSelectionRange = convertSelectionRange;
    exports2.convertFileTextChanges = convertFileTextChanges;
    exports2.convertRenameLocations = convertRenameLocations;
    exports2.convertQuickInfo = convertQuickInfo;
    exports2.convertNavTree = convertNavTree;
    exports2.convertOutliningSpan = convertOutliningSpan;
    exports2.convertOutliningSpanKind = convertOutliningSpanKind;
    exports2.convertTextChange = convertTextChange;
    exports2.convertCallHierarchyIncomingCall = convertCallHierarchyIncomingCall;
    exports2.convertCallHierarchyOutgoingCall = convertCallHierarchyOutgoingCall;
    exports2.convertCallHierarchyItem = convertCallHierarchyItem;
    exports2.convertDocumentSpanToLocation = convertDocumentSpanToLocation;
    exports2.convertDefinitionInfoAndBoundSpan = convertDefinitionInfoAndBoundSpan;
    exports2.convertDocumentSpantoLocationLink = convertDocumentSpantoLocationLink;
    exports2.convertTextSpan = convertTextSpan;
    var path3 = require_path_browserify();
    var semver = require_semver2();
    var PConst = require_protocol_const();
    var modifiers_1 = require_modifiers();
    var previewer = require_previewer();
    var typeConverters = require_typeConverters();
    function convertDiagnostic(diag, document, fileNameToUri, getTextDocument) {
      if (diag.start === void 0) {
        return;
      }
      if (diag.length === void 0) {
        return;
      }
      const diagnostic = {
        range: {
          start: document.positionAt(diag.start),
          end: document.positionAt(diag.start + diag.length)
        },
        severity: convertDiagnosticCategory(diag.category),
        source: "ts",
        code: diag.code,
        message: getMessageText(diag)
      };
      if (diag.relatedInformation) {
        diagnostic.relatedInformation = diag.relatedInformation.map((rErr) => convertDiagnosticRelatedInformation(rErr, fileNameToUri, getTextDocument)).filter((v) => !!v);
      }
      if (diag.reportsUnnecessary) {
        if (diagnostic.tags === void 0) {
          diagnostic.tags = [];
        }
        diagnostic.tags.push(1);
      }
      if (diag.reportsDeprecated) {
        if (diagnostic.tags === void 0) {
          diagnostic.tags = [];
        }
        diagnostic.tags.push(2);
      }
      return diagnostic;
    }
    function convertDiagnosticRelatedInformation(diag, fileNameToUri, getTextDocument) {
      if (diag.start === void 0) {
        return;
      }
      if (diag.length === void 0) {
        return;
      }
      let document;
      if (diag.file) {
        document = getTextDocument(fileNameToUri(diag.file.fileName));
      }
      if (!document) {
        return;
      }
      const diagnostic = {
        location: {
          uri: document.uri,
          range: {
            start: document.positionAt(diag.start),
            end: document.positionAt(diag.start + diag.length)
          }
        },
        message: getMessageText(diag)
      };
      return diagnostic;
    }
    function convertDiagnosticCategory(input) {
      switch (input) {
        case 0:
          return 2;
        case 1:
          return 1;
        case 2:
          return 4;
        case 3:
          return 3;
      }
      return 1;
    }
    function getMessageText(diag) {
      let messageText = "";
      if (typeof diag.messageText === "string") {
        messageText += diag.messageText;
      } else {
        messageText += diag.messageText.messageText;
        if (diag.messageText.next) {
          for (const info of diag.messageText.next) {
            messageText += "\n" + getNextMessageText(info, 1);
          }
        }
      }
      return messageText;
    }
    function getNextMessageText(diag, level = 0) {
      let messageText = "  ".repeat(level);
      messageText += diag.messageText;
      if (diag.next) {
        for (const info of diag.next) {
          messageText += "\n" + getNextMessageText(info, level + 1);
        }
      }
      return messageText;
    }
    function applyCompletionEntryDetails(ts, item, data, document, fileNameToUri, getTextDocument) {
      const { sourceDisplay } = data;
      if (sourceDisplay) {
        item.labelDetails ??= {};
        item.labelDetails.description = ts.displayPartsToString(sourceDisplay);
      }
      const detailTexts = [];
      if (data.codeActions) {
        item.additionalTextEdits ??= [];
        for (const action of data.codeActions) {
          detailTexts.push(action.description);
          for (const changes of action.changes) {
            const ranges = changes.textChanges.map((change) => convertTextSpan(change.span, document));
            ranges.forEach((range, index) => {
              item.additionalTextEdits?.push({ range, newText: changes.textChanges[index].newText });
            });
          }
        }
      }
      if (data.displayParts) {
        detailTexts.push(previewer.plainWithLinks(data.displayParts, fileNameToUri, getTextDocument));
      }
      if (detailTexts.length) {
        item.detail = detailTexts.join("\n");
      }
      item.documentation = {
        kind: "markdown",
        value: previewer.markdownDocumentation(data.documentation, data.tags, fileNameToUri, getTextDocument)
      };
      if (data) {
        handleKindModifiers(item, data);
      }
    }
    function convertCompletionInfo(ts, completionContext, document, position, createData) {
      const lt_320 = semver.lt(ts.version, "3.2.0");
      const gte_300 = semver.gte(ts.version, "3.0.0");
      const wordRange = completionContext.optionalReplacementSpan ? convertTextSpan(completionContext.optionalReplacementSpan, document) : void 0;
      const line = getLineText(document, position.line);
      const dotAccessorContext = getDotAccessorContext(document);
      const entries = completionContext.entries.map((tsEntry) => ({
        ...convertCompletionEntry(tsEntry, document),
        data: createData(tsEntry)
      }));
      return {
        isIncomplete: !!completionContext.isIncomplete,
        items: entries
      };
      function convertCompletionEntry(tsEntry, document2) {
        const item = { label: tsEntry.name };
        item.kind = convertCompletionItemKind(tsEntry.kind);
        if (tsEntry.source && tsEntry.hasAction) {
          item.sortText = "\uFFFF" + tsEntry.sortText;
        } else {
          item.sortText = tsEntry.sortText;
        }
        const { sourceDisplay, isSnippet, labelDetails } = tsEntry;
        if (sourceDisplay) {
          item.labelDetails ??= {};
          item.labelDetails.description = ts.displayPartsToString(sourceDisplay);
        }
        if (labelDetails) {
          item.labelDetails ??= {};
          Object.assign(item.labelDetails, labelDetails);
        }
        item.preselect = tsEntry.isRecommended;
        let range = getRangeFromReplacementSpan(tsEntry, document2);
        item.commitCharacters = getCommitCharacters(tsEntry, {
          isNewIdentifierLocation: completionContext.isNewIdentifierLocation,
          isInValidCommitCharacterContext: isInValidCommitCharacterContext(document2, position),
          enableCallCompletions: true
          // TODO: suggest.completeFunctionCalls
        });
        item.insertText = tsEntry.insertText;
        item.insertTextFormat = isSnippet ? 2 : 1;
        item.filterText = getFilterText(tsEntry, wordRange, line, tsEntry.insertText);
        if (completionContext?.isMemberCompletion && dotAccessorContext && !isSnippet) {
          item.filterText = dotAccessorContext.text + (item.insertText || item.label);
          if (!range) {
            const replacementRange = wordRange;
            if (replacementRange) {
              range = {
                inserting: dotAccessorContext.range,
                replacing: rangeUnion(dotAccessorContext.range, replacementRange)
              };
            } else {
              range = dotAccessorContext.range;
            }
            item.insertText = item.filterText;
          }
        }
        handleKindModifiers(item, tsEntry);
        if (!range && wordRange) {
          range = {
            inserting: { start: wordRange.start, end: position },
            replacing: wordRange
          };
        }
        if (range) {
          if ("start" in range) {
            item.textEdit = {
              range,
              newText: item.insertText || item.label
            };
          } else {
            item.textEdit = {
              insert: range.inserting,
              replace: range.replacing,
              newText: item.insertText || item.label
            };
          }
        }
        return item;
      }
      function getDotAccessorContext(document2) {
        let dotAccessorContext2;
        if (gte_300) {
          if (!completionContext) {
            return;
          }
          const isMemberCompletion = completionContext.isMemberCompletion;
          if (isMemberCompletion) {
            const dotMatch = line.slice(0, position.character).match(/\??\.\s*$/) || void 0;
            if (dotMatch) {
              const range = {
                start: { line: position.line, character: position.character - dotMatch[0].length },
                end: position
              };
              const text = document2.getText(range);
              dotAccessorContext2 = { range, text };
            }
          }
        }
        return dotAccessorContext2;
      }
      function getRangeFromReplacementSpan(tsEntry, document2) {
        if (!tsEntry.replacementSpan) {
          return;
        }
        let replaceRange = {
          start: document2.positionAt(tsEntry.replacementSpan.start),
          end: document2.positionAt(tsEntry.replacementSpan.start + tsEntry.replacementSpan.length)
        };
        if (replaceRange.start.line !== replaceRange.end.line) {
          replaceRange = {
            start: {
              line: replaceRange.start.line,
              character: replaceRange.start.character
            },
            end: {
              line: replaceRange.start.line,
              character: document2.positionAt(document2.offsetAt({ line: replaceRange.start.line + 1, character: 0 }) - 1).character
            }
          };
        }
        return {
          inserting: replaceRange,
          replacing: replaceRange
        };
      }
      function getFilterText(tsEntry, wordRange2, line2, insertText) {
        if (tsEntry.name.startsWith("#")) {
          const wordStart = wordRange2 ? line2.charAt(wordRange2.start.character) : void 0;
          if (insertText) {
            if (insertText.startsWith("this.#")) {
              return wordStart === "#" ? insertText : insertText.replace(/^this\.#/, "");
            } else {
              return insertText;
            }
          } else {
            return wordStart === "#" ? void 0 : tsEntry.name.replace(/^#/, "");
          }
        }
        if (insertText?.startsWith("this.")) {
          return void 0;
        } else if (insertText?.startsWith("[")) {
          return insertText.replace(/^\[['"](.+)[['"]\]$/, ".$1");
        }
        return insertText;
      }
      function getCommitCharacters(entry, context) {
        if (entry.kind === PConst.Kind.warning) {
          return void 0;
        }
        if (context.isNewIdentifierLocation || !context.isInValidCommitCharacterContext) {
          return void 0;
        }
        const commitCharacters = [".", ",", ";"];
        if (context.enableCallCompletions) {
          commitCharacters.push("(");
        }
        return commitCharacters;
      }
      function isInValidCommitCharacterContext(document2, position2) {
        if (lt_320) {
          if (position2.character > 1) {
            const preText = document2.getText({
              start: { line: position2.line, character: 0 },
              end: position2
            });
            return preText.match(/(\s|^)\.$/ig) === null;
          }
        }
        return true;
      }
    }
    function convertCompletionItemKind(kind) {
      switch (kind) {
        case PConst.Kind.primitiveType:
        case PConst.Kind.keyword:
          return 14;
        case PConst.Kind.const:
        case PConst.Kind.let:
        case PConst.Kind.variable:
        case PConst.Kind.localVariable:
        case PConst.Kind.alias:
        case PConst.Kind.parameter:
          return 6;
        case PConst.Kind.memberVariable:
        case PConst.Kind.memberGetAccessor:
        case PConst.Kind.memberSetAccessor:
          return 5;
        case PConst.Kind.function:
        case PConst.Kind.localFunction:
          return 3;
        case PConst.Kind.method:
        case PConst.Kind.constructSignature:
        case PConst.Kind.callSignature:
        case PConst.Kind.indexSignature:
          return 2;
        case PConst.Kind.enum:
          return 13;
        case PConst.Kind.enumMember:
          return 20;
        case PConst.Kind.module:
        case PConst.Kind.externalModuleName:
          return 9;
        case PConst.Kind.class:
        case PConst.Kind.type:
          return 7;
        case PConst.Kind.interface:
          return 8;
        case PConst.Kind.warning:
          return 1;
        case PConst.Kind.script:
          return 17;
        case PConst.Kind.directory:
          return 19;
        case PConst.Kind.string:
          return 21;
        default:
          return 10;
      }
    }
    function handleKindModifiers(item, tsEntry) {
      if (tsEntry.kindModifiers) {
        const kindModifiers = (0, modifiers_1.parseKindModifier)(tsEntry.kindModifiers);
        if (kindModifiers.has(PConst.KindModifiers.optional)) {
          if (!item.insertText) {
            item.insertText = item.label;
          }
          if (!item.filterText) {
            item.filterText = item.label;
          }
          item.label += "?";
        }
        if (kindModifiers.has(PConst.KindModifiers.deprecated)) {
          item.tags = [1];
        }
        if (kindModifiers.has(PConst.KindModifiers.color)) {
          item.kind = 16;
        }
        if (tsEntry.kind === PConst.Kind.script) {
          for (const extModifier of PConst.KindModifiers.fileExtensionKindModifiers) {
            if (kindModifiers.has(extModifier)) {
              if (tsEntry.name.toLowerCase().endsWith(extModifier)) {
                item.detail = tsEntry.name;
              } else {
                item.detail = tsEntry.name + extModifier;
              }
              break;
            }
          }
        }
      }
    }
    function rangeUnion(a, b) {
      const start = a.start.line < b.start.line || a.start.line === b.start.line && a.start.character < b.start.character ? a.start : b.start;
      const end = a.end.line > b.end.line || a.end.line === b.end.line && a.end.character > b.end.character ? a.end : b.end;
      return { start, end };
    }
    function getLineText(document, line) {
      const endOffset = document.offsetAt({ line: line + 1, character: 0 });
      const end = document.positionAt(endOffset);
      const text = document.getText({
        start: { line, character: 0 },
        end: end.line === line ? end : document.positionAt(endOffset - 1)
      });
      return text;
    }
    function convertNavigateToItem(item, document) {
      const info = {
        name: getLabel(item),
        kind: convertScriptElementKind(item.kind),
        location: {
          uri: document.uri,
          range: convertTextSpan(item.textSpan, document)
        }
      };
      const kindModifiers = item.kindModifiers ? (0, modifiers_1.parseKindModifier)(item.kindModifiers) : void 0;
      if (kindModifiers?.has(PConst.KindModifiers.deprecated)) {
        info.tags = [1];
      }
      return info;
    }
    function getLabel(item) {
      const label = item.name;
      if (item.kind === "method" || item.kind === "function") {
        return label + "()";
      }
      return label;
    }
    function convertScriptElementKind(kind) {
      switch (kind) {
        case PConst.Kind.method:
          return 6;
        case PConst.Kind.enum:
          return 10;
        case PConst.Kind.enumMember:
          return 22;
        case PConst.Kind.function:
          return 12;
        case PConst.Kind.class:
          return 5;
        case PConst.Kind.interface:
          return 11;
        case PConst.Kind.type:
          return 5;
        case PConst.Kind.memberVariable:
          return 8;
        case PConst.Kind.memberGetAccessor:
          return 8;
        case PConst.Kind.memberSetAccessor:
          return 8;
        case PConst.Kind.variable:
          return 13;
        default:
          return 13;
      }
    }
    function convertInlayHint(hint, document) {
      const result = {
        position: document.positionAt(hint.position),
        label: hint.text,
        kind: hint.kind === "Type" ? 1 : hint.kind === "Parameter" ? 2 : void 0
      };
      result.paddingLeft = hint.whitespaceBefore;
      result.paddingRight = hint.whitespaceAfter;
      return result;
    }
    function convertHighlightSpan(span, document) {
      return {
        kind: span.kind === "writtenReference" ? 3 : 2,
        range: convertTextSpan(span.textSpan, document)
      };
    }
    function convertSelectionRange(range, document) {
      return {
        parent: range.parent ? convertSelectionRange(range.parent, document) : void 0,
        range: convertTextSpan(range.textSpan, document)
      };
    }
    function convertFileTextChanges(changes, fileNameToUri, getTextDocument) {
      const workspaceEdit = {};
      for (const change of changes) {
        if (!workspaceEdit.documentChanges) {
          workspaceEdit.documentChanges = [];
        }
        const uri = fileNameToUri(change.fileName);
        if (change.isNewFile) {
          workspaceEdit.documentChanges.push({ kind: "create", uri: uri.toString() });
          workspaceEdit.documentChanges.push({
            textDocument: {
              uri: uri.toString(),
              version: null
              // fix https://github.com/johnsoncodehk/volar/issues/2025
            },
            edits: change.textChanges.map((edit) => ({
              newText: edit.newText,
              range: {
                start: { line: 0, character: edit.span.start },
                end: { line: 0, character: edit.span.start + edit.span.length }
              }
            }))
          });
        } else {
          const doc = getTextDocument(uri);
          workspaceEdit.documentChanges.push({
            textDocument: {
              uri: uri.toString(),
              version: null
              // fix https://github.com/johnsoncodehk/volar/issues/2025
            },
            edits: change.textChanges.map((edit) => convertTextChange(edit, doc))
          });
        }
      }
      return workspaceEdit;
    }
    function convertRenameLocations(newText, locations, fileNameToUri, getTextDocument) {
      const workspaceEdit = {};
      for (const location of locations) {
        if (!workspaceEdit.changes) {
          workspaceEdit.changes = {};
        }
        const uri = fileNameToUri(location.fileName);
        const doc = getTextDocument(uri);
        if (!workspaceEdit.changes[uri.toString()]) {
          workspaceEdit.changes[uri.toString()] = [];
        }
        let _newText = newText;
        if (location.prefixText) {
          _newText = location.prefixText + _newText;
        }
        if (location.suffixText) {
          _newText = _newText + location.suffixText;
        }
        workspaceEdit.changes[uri.toString()].push({
          newText: _newText,
          range: convertTextSpan(location.textSpan, doc)
        });
      }
      return workspaceEdit;
    }
    function convertQuickInfo(ts, info, document, fileNameToUri, getTextDocument) {
      const parts = [];
      const displayString = ts.displayPartsToString(info.displayParts);
      const documentation = previewer.markdownDocumentation(info.documentation ?? [], info.tags, fileNameToUri, getTextDocument);
      if (displayString) {
        parts.push(["```typescript", displayString, "```"].join("\n"));
      }
      if (documentation) {
        parts.push(documentation);
      }
      const markdown = {
        kind: "markdown",
        value: parts.join("\n\n")
      };
      return {
        contents: markdown,
        range: convertTextSpan(info.textSpan, document)
      };
    }
    function convertNavTree(item, document) {
      if (!shouldIncludeEntry(item)) {
        return [];
      }
      let remain = item.childItems ?? [];
      return item.spans.map((span) => {
        const childItems = [];
        remain = remain.filter((child) => {
          const childStart = child.spans[0].start;
          const childEnd = child.spans[child.spans.length - 1].start + child.spans[child.spans.length - 1].length;
          if (childStart >= span.start && childEnd <= span.start + span.length) {
            childItems.push(child);
            return false;
          }
          return true;
        });
        const nameSpan = item.spans.length === 1 ? item.nameSpan ?? span : span;
        const fullRange = {
          start: Math.min(span.start, nameSpan.start),
          end: Math.max(span.start + span.length, nameSpan.start + nameSpan.length)
        };
        const symbol = {
          name: item.text,
          kind: getSymbolKind(item.kind),
          range: convertTextSpan({
            start: fullRange.start,
            length: fullRange.end - fullRange.start
          }, document),
          selectionRange: convertTextSpan(nameSpan, document),
          children: childItems.map((item2) => convertNavTree(item2, document)).flat()
        };
        const kindModifiers = (0, modifiers_1.parseKindModifier)(item.kindModifiers);
        if (kindModifiers.has(PConst.KindModifiers.deprecated)) {
          symbol.deprecated = true;
          symbol.tags ??= [];
          symbol.tags.push(1);
        }
        return symbol;
      });
    }
    var getSymbolKind = (kind) => {
      switch (kind) {
        case PConst.Kind.module:
          return 2;
        case PConst.Kind.class:
          return 5;
        case PConst.Kind.enum:
          return 10;
        case PConst.Kind.interface:
          return 11;
        case PConst.Kind.method:
          return 6;
        case PConst.Kind.memberVariable:
          return 7;
        case PConst.Kind.memberGetAccessor:
          return 7;
        case PConst.Kind.memberSetAccessor:
          return 7;
        case PConst.Kind.variable:
          return 13;
        case PConst.Kind.const:
          return 13;
        case PConst.Kind.localVariable:
          return 13;
        case PConst.Kind.function:
          return 12;
        case PConst.Kind.localFunction:
          return 12;
        case PConst.Kind.constructSignature:
          return 9;
        case PConst.Kind.constructorImplementation:
          return 9;
      }
      return 13;
    };
    function shouldIncludeEntry(item) {
      if (item.kind === PConst.Kind.alias) {
        return false;
      }
      return !!(item.text && item.text !== "<function>" && item.text !== "<class>");
    }
    function convertOutliningSpan(outliningSpan, document) {
      const start = document.positionAt(outliningSpan.textSpan.start);
      const end = adjustFoldingEnd(start, document.positionAt(outliningSpan.textSpan.start + outliningSpan.textSpan.length), document);
      return {
        startLine: start.line,
        endLine: end.line,
        startCharacter: start.character,
        endCharacter: end.character,
        kind: convertOutliningSpanKind(outliningSpan.kind)
      };
    }
    function convertOutliningSpanKind(kind) {
      switch (kind) {
        case "comment":
          return "comment";
        case "region":
          return "region";
        case "imports":
          return "imports";
        case "code":
        default:
          return void 0;
      }
    }
    var foldEndPairCharacters = ["}", "]", ")", "`"];
    function adjustFoldingEnd(start, end, document) {
      if (end.character > 0) {
        const foldEndCharacter = document.getText({
          start: { line: end.line, character: end.character - 1 },
          end
        });
        if (foldEndPairCharacters.includes(foldEndCharacter)) {
          const endOffset = Math.max(document.offsetAt({ line: end.line, character: 0 }) - 1, document.offsetAt(start));
          return document.positionAt(endOffset);
        }
      }
      return end;
    }
    function convertTextChange(edit, document) {
      return {
        range: convertTextSpan(edit.span, document),
        newText: edit.newText
      };
    }
    function convertCallHierarchyIncomingCall(item, ctx) {
      const uri = ctx.fileNameToUri(item.from.file);
      const document = ctx.getTextDocument(uri);
      return {
        from: convertCallHierarchyItem(item.from, ctx),
        fromRanges: item.fromSpans.map((span) => convertTextSpan(span, document)).filter((span) => !!span)
      };
    }
    function convertCallHierarchyOutgoingCall(item, fromDocument, ctx) {
      return {
        to: convertCallHierarchyItem(item.to, ctx),
        fromRanges: item.fromSpans.map((span) => convertTextSpan(span, fromDocument)).filter((span) => !!span)
      };
    }
    function convertCallHierarchyItem(item, ctx) {
      const rootPath = ctx.languageService.getProgram()?.getCompilerOptions().rootDir ?? "";
      const uri = ctx.fileNameToUri(item.file);
      const document = ctx.getTextDocument(uri);
      const useFileName = isSourceFileItem(item);
      const name = useFileName ? path3.basename(item.file) : item.name;
      const detail = useFileName ? path3.relative(rootPath, path3.dirname(item.file)) : item.containerName ?? "";
      const result = {
        kind: typeConverters.SymbolKind.fromProtocolScriptElementKind(item.kind),
        name,
        detail,
        uri: uri.toString(),
        range: convertTextSpan(item.span, document),
        selectionRange: convertTextSpan(item.selectionSpan, document)
      };
      const kindModifiers = item.kindModifiers ? (0, modifiers_1.parseKindModifier)(item.kindModifiers) : void 0;
      if (kindModifiers?.has(PConst.KindModifiers.deprecated)) {
        result.tags = [1];
      }
      return result;
    }
    function isSourceFileItem(item) {
      return item.kind === PConst.Kind.script || item.kind === PConst.Kind.module && item.selectionSpan.start === 0;
    }
    function convertDocumentSpanToLocation(documentSpan, ctx) {
      const uri = ctx.fileNameToUri(documentSpan.fileName);
      const document = ctx.getTextDocument(uri);
      const range = convertTextSpan(documentSpan.textSpan, document);
      return {
        uri: uri.toString(),
        range
      };
    }
    function convertDefinitionInfoAndBoundSpan(info, document, ctx) {
      if (!info.definitions) {
        return [];
      }
      const originSelectionRange = convertTextSpan(info.textSpan, document);
      return info.definitions.map((entry) => {
        const link = convertDocumentSpantoLocationLink(entry, ctx);
        if (link) {
          link.originSelectionRange ??= originSelectionRange;
          return link;
        }
      }).filter((entry) => !!entry);
    }
    function convertDocumentSpantoLocationLink(documentSpan, ctx) {
      const targetUri = ctx.fileNameToUri(documentSpan.fileName);
      const document = ctx.getTextDocument(targetUri);
      const targetSelectionRange = convertTextSpan(documentSpan.textSpan, document);
      const targetRange = documentSpan.contextSpan ? convertTextSpan(documentSpan.contextSpan, document) : targetSelectionRange;
      const originSelectionRange = documentSpan.originalTextSpan ? convertTextSpan(documentSpan.originalTextSpan, document) : void 0;
      return {
        targetUri: targetUri.toString(),
        targetRange,
        targetSelectionRange,
        originSelectionRange
      };
    }
    function convertTextSpan(textSpan, document) {
      if (!document) {
        return {
          start: { line: 0, character: 0 },
          end: { line: 0, character: 0 }
        };
      }
      return {
        start: document.positionAt(textSpan.start),
        end: document.positionAt(textSpan.start + textSpan.length)
      };
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/configs/getFormatCodeSettings.js
var require_getFormatCodeSettings = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/configs/getFormatCodeSettings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFormatCodeSettings = getFormatCodeSettings;
    var shared_1 = require_shared();
    async function getFormatCodeSettings(ctx, document, options) {
      const config = await ctx.env.getConfiguration?.((0, shared_1.getConfigTitle)(document) + ".format") ?? {};
      return {
        convertTabsToSpaces: options?.insertSpaces,
        tabSize: options?.tabSize,
        indentSize: options?.tabSize,
        indentStyle: 2,
        newLineCharacter: "\n",
        insertSpaceAfterCommaDelimiter: config.insertSpaceAfterCommaDelimiter ?? true,
        insertSpaceAfterConstructor: config.insertSpaceAfterConstructor ?? false,
        insertSpaceAfterSemicolonInForStatements: config.insertSpaceAfterSemicolonInForStatements ?? true,
        insertSpaceBeforeAndAfterBinaryOperators: config.insertSpaceBeforeAndAfterBinaryOperators ?? true,
        insertSpaceAfterKeywordsInControlFlowStatements: config.insertSpaceAfterKeywordsInControlFlowStatements ?? true,
        insertSpaceAfterFunctionKeywordForAnonymousFunctions: config.insertSpaceAfterFunctionKeywordForAnonymousFunctions ?? true,
        insertSpaceBeforeFunctionParenthesis: config.insertSpaceBeforeFunctionParenthesis ?? false,
        insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: config.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis ?? false,
        insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: config.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets ?? false,
        insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: config.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces ?? true,
        insertSpaceAfterOpeningAndBeforeClosingEmptyBraces: config.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces ?? true,
        insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: config.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces ?? false,
        insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: config.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces ?? false,
        insertSpaceAfterTypeAssertion: config.insertSpaceAfterTypeAssertion ?? false,
        placeOpenBraceOnNewLineForFunctions: config.placeOpenBraceOnNewLineForFunctions ?? false,
        placeOpenBraceOnNewLineForControlBlocks: config.placeOpenBraceOnNewLineForControlBlocks ?? false,
        semicolons: config.semicolons ?? "ignore"
      };
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/syntaxOnlyService.js
var require_syntaxOnlyService = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/syntaxOnlyService.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSyntaxOnlyService = createSyntaxOnlyService;
    function createSyntaxOnlyService(ts, syntaxOnly) {
      let currentProjectVersion = -1;
      let fileNames = [];
      const scriptInfos = /* @__PURE__ */ new Map();
      const host = {
        getProjectVersion: () => currentProjectVersion.toString(),
        getScriptFileNames: () => fileNames,
        getScriptSnapshot: (fileName) => scriptInfos.get(fileName).snapshot,
        getScriptKind: (fileName) => scriptInfos.get(fileName).kind,
        getScriptVersion: (fileName) => scriptInfos.get(fileName).version.toString(),
        getCompilationSettings: () => ({}),
        getCurrentDirectory: () => "",
        getDefaultLibFileName: () => "",
        readFile: () => void 0,
        fileExists: (fileName) => scriptInfos.has(fileName)
      };
      return {
        languageService: syntaxOnly ? ts.createLanguageService(host, void 0, ts.LanguageServiceMode.Syntactic) : ts.createLanguageService(host),
        updateFile
      };
      function updateFile(fileName, snapshot, scriptKind) {
        let scriptInfo = scriptInfos.get(fileName);
        if (scriptInfo?.snapshot === snapshot && scriptInfo.kind === scriptKind) {
          return;
        }
        currentProjectVersion++;
        scriptInfo = {
          snapshot,
          kind: scriptKind,
          version: (scriptInfo?.version ?? 0) + 1
        };
        const filesChanged = !scriptInfos.has(fileName);
        scriptInfos.set(fileName, scriptInfo);
        if (filesChanged) {
          fileNames = [...scriptInfos.keys()];
        }
      }
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/plugins/syntactic.js
var require_syntactic = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/plugins/syntactic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLanguageServiceByDocument = getLanguageServiceByDocument;
    exports2.create = create;
    var getFormatCodeSettings_1 = require_getFormatCodeSettings();
    var shared_1 = require_shared();
    var syntaxOnlyService_1 = require_syntaxOnlyService();
    var lspConverters_1 = require_lspConverters();
    var snapshots = /* @__PURE__ */ new WeakMap();
    var created;
    function getLanguageServiceByDocument(ts, document) {
      if (!created) {
        created = (0, syntaxOnlyService_1.createSyntaxOnlyService)(ts, true);
      }
      let cache = snapshots.get(document);
      if (!cache || cache[0] !== document.version) {
        const snapshot = ts.ScriptSnapshot.fromString(document.getText());
        cache = [document.version, snapshot];
        snapshots.set(document, cache);
        created.updateFile(document.uri, cache[1], document.languageId === "javascript" ? ts.ScriptKind.JS : document.languageId === "javascriptreact" ? ts.ScriptKind.JSX : document.languageId === "typescriptreact" ? ts.ScriptKind.TSX : ts.ScriptKind.TS);
      }
      return {
        languageService: created.languageService,
        fileName: document.uri
      };
    }
    function create(ts, { isFormattingEnabled = async (document, context) => {
      return await context.env.getConfiguration?.((0, shared_1.getConfigTitle)(document) + ".format.enable") ?? true;
    } } = {}) {
      return {
        name: "typescript-syntactic",
        capabilities: {
          autoInsertionProvider: {
            triggerCharacters: [">", ">"],
            configurationSections: ["javascript.autoClosingTags", "typescript.autoClosingTags"]
          },
          foldingRangeProvider: true,
          selectionRangeProvider: true,
          documentSymbolProvider: true,
          documentFormattingProvider: true,
          documentOnTypeFormattingProvider: {
            // https://github.com/microsoft/vscode/blob/ce119308e8fd4cd3f992d42b297588e7abe33a0c/extensions/typescript-language-features/src/languageFeatures/formatting.ts#L99
            triggerCharacters: [";", "}", "\n"]
          }
        },
        create(context) {
          return {
            async provideAutoInsertSnippet(document, selection, change) {
              if (document.offsetAt(selection) !== change.rangeOffset + change.text.length) {
                return;
              }
              if ((document.languageId === "javascriptreact" || document.languageId === "typescriptreact") && change.text.endsWith(">") && (await context.env.getConfiguration?.((0, shared_1.getConfigTitle)(document) + ".autoClosingTags") ?? true)) {
                const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
                const close = languageService.getJsxClosingTagAtPosition(fileName, document.offsetAt(selection));
                if (close) {
                  return "$0" + close.newText;
                }
              }
            },
            provideFoldingRanges(document) {
              if (!(0, shared_1.isTsDocument)(document)) {
                return;
              }
              const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
              const outliningSpans = (0, shared_1.safeCall)(() => languageService.getOutliningSpans(fileName));
              if (!outliningSpans) {
                return [];
              }
              return outliningSpans.map((span) => (0, lspConverters_1.convertOutliningSpan)(span, document));
            },
            provideSelectionRanges(document, positions) {
              if (!(0, shared_1.isTsDocument)(document)) {
                return;
              }
              const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
              const ranges = positions.map((position) => {
                const offset = document.offsetAt(position);
                const range = (0, shared_1.safeCall)(() => languageService.getSmartSelectionRange(fileName, offset));
                if (!range) {
                  return;
                }
                return (0, lspConverters_1.convertSelectionRange)(range, document);
              });
              if (ranges.every((range) => !!range)) {
                return ranges;
              }
            },
            provideDocumentSymbols(document) {
              if (!(0, shared_1.isTsDocument)(document)) {
                return;
              }
              const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
              const barItems = (0, shared_1.safeCall)(() => languageService.getNavigationTree(fileName));
              if (!barItems) {
                return [];
              }
              return barItems.childItems?.map((item) => (0, lspConverters_1.convertNavTree)(item, document)).flat() ?? [];
            },
            async provideDocumentFormattingEdits(document, range, options, codeOptions) {
              if (!(0, shared_1.isTsDocument)(document)) {
                return;
              }
              if (!await isFormattingEnabled(document, context)) {
                return;
              }
              const tsOptions = await (0, getFormatCodeSettings_1.getFormatCodeSettings)(context, document, options);
              if (codeOptions) {
                tsOptions.baseIndentSize = codeOptions.initialIndentLevel * options.tabSize;
              }
              const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
              const scriptEdits = range ? (0, shared_1.safeCall)(() => languageService.getFormattingEditsForRange(fileName, document.offsetAt(range.start), document.offsetAt(range.end), tsOptions)) : (0, shared_1.safeCall)(() => languageService.getFormattingEditsForDocument(fileName, tsOptions));
              if (!scriptEdits) {
                return [];
              }
              return scriptEdits.map((edit) => (0, lspConverters_1.convertTextChange)(edit, document));
            },
            async provideOnTypeFormattingEdits(document, position, key, options, codeOptions) {
              if (!(0, shared_1.isTsDocument)(document)) {
                return;
              }
              if (!await isFormattingEnabled(document, context)) {
                return;
              }
              const tsOptions = await (0, getFormatCodeSettings_1.getFormatCodeSettings)(context, document, options);
              if (codeOptions) {
                tsOptions.baseIndentSize = codeOptions.initialIndentLevel * options.tabSize;
              }
              const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
              const scriptEdits = (0, shared_1.safeCall)(() => languageService.getFormattingEditsAfterKeystroke(fileName, document.offsetAt(position), key, tsOptions));
              if (!scriptEdits) {
                return [];
              }
              return scriptEdits.map((edit) => (0, lspConverters_1.convertTextChange)(edit, document));
            }
          };
        }
      };
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/plugins/docCommentTemplate.js
var require_docCommentTemplate = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/plugins/docCommentTemplate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.create = create;
    var nls = require_main6();
    var shared_1 = require_shared();
    var lspConverters_1 = require_lspConverters();
    var syntactic_1 = require_syntactic();
    var localize = nls.loadMessageBundle();
    var defaultJsDoc = `/**
 * $0
 */`;
    function create(ts) {
      return {
        name: "typescript-doc-comment-template",
        capabilities: {
          completionProvider: {
            triggerCharacters: ["*"]
          }
        },
        create() {
          return {
            provideCompletionItems(document, position) {
              if (!(0, shared_1.isTsDocument)(document)) {
                return;
              }
              if (!isPotentiallyValidDocCompletionPosition(document, position)) {
                return;
              }
              const { languageService, fileName } = (0, syntactic_1.getLanguageServiceByDocument)(ts, document);
              const offset = document.offsetAt(position);
              const docCommentTemplate = languageService.getDocCommentTemplateAtPosition(fileName, offset);
              if (!docCommentTemplate) {
                return;
              }
              let insertText;
              if (docCommentTemplate.newText === "/** */") {
                insertText = defaultJsDoc;
              } else {
                insertText = templateToSnippet(docCommentTemplate.newText);
              }
              const item = createCompletionItem(document, position, insertText);
              return {
                isIncomplete: false,
                items: [item]
              };
            }
          };
        }
      };
    }
    function createCompletionItem(document, position, insertText) {
      const item = { label: "/** */" };
      item.kind = 1;
      item.detail = localize("typescript.jsDocCompletionItem.documentation", "JSDoc comment");
      item.sortText = "\0";
      item.insertTextFormat = 2;
      const line = (0, lspConverters_1.getLineText)(document, position.line);
      const prefix = line.slice(0, position.character).match(/\/\**\s*$/);
      const suffix = line.slice(position.character).match(/^\s*\**\//);
      const start = {
        line: position.line,
        character: position.character + (prefix ? -prefix[0].length : 0)
      };
      const end = { line: position.line, character: position.character + (suffix ? suffix[0].length : 0) };
      const range = { start, end };
      item.textEdit = { range, newText: insertText };
      return item;
    }
    function isPotentiallyValidDocCompletionPosition(document, position) {
      const line = (0, lspConverters_1.getLineText)(document, position.line);
      const prefix = line.slice(0, position.character);
      if (!/^\s*$|\/\*\*\s*$|^\s*\/\*\*+\s*$/.test(prefix)) {
        return false;
      }
      const suffix = line.slice(position.character);
      return /^\s*(\*+\/)?\s*$/.test(suffix);
    }
    function templateToSnippet(template) {
      let snippetIndex = 1;
      template = template.replace(/\$/g, "\\$");
      template = template.replace(/^[ \t]*(?=(\/|[ ]\*))/gm, "");
      template = template.replace(/^(\/\*\*\s*\*[ ]*)$/m, (x) => x + `$0`);
      template = template.replace(/\* @param([ ]\{\S+\})?\s+(\S+)[ \t]*$/gm, (_param, type, post) => {
        let out = "* @param ";
        if (type === " {any}" || type === " {*}") {
          out += `{\${${snippetIndex++}:*}} `;
        } else if (type) {
          out += type + " ";
        }
        out += post + ` \${${snippetIndex++}}`;
        return out;
      });
      template = template.replace(/\* @returns[ \t]*$/gm, `* @returns \${${snippetIndex++}}`);
      return template;
    }
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_0/index.js
var require__ = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_0/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function default_1(ts, host, _service) {
      var _a, _b;
      const importSuggestionsCache = (_b = (_a = ts.Completions) === null || _a === void 0 ? void 0 : _a.createImportSuggestionsForFileCache) === null || _b === void 0 ? void 0 : _b.call(_a);
      host.getImportSuggestionsCache = () => importSuggestionsCache;
    }
    exports2.default = default_1;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_4/moduleSpecifierCache.js
var require_moduleSpecifierCache = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_4/moduleSpecifierCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createModuleSpecifierCache = void 0;
    function createModuleSpecifierCache() {
      let cache;
      let currentKey;
      const result = {
        get(fromFileName, toFileName, preferences) {
          if (!cache || currentKey !== key(fromFileName, preferences))
            return void 0;
          return cache.get(toFileName);
        },
        set(fromFileName, toFileName, preferences, modulePaths, moduleSpecifiers) {
          ensureCache(fromFileName, preferences).set(toFileName, createInfo(
            modulePaths,
            moduleSpecifiers,
            /*isAutoImportable*/
            true
          ));
          if (moduleSpecifiers) {
            for (const p of modulePaths) {
              if (p.isInNodeModules) {
              }
            }
          }
        },
        setModulePaths(fromFileName, toFileName, preferences, modulePaths) {
          const cache2 = ensureCache(fromFileName, preferences);
          const info = cache2.get(toFileName);
          if (info) {
            info.modulePaths = modulePaths;
          } else {
            cache2.set(toFileName, createInfo(
              modulePaths,
              /*moduleSpecifiers*/
              void 0,
              /*isAutoImportable*/
              void 0
            ));
          }
        },
        setIsAutoImportable(fromFileName, toFileName, preferences, isAutoImportable) {
          const cache2 = ensureCache(fromFileName, preferences);
          const info = cache2.get(toFileName);
          if (info) {
            info.isAutoImportable = isAutoImportable;
          } else {
            cache2.set(toFileName, createInfo(
              /*modulePaths*/
              void 0,
              /*moduleSpecifiers*/
              void 0,
              isAutoImportable
            ));
          }
        },
        clear() {
          cache === null || cache === void 0 ? void 0 : cache.clear();
          currentKey = void 0;
        },
        count() {
          return cache ? cache.size : 0;
        }
      };
      return result;
      function ensureCache(fromFileName, preferences) {
        const newKey = key(fromFileName, preferences);
        if (cache && currentKey !== newKey) {
          result.clear();
        }
        currentKey = newKey;
        return cache || (cache = /* @__PURE__ */ new Map());
      }
      function key(fromFileName, preferences) {
        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference}`;
      }
      function createInfo(modulePaths, moduleSpecifiers, isAutoImportable) {
        return { modulePaths, moduleSpecifiers, isAutoImportable };
      }
    }
    exports2.createModuleSpecifierCache = createModuleSpecifierCache;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_4/packageJsonCache.js
var require_packageJsonCache = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_4/packageJsonCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPackageJsonCache = exports2.canCreatePackageJsonCache = void 0;
    function canCreatePackageJsonCache(ts) {
      return "createPackageJsonInfo" in ts && "getDirectoryPath" in ts && "combinePaths" in ts && "tryFileExists" in ts && "forEachAncestorDirectory" in ts;
    }
    exports2.canCreatePackageJsonCache = canCreatePackageJsonCache;
    function createPackageJsonCache(ts, host) {
      const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts;
      const packageJsons = /* @__PURE__ */ new Map();
      const directoriesWithoutPackageJson = /* @__PURE__ */ new Map();
      return {
        addOrUpdate,
        // @ts-expect-error
        forEach: packageJsons.forEach.bind(packageJsons),
        get: packageJsons.get.bind(packageJsons),
        delete: (fileName) => {
          packageJsons.delete(fileName);
          directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
        },
        getInDirectory: (directory) => {
          return packageJsons.get(combinePaths(directory, "package.json")) || void 0;
        },
        directoryHasPackageJson,
        searchDirectoryAndAncestors: (directory) => {
          forEachAncestorDirectory(directory, (ancestor) => {
            if (directoryHasPackageJson(ancestor) !== 3) {
              return true;
            }
            const packageJsonFileName = host.toPath(combinePaths(ancestor, "package.json"));
            if (tryFileExists(host, packageJsonFileName)) {
              addOrUpdate(packageJsonFileName);
            } else {
              directoriesWithoutPackageJson.set(ancestor, true);
            }
          });
        }
      };
      function addOrUpdate(fileName) {
        const packageJsonInfo = (
          // Debug.checkDefined(
          createPackageJsonInfo(fileName, host.host)
        );
        packageJsons.set(fileName, packageJsonInfo);
        directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
      }
      function directoryHasPackageJson(directory) {
        return packageJsons.has(combinePaths(directory, "package.json")) ? -1 : directoriesWithoutPackageJson.has(directory) ? 0 : 3;
      }
    }
    exports2.createPackageJsonCache = createPackageJsonCache;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_4/index.js
var require__2 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_4/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var moduleSpecifierCache_1 = require_moduleSpecifierCache();
    var packageJsonCache_1 = require_packageJsonCache();
    function default_1(ts, host, service) {
      const _createCacheableExportInfoMap = ts.createCacheableExportInfoMap;
      const _combinePaths = ts.combinePaths;
      const _forEachAncestorDirectory = ts.forEachAncestorDirectory;
      const _getDirectoryPath = ts.getDirectoryPath;
      const _toPath = ts.toPath;
      const _createGetCanonicalFileName = ts.createGetCanonicalFileName;
      if (!_createCacheableExportInfoMap || !_combinePaths || !_forEachAncestorDirectory || !_getDirectoryPath || !_toPath || !_createGetCanonicalFileName || !(0, packageJsonCache_1.canCreatePackageJsonCache)(ts))
        return;
      const moduleSpecifierCache = (0, moduleSpecifierCache_1.createModuleSpecifierCache)();
      const exportMapCache = _createCacheableExportInfoMap({
        getCurrentProgram() {
          return service.getProgram();
        },
        getPackageJsonAutoImportProvider() {
          return service.getProgram();
        }
      });
      const packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts, Object.assign(Object.assign({}, host), {
        // @ts-expect-error
        host: Object.assign({}, host),
        toPath
      }));
      host.getCachedExportInfoMap = () => exportMapCache;
      host.getModuleSpecifierCache = () => moduleSpecifierCache;
      host.getPackageJsonsVisibleToFile = (fileName, rootDir) => {
        const rootPath = rootDir && toPath(rootDir);
        const filePath = toPath(fileName);
        const result = [];
        const processDirectory = (directory) => {
          switch (packageJsonCache.directoryHasPackageJson(directory)) {
            // Sync and check same directory again
            case 3:
              packageJsonCache.searchDirectoryAndAncestors(directory);
              return processDirectory(directory);
            // Check package.json
            case -1:
              const info = packageJsonCache.getInDirectory(directory);
              if (info)
                result.push(info);
          }
          if (rootPath && rootPath === directory) {
            return true;
          }
        };
        _forEachAncestorDirectory(_getDirectoryPath(filePath), processDirectory);
        return result;
      };
      function toPath(fileName) {
        var _a;
        return _toPath(fileName, host.getCurrentDirectory(), _createGetCanonicalFileName((_a = host.useCaseSensitiveFileNames) === null || _a === void 0 ? void 0 : _a.call(host)));
      }
    }
    exports2.default = default_1;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_7/moduleSpecifierCache.js
var require_moduleSpecifierCache2 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_7/moduleSpecifierCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createModuleSpecifierCache = exports2.nodeModulesPathPart = void 0;
    exports2.nodeModulesPathPart = "/node_modules/";
    function createModuleSpecifierCache() {
      let containedNodeModulesWatchers;
      let cache;
      let currentKey;
      const result = {
        get(fromFileName, toFileName, preferences, options) {
          if (!cache || currentKey !== key(fromFileName, preferences, options))
            return void 0;
          return cache.get(toFileName);
        },
        set(fromFileName, toFileName, preferences, options, modulePaths, moduleSpecifiers) {
          ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(
            modulePaths,
            moduleSpecifiers,
            /*isBlockedByPackageJsonDependencies*/
            false
          ));
          if (moduleSpecifiers) {
            for (const p of modulePaths) {
              if (p.isInNodeModules) {
              }
            }
          }
        },
        setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
          const cache2 = ensureCache(fromFileName, preferences, options);
          const info = cache2.get(toFileName);
          if (info) {
            info.modulePaths = modulePaths;
          } else {
            cache2.set(toFileName, createInfo(
              modulePaths,
              /*moduleSpecifiers*/
              void 0,
              /*isBlockedByPackageJsonDependencies*/
              void 0
            ));
          }
        },
        setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, isBlockedByPackageJsonDependencies) {
          const cache2 = ensureCache(fromFileName, preferences, options);
          const info = cache2.get(toFileName);
          if (info) {
            info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
          } else {
            cache2.set(toFileName, createInfo(
              /*modulePaths*/
              void 0,
              /*moduleSpecifiers*/
              void 0,
              isBlockedByPackageJsonDependencies
            ));
          }
        },
        clear() {
          containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.forEach((watcher) => watcher.close());
          cache === null || cache === void 0 ? void 0 : cache.clear();
          containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.clear();
          currentKey = void 0;
        },
        count() {
          return cache ? cache.size : 0;
        }
      };
      return result;
      function ensureCache(fromFileName, preferences, options) {
        const newKey = key(fromFileName, preferences, options);
        if (cache && currentKey !== newKey) {
          result.clear();
        }
        currentKey = newKey;
        return cache || (cache = /* @__PURE__ */ new Map());
      }
      function key(fromFileName, preferences, options) {
        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
      }
      function createInfo(modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies) {
        return { modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies };
      }
    }
    exports2.createModuleSpecifierCache = createModuleSpecifierCache;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_7/packageJsonCache.js
var require_packageJsonCache2 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_7/packageJsonCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPackageJsonCache = void 0;
    function createPackageJsonCache(ts, host) {
      const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts;
      const packageJsons = /* @__PURE__ */ new Map();
      const directoriesWithoutPackageJson = /* @__PURE__ */ new Map();
      return {
        addOrUpdate,
        forEach: packageJsons.forEach.bind(packageJsons),
        get: packageJsons.get.bind(packageJsons),
        delete: (fileName) => {
          packageJsons.delete(fileName);
          directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
        },
        getInDirectory: (directory) => {
          return packageJsons.get(combinePaths(directory, "package.json")) || void 0;
        },
        directoryHasPackageJson,
        searchDirectoryAndAncestors: (directory) => {
          forEachAncestorDirectory(directory, (ancestor) => {
            if (directoryHasPackageJson(ancestor) !== 3) {
              return true;
            }
            const packageJsonFileName = host.toPath(combinePaths(ancestor, "package.json"));
            if (tryFileExists(host, packageJsonFileName)) {
              addOrUpdate(packageJsonFileName);
            } else {
              directoriesWithoutPackageJson.set(ancestor, true);
            }
          });
        }
      };
      function addOrUpdate(fileName) {
        const packageJsonInfo = (
          // Debug.checkDefined(
          createPackageJsonInfo(fileName, host.host)
        );
        packageJsons.set(fileName, packageJsonInfo);
        directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
      }
      function directoryHasPackageJson(directory) {
        return packageJsons.has(combinePaths(directory, "package.json")) ? -1 : directoriesWithoutPackageJson.has(directory) ? 0 : 3;
      }
    }
    exports2.createPackageJsonCache = createPackageJsonCache;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_7/index.js
var require__3 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/4_7/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var moduleSpecifierCache_1 = require_moduleSpecifierCache2();
    var packageJsonCache_1 = require_packageJsonCache2();
    function default_1(ts, host, service) {
      const _createCacheableExportInfoMap = ts.createCacheableExportInfoMap;
      const _combinePaths = ts.combinePaths;
      const _forEachAncestorDirectory = ts.forEachAncestorDirectory;
      const _getDirectoryPath = ts.getDirectoryPath;
      const _toPath = ts.toPath;
      const _createGetCanonicalFileName = ts.createGetCanonicalFileName;
      if (!_createCacheableExportInfoMap || !_combinePaths || !_forEachAncestorDirectory || !_getDirectoryPath || !_toPath || !_createGetCanonicalFileName)
        return;
      const moduleSpecifierCache = (0, moduleSpecifierCache_1.createModuleSpecifierCache)();
      const exportMapCache = _createCacheableExportInfoMap({
        getCurrentProgram() {
          return service.getProgram();
        },
        getPackageJsonAutoImportProvider() {
          return service.getProgram();
        },
        getGlobalTypingsCacheLocation() {
          return void 0;
        }
      });
      const packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts, Object.assign(Object.assign({}, host), {
        // @ts-expect-error
        host: Object.assign({}, host),
        toPath
      }));
      host.getCachedExportInfoMap = () => exportMapCache;
      host.getModuleSpecifierCache = () => moduleSpecifierCache;
      host.getPackageJsonsVisibleToFile = (fileName, rootDir) => {
        const rootPath = rootDir && toPath(rootDir);
        const filePath = toPath(fileName);
        const result = [];
        const processDirectory = (directory) => {
          switch (packageJsonCache.directoryHasPackageJson(directory)) {
            // Sync and check same directory again
            case 3:
              packageJsonCache.searchDirectoryAndAncestors(directory);
              return processDirectory(directory);
            // Check package.json
            case -1:
              const info = packageJsonCache.getInDirectory(directory);
              if (info)
                result.push(info);
          }
          if (rootPath && rootPath === directory) {
            return true;
          }
        };
        _forEachAncestorDirectory(_getDirectoryPath(filePath), processDirectory);
        return result;
      };
      function toPath(fileName) {
        var _a;
        return _toPath(fileName, host.getCurrentDirectory(), _createGetCanonicalFileName((_a = host.useCaseSensitiveFileNames) === null || _a === void 0 ? void 0 : _a.call(host)));
      }
    }
    exports2.default = default_1;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/packageJsonCache.js
var require_packageJsonCache3 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/packageJsonCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPackageJsonCache = void 0;
    function createPackageJsonCache(ts, host) {
      const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts;
      const packageJsons = /* @__PURE__ */ new Map();
      const directoriesWithoutPackageJson = /* @__PURE__ */ new Map();
      return {
        addOrUpdate,
        // @ts-expect-error
        forEach: packageJsons.forEach.bind(packageJsons),
        get: packageJsons.get.bind(packageJsons),
        delete: (fileName) => {
          packageJsons.delete(fileName);
          directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
        },
        getInDirectory: (directory) => {
          return packageJsons.get(combinePaths(directory, "package.json")) || void 0;
        },
        directoryHasPackageJson,
        searchDirectoryAndAncestors: (directory) => {
          forEachAncestorDirectory(directory, (ancestor) => {
            if (directoryHasPackageJson(ancestor) !== 3) {
              return true;
            }
            const packageJsonFileName = host.toPath(combinePaths(ancestor, "package.json"));
            if (tryFileExists(host, packageJsonFileName)) {
              addOrUpdate(packageJsonFileName);
            } else {
              directoriesWithoutPackageJson.set(ancestor, true);
            }
          });
        }
      };
      function addOrUpdate(fileName) {
        const packageJsonInfo = (
          /*Debug.checkDefined( */
          createPackageJsonInfo(fileName, host.host)
        );
        packageJsons.set(fileName, packageJsonInfo);
        directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
      }
      function directoryHasPackageJson(directory) {
        return packageJsons.has(combinePaths(directory, "package.json")) ? -1 : directoriesWithoutPackageJson.has(directory) ? 0 : 3;
      }
    }
    exports2.createPackageJsonCache = createPackageJsonCache;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/projectService.js
var require_projectService = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/projectService.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProjectService = void 0;
    var packageJsonCache_1 = require_packageJsonCache3();
    function createProjectService(ts, sys, currentDirectory, hostConfiguration, serverMode) {
      const { toPath, getNormalizedAbsolutePath, normalizePath: toNormalizedPath, createGetCanonicalFileName, forEachAncestorDirectory, getDirectoryPath } = ts;
      const projectService = {
        serverMode,
        host: sys,
        currentDirectory: toNormalizedPath(currentDirectory),
        toCanonicalFileName: createGetCanonicalFileName(sys.useCaseSensitiveFileNames),
        toPath(fileName) {
          return toPath(fileName, this.currentDirectory, this.toCanonicalFileName);
        },
        getExecutingFilePath() {
          return this.getNormalizedAbsolutePath(this.host.getExecutingFilePath());
        },
        getNormalizedAbsolutePath(fileName) {
          return getNormalizedAbsolutePath(fileName, this.host.getCurrentDirectory());
        },
        packageJsonCache: void 0,
        getPackageJsonsVisibleToFile(fileName, rootDir) {
          const packageJsonCache = this.packageJsonCache;
          const rootPath = rootDir && this.toPath(rootDir);
          const filePath = this.toPath(fileName);
          const result = [];
          const processDirectory = (directory) => {
            switch (packageJsonCache.directoryHasPackageJson(directory)) {
              // Sync and check same directory again
              case 3:
                packageJsonCache.searchDirectoryAndAncestors(directory);
                return processDirectory(directory);
              // Check package.json
              case -1:
                const info = packageJsonCache.getInDirectory(directory);
                if (info)
                  result.push(info);
            }
            if (rootPath && rootPath === directory) {
              return true;
            }
          };
          forEachAncestorDirectory(getDirectoryPath(filePath), processDirectory);
          return result;
        },
        includePackageJsonAutoImports() {
          switch (hostConfiguration.preferences.includePackageJsonAutoImports) {
            case "on":
              return 1;
            case "off":
              return 0;
            default:
              return 2;
          }
        },
        fileExists(fileName) {
          return this.host.fileExists(fileName);
        }
      };
      projectService.packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts, projectService);
      return projectService;
    }
    exports2.createProjectService = createProjectService;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/moduleSpecifierCache.js
var require_moduleSpecifierCache3 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/moduleSpecifierCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createModuleSpecifierCache = exports2.nodeModulesPathPart = void 0;
    exports2.nodeModulesPathPart = "/node_modules/";
    function createModuleSpecifierCache() {
      let containedNodeModulesWatchers;
      let cache;
      let currentKey;
      const result = {
        get(fromFileName, toFileName, preferences, options) {
          if (!cache || currentKey !== key(fromFileName, preferences, options))
            return void 0;
          return cache.get(toFileName);
        },
        set(fromFileName, toFileName, preferences, options, modulePaths, moduleSpecifiers) {
          ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(
            modulePaths,
            moduleSpecifiers,
            /*isBlockedByPackageJsonDependencies*/
            false
          ));
          if (moduleSpecifiers) {
            for (const p of modulePaths) {
              if (p.isInNodeModules) {
              }
            }
          }
        },
        setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
          const cache2 = ensureCache(fromFileName, preferences, options);
          const info = cache2.get(toFileName);
          if (info) {
            info.modulePaths = modulePaths;
          } else {
            cache2.set(toFileName, createInfo(
              modulePaths,
              /*moduleSpecifiers*/
              void 0,
              /*isBlockedByPackageJsonDependencies*/
              void 0
            ));
          }
        },
        setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, isBlockedByPackageJsonDependencies) {
          const cache2 = ensureCache(fromFileName, preferences, options);
          const info = cache2.get(toFileName);
          if (info) {
            info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
          } else {
            cache2.set(toFileName, createInfo(
              /*modulePaths*/
              void 0,
              /*moduleSpecifiers*/
              void 0,
              isBlockedByPackageJsonDependencies
            ));
          }
        },
        clear() {
          containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.forEach((watcher) => watcher.close());
          cache === null || cache === void 0 ? void 0 : cache.clear();
          containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.clear();
          currentKey = void 0;
        },
        count() {
          return cache ? cache.size : 0;
        }
      };
      return result;
      function ensureCache(fromFileName, preferences, options) {
        const newKey = key(fromFileName, preferences, options);
        if (cache && currentKey !== newKey) {
          result.clear();
        }
        currentKey = newKey;
        return cache || (cache = /* @__PURE__ */ new Map());
      }
      function key(fromFileName, preferences, options) {
        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
      }
      function createInfo(modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies) {
        return { modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies };
      }
    }
    exports2.createModuleSpecifierCache = createModuleSpecifierCache;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/autoImportProviderProject.js
var require_autoImportProviderProject = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/autoImportProviderProject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAutoImportProviderProjectStatic = void 0;
    var project_1 = require_project();
    function createAutoImportProviderProjectStatic(tsBase, host, createLanguageService) {
      const ts = tsBase;
      const { combinePaths, inferredTypesContainingFile, arrayFrom, resolvePackageNameToPackageJson, concatenate, forEach, startsWith, getEntrypointsFromPackageJsonInfo, mapDefined, timestamp } = ts;
      return {
        maxDependencies: 10,
        compilerOptionsOverrides: {
          diagnostics: false,
          skipLibCheck: true,
          sourceMap: false,
          types: ts.emptyArray,
          lib: ts.emptyArray,
          noLib: true
        },
        getRootFileNames(dependencySelection, hostProject, moduleResolutionHost, compilerOptions) {
          var _a, _b;
          if (!dependencySelection) {
            return ts.emptyArray;
          }
          const program = hostProject.getCurrentProgram();
          if (!program) {
            return ts.emptyArray;
          }
          const start = timestamp();
          let dependencyNames;
          let rootNames;
          const rootFileName = combinePaths(hostProject.currentDirectory, inferredTypesContainingFile);
          const packageJsons = hostProject.getPackageJsonsForAutoImport(combinePaths(hostProject.currentDirectory, rootFileName));
          for (const packageJson of packageJsons) {
            (_a = packageJson.dependencies) === null || _a === void 0 ? void 0 : _a.forEach((_, dependenyName) => addDependency(dependenyName));
            (_b = packageJson.peerDependencies) === null || _b === void 0 ? void 0 : _b.forEach((_, dependencyName) => addDependency(dependencyName));
          }
          let dependenciesAdded = 0;
          if (dependencyNames) {
            const symlinkCache = hostProject.getSymlinkCache();
            for (const name of arrayFrom(dependencyNames.keys())) {
              if (dependencySelection === 2 && dependenciesAdded > this.maxDependencies) {
                hostProject.log(`AutoImportProviderProject: attempted to add more than ${this.maxDependencies} dependencies. Aborting.`);
                return ts.emptyArray;
              }
              const packageJson = resolvePackageNameToPackageJson(
                name,
                hostProject.currentDirectory,
                compilerOptions,
                moduleResolutionHost,
                // @ts-expect-error
                program.getModuleResolutionCache()
              );
              if (packageJson) {
                const entrypoints = getRootNamesFromPackageJson(packageJson, program, symlinkCache);
                if (entrypoints) {
                  rootNames = concatenate(rootNames, entrypoints);
                  dependenciesAdded += entrypoints.length ? 1 : 0;
                  continue;
                }
              }
              const done = forEach([hostProject.currentDirectory, hostProject.getGlobalTypingsCacheLocation()], (directory) => {
                if (directory) {
                  const typesPackageJson = resolvePackageNameToPackageJson(
                    `@types/${name}`,
                    directory,
                    compilerOptions,
                    moduleResolutionHost,
                    // @ts-expect-error
                    program.getModuleResolutionCache()
                  );
                  if (typesPackageJson) {
                    const entrypoints = getRootNamesFromPackageJson(typesPackageJson, program, symlinkCache);
                    rootNames = concatenate(rootNames, entrypoints);
                    dependenciesAdded += (entrypoints === null || entrypoints === void 0 ? void 0 : entrypoints.length) ? 1 : 0;
                    return true;
                  }
                }
              });
              if (done)
                continue;
              if (packageJson && compilerOptions.allowJs && compilerOptions.maxNodeModuleJsDepth) {
                const entrypoints = getRootNamesFromPackageJson(
                  packageJson,
                  program,
                  symlinkCache,
                  /*allowJs*/
                  true
                );
                rootNames = concatenate(rootNames, entrypoints);
                dependenciesAdded += (entrypoints === null || entrypoints === void 0 ? void 0 : entrypoints.length) ? 1 : 0;
              }
            }
          }
          if (rootNames === null || rootNames === void 0 ? void 0 : rootNames.length) {
            hostProject.log(`AutoImportProviderProject: found ${rootNames.length} root files in ${dependenciesAdded} dependencies in ${timestamp() - start} ms`);
          }
          return rootNames || ts.emptyArray;
          function addDependency(dependency) {
            if (!startsWith(dependency, "@types/")) {
              (dependencyNames || (dependencyNames = /* @__PURE__ */ new Set())).add(dependency);
            }
          }
          function getRootNamesFromPackageJson(packageJson, program2, symlinkCache, resolveJs) {
            var _a2;
            const entrypoints = getEntrypointsFromPackageJsonInfo(
              packageJson,
              compilerOptions,
              moduleResolutionHost,
              // @ts-expect-error
              program2.getModuleResolutionCache(),
              resolveJs
            );
            if (entrypoints) {
              if (entrypoints.length > 100)
                return;
              const real = (_a2 = moduleResolutionHost.realpath) === null || _a2 === void 0 ? void 0 : _a2.call(moduleResolutionHost, packageJson.packageDirectory);
              const isSymlink = real && real !== packageJson.packageDirectory;
              if (isSymlink) {
                symlinkCache.setSymlinkedDirectory(packageJson.packageDirectory, {
                  real,
                  realPath: hostProject.toPath(real)
                });
              }
              return mapDefined(entrypoints, (entrypoint) => {
                const resolvedFileName = isSymlink ? entrypoint.replace(packageJson.packageDirectory, real) : entrypoint;
                if (!program2.getSourceFile(resolvedFileName) && !(isSymlink && program2.getSourceFile(entrypoint))) {
                  return resolvedFileName;
                }
              });
            }
          }
        },
        create(dependencySelection, hostProject, moduleResolutionHost) {
          if (dependencySelection === 0) {
            return void 0;
          }
          const compilerOptions = Object.assign(Object.assign({}, hostProject.getCompilerOptions()), this.compilerOptionsOverrides);
          let rootNames = this.getRootFileNames(dependencySelection, hostProject, moduleResolutionHost, compilerOptions);
          if (!rootNames.length) {
            return void 0;
          }
          return createAutoImportProviderProject(tsBase, host, createLanguageService, { self: this, hostProject, rootNames, compilerOptions });
        }
      };
    }
    exports2.createAutoImportProviderProjectStatic = createAutoImportProviderProjectStatic;
    function createAutoImportProviderProject(tsBase, host, createLanguageService, options) {
      const { self, rootNames, compilerOptions, hostProject } = options;
      const ts = tsBase;
      const { some } = ts;
      const project = Object.assign(Object.assign({}, (0, project_1.createProject)(tsBase, host, createLanguageService, {
        projectService: hostProject.projectService,
        currentDirectory: hostProject.currentDirectory,
        compilerOptions
      })), {
        projectVersion: 0,
        getProjectVersion() {
          return this.projectVersion.toString();
        },
        rootFileNames: rootNames,
        hostProject,
        isEmpty() {
          return !some(this.rootFileNames);
        },
        isOrphan() {
          return true;
        },
        updateGraph() {
          var _a;
          let rootFileNames = this.rootFileNames;
          if (!rootFileNames) {
            rootFileNames = self.getRootFileNames(this.hostProject.includePackageJsonAutoImports(), this.hostProject, this.hostProject.getModuleResolutionHostForAutoImportProvider(), this.getCompilationSettings());
          }
          this.rootFileNames = rootFileNames;
          const oldProgram = this.getCurrentProgram();
          this.program = (_a = this.languageService) === null || _a === void 0 ? void 0 : _a.getProgram();
          this.dirty = false;
          if (oldProgram && oldProgram !== this.getCurrentProgram()) {
            this.hostProject.clearCachedExportInfoMap();
          }
        },
        scheduleInvalidateResolutionsOfFailedLookupLocations() {
          return;
        },
        hasRoots() {
          var _a;
          return !!((_a = this.rootFileNames) === null || _a === void 0 ? void 0 : _a.length);
        },
        markAsDirty() {
          if (!this.dirty) {
            this.rootFileNames = void 0;
            this.projectVersion++;
            this.dirty = true;
          }
        },
        getScriptFileNames() {
          return this.rootFileNames || ts.emptyArray;
        },
        getLanguageService() {
          throw new Error("AutoImportProviderProject language service should never be used. To get the program, use `project.getCurrentProgram()`.");
        },
        onAutoImportProviderSettingsChanged() {
          throw new Error("AutoImportProviderProject is an auto import provider; use `markAsDirty()` instead.");
        },
        onPackageJsonChange() {
          throw new Error("package.json changes should be notified on an AutoImportProvider's host project");
        },
        getModuleResolutionHostForAutoImportProvider() {
          throw new Error("AutoImportProviderProject cannot provide its own host; use `hostProject.getModuleResolutionHostForAutomImportProvider()` instead.");
        },
        includePackageJsonAutoImports() {
          return 0;
        },
        getTypeAcquisition() {
          return { enable: false };
        },
        getSymlinkCache() {
          return this.hostProject.getSymlinkCache();
        },
        getModuleResolutionCache() {
          var _a, _b;
          return (_b = (_a = this.hostProject.languageService) === null || _a === void 0 ? void 0 : _a.getProgram()) === null || _b === void 0 ? void 0 : _b.getModuleResolutionCache();
        }
      });
      return (0, project_1.initProject)(project, new Proxy(host, {
        get(target, key) {
          return key in project ? project[key] : target[key];
        },
        set(_target, key, value) {
          project[key] = value;
          return true;
        }
      }), createLanguageService);
    }
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/project.js
var require_project = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/project.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initProject = exports2.createProject = void 0;
    var moduleSpecifierCache_1 = require_moduleSpecifierCache3();
    var autoImportProviderProject_1 = require_autoImportProviderProject();
    function createProject(ts, host, createLanguageService, options) {
      var _a, _b;
      const { combinePaths, inferredTypesContainingFile, createSymlinkCache, toPath, createCacheableExportInfoMap, timestamp, isInsideNodeModules, LanguageServiceMode } = ts;
      const tsCreateModuleSpecifierCache = (_a = ts.server) === null || _a === void 0 ? void 0 : _a.createModuleSpecifierCache;
      const noopHost = {
        watchNodeModulesForPackageJsonChanges: () => ({ close: () => {
        } }),
        toPath(fileName) {
          return toPath(fileName, host.getCurrentDirectory(), projectService.toCanonicalFileName);
        }
      };
      const AutoImportProviderProject = (0, autoImportProviderProject_1.createAutoImportProviderProjectStatic)(ts, host, createLanguageService);
      const { projectService, compilerOptions, currentDirectory } = options;
      function updateProjectIfDirty(project) {
        return project.dirty && project.updateGraph();
      }
      return {
        dirty: false,
        hostProject: void 0,
        languageServiceEnabled: true,
        languageService: void 0,
        projectService,
        getCanonicalFileName: projectService.toCanonicalFileName,
        exportMapCache: void 0,
        getCachedExportInfoMap() {
          return this.exportMapCache || (this.exportMapCache = createCacheableExportInfoMap(this));
        },
        clearCachedExportInfoMap() {
          var _a2;
          (_a2 = this.exportMapCache) === null || _a2 === void 0 ? void 0 : _a2.clear();
        },
        moduleSpecifierCache: tsCreateModuleSpecifierCache ? tsCreateModuleSpecifierCache(noopHost) : ((_b = options.createModuleSpecifierCache) !== null && _b !== void 0 ? _b : moduleSpecifierCache_1.createModuleSpecifierCache)(),
        getModuleSpecifierCache() {
          return this.moduleSpecifierCache;
        },
        compilerOptions,
        getCompilationSettings() {
          return this.compilerOptions;
        },
        getCompilerOptions() {
          return this.compilerOptions;
        },
        program: void 0,
        getCurrentProgram() {
          return this.program;
        },
        currentDirectory: projectService.getNormalizedAbsolutePath(currentDirectory || ""),
        getCurrentDirectory() {
          return this.currentDirectory;
        },
        symlinks: void 0,
        getSymlinkCache() {
          if (!this.symlinks) {
            this.symlinks = createSymlinkCache(this.getCurrentDirectory(), this.getCanonicalFileName);
          }
          if (this.program && !this.symlinks.hasProcessedResolutions()) {
            this.symlinks.setSymlinksFromResolutions(
              this.program.getSourceFiles(),
              // @ts-expect-error
              this.program.getAutomaticTypeDirectiveResolutions()
            );
          }
          return this.symlinks;
        },
        packageJsonsForAutoImport: void 0,
        getPackageJsonsForAutoImport(rootDir) {
          const packageJsons = this.getPackageJsonsVisibleToFile(combinePaths(this.currentDirectory, inferredTypesContainingFile), rootDir);
          this.packageJsonsForAutoImport = new Set(packageJsons.map((p) => p.fileName));
          return packageJsons;
        },
        getPackageJsonsVisibleToFile(fileName, rootDir) {
          return this.projectService.getPackageJsonsVisibleToFile(fileName, rootDir);
        },
        getModuleResolutionHostForAutoImportProvider() {
          var _a2;
          if (this.program) {
            return {
              // @ts-expect-error
              fileExists: this.program.fileExists,
              // @ts-expect-error
              directoryExists: this.program.directoryExists,
              // @ts-expect-error
              realpath: this.program.realpath || ((_a2 = this.projectService.host.realpath) === null || _a2 === void 0 ? void 0 : _a2.bind(this.projectService.host)),
              getCurrentDirectory: this.getCurrentDirectory.bind(this),
              readFile: this.projectService.host.readFile.bind(this.projectService.host),
              getDirectories: this.projectService.host.getDirectories.bind(this.projectService.host),
              // trace: this.projectService.host.trace?.bind(this.projectService.host),
              trace: () => {
              },
              // @ts-expect-error
              useCaseSensitiveFileNames: this.program.useCaseSensitiveFileNames()
            };
          }
          return this.projectService.host;
        },
        autoImportProviderHost: void 0,
        getPackageJsonAutoImportProvider() {
          if (this.autoImportProviderHost === false) {
            return void 0;
          }
          if (this.projectService.serverMode !== LanguageServiceMode.Semantic) {
            this.autoImportProviderHost = false;
            return void 0;
          }
          if (this.autoImportProviderHost) {
            updateProjectIfDirty(this.autoImportProviderHost);
            if (this.autoImportProviderHost.isEmpty()) {
              this.autoImportProviderHost.close();
              this.autoImportProviderHost = void 0;
              return void 0;
            }
            return this.autoImportProviderHost.getCurrentProgram();
          }
          const dependencySelection = projectService.includePackageJsonAutoImports();
          if (dependencySelection) {
            const start = timestamp();
            this.autoImportProviderHost = AutoImportProviderProject.create(dependencySelection, this, this.getModuleResolutionHostForAutoImportProvider());
            if (this.autoImportProviderHost) {
              updateProjectIfDirty(this.autoImportProviderHost);
              this.sendPerformanceEvent("CreatePackageJsonAutoImportProvider", timestamp() - start);
              return this.autoImportProviderHost.getCurrentProgram();
            }
          }
        },
        includePackageJsonAutoImports() {
          if (this.projectService.includePackageJsonAutoImports() === 0 || !this.languageServiceEnabled || isInsideNodeModules(this.currentDirectory)) {
            return 0;
          }
          return this.projectService.includePackageJsonAutoImports();
        },
        close() {
        },
        log(_message) {
        },
        sendPerformanceEvent(_kind, _durationMs) {
        },
        toPath(fileName) {
          return toPath(fileName, this.currentDirectory, this.projectService.toCanonicalFileName);
        },
        getGlobalTypingsCacheLocation() {
          return void 0;
        },
        useSourceOfProjectReferenceRedirect() {
          return !this.getCompilerOptions().disableSourceOfProjectReferenceRedirect;
        },
        onAutoImportProviderSettingsChanged() {
          var _a2;
          if (this.autoImportProviderHost === false) {
            this.autoImportProviderHost = void 0;
          } else {
            (_a2 = this.autoImportProviderHost) === null || _a2 === void 0 ? void 0 : _a2.markAsDirty();
          }
        }
      };
    }
    exports2.createProject = createProject;
    function initProject(project, host, createLanguageService) {
      const languageService = createLanguageService(host);
      project.languageService = languageService;
      project.program = languageService.getProgram();
      return project;
    }
    exports2.initProject = initProject;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/index.js
var require__4 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_0/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var projectService_1 = require_projectService();
    var project_1 = require_project();
    var projectService;
    var projects = /* @__PURE__ */ new Set();
    function default_1(ts, sys, host, createLanguageService, _createProject = project_1.createProject) {
      const hostConfiguration = { preferences: { includePackageJsonAutoImports: "auto" } };
      if (!projectService) {
        projectService = (0, projectService_1.createProjectService)(ts, sys, host.getCurrentDirectory(), hostConfiguration, ts.LanguageServiceMode.Semantic);
      }
      const project = _createProject(ts, host, createLanguageService, {
        projectService,
        currentDirectory: host.getCurrentDirectory(),
        compilerOptions: host.getCompilationSettings()
      });
      const proxyMethods = [
        "getCachedExportInfoMap",
        "getModuleSpecifierCache",
        "getGlobalTypingsCacheLocation",
        "getSymlinkCache",
        "getPackageJsonsVisibleToFile",
        "getPackageJsonAutoImportProvider",
        "includePackageJsonAutoImports",
        "useSourceOfProjectReferenceRedirect"
      ];
      proxyMethods.forEach((key) => host[key] = project[key].bind(project));
      (0, project_1.initProject)(project, host, createLanguageService);
      projects.add(project);
      return {
        languageService: project.languageService,
        setPreferences(newPreferences) {
          let onAutoImportProviderSettingsChanged = newPreferences.includePackageJsonAutoImports !== hostConfiguration.preferences.includePackageJsonAutoImports;
          hostConfiguration.preferences = newPreferences;
          if (onAutoImportProviderSettingsChanged) {
            project.onAutoImportProviderSettingsChanged();
          }
        },
        projectUpdated(path3) {
          projects.forEach((projectToUpdate) => {
            var _a, _b, _c;
            if (project === projectToUpdate || !projectToUpdate.autoImportProviderHost)
              return;
            const realPaths = [...(_c = (_b = (_a = projectToUpdate.symlinks) === null || _a === void 0 ? void 0 : _a.getSymlinkedDirectoriesByRealpath()) === null || _b === void 0 ? void 0 : _b.keys()) !== null && _c !== void 0 ? _c : []].map((name) => projectToUpdate.projectService.getNormalizedAbsolutePath(name));
            if (realPaths.includes(projectToUpdate.projectService.toCanonicalFileName(path3))) {
              projectToUpdate.autoImportProviderHost.markAsDirty();
            }
          });
        }
      };
    }
    exports2.default = default_1;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_3/project.js
var require_project2 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_3/project.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProject = void 0;
    var project_1 = require_project();
    function createProject(ts, host, createLanguageService, options) {
      const { createSymlinkCache, ensureTrailingDirectorySeparator } = ts;
      const project = (0, project_1.createProject)(ts, host, createLanguageService, options);
      project.getSymlinkCache = () => {
        if (!project.symlinks) {
          project.symlinks = createSymlinkCache(project.getCurrentDirectory(), project.getCanonicalFileName);
          const setSymlinkedDirectory = project.symlinks.setSymlinkedDirectory;
          project.symlinks.setSymlinkedDirectory = (symlink, real) => {
            if (typeof real === "object") {
              real.real = ensureTrailingDirectorySeparator(real.real);
              real.realPath = ensureTrailingDirectorySeparator(real.realPath);
            }
            setSymlinkedDirectory(symlink, real);
          };
        }
        if (project.program && !project.symlinks.hasProcessedResolutions()) {
          project.symlinks.setSymlinksFromResolutions(
            // @ts-expect-error
            project.program.forEachResolvedModule,
            // @ts-expect-error
            project.program.forEachResolvedTypeReferenceDirective,
            // @ts-expect-error
            project.program.getAutomaticTypeDirectiveResolutions()
          );
        }
        return project.symlinks;
      };
      return project;
    }
    exports2.createProject = createProject;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_3/index.js
var require__5 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_3/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _5_0_1 = require__4();
    var project_1 = require_project2();
    function default_1(ts, sys, host, createLanguageService) {
      return (0, _5_0_1.default)(ts, sys, host, createLanguageService, project_1.createProject);
    }
    exports2.default = default_1;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_5/moduleSpecifierCache.js
var require_moduleSpecifierCache4 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_5/moduleSpecifierCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createModuleSpecifierCache = void 0;
    function createModuleSpecifierCache() {
      let containedNodeModulesWatchers;
      let cache;
      let currentKey;
      const result = {
        get(fromFileName, toFileName, preferences, options) {
          if (!cache || currentKey !== key(fromFileName, preferences, options))
            return void 0;
          return cache.get(toFileName);
        },
        set(fromFileName, toFileName, preferences, options, kind, modulePaths, moduleSpecifiers) {
          ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(
            kind,
            modulePaths,
            moduleSpecifiers,
            /*isBlockedByPackageJsonDependencies*/
            false
          ));
          if (moduleSpecifiers) {
            for (const p of modulePaths) {
              if (p.isInNodeModules) {
              }
            }
          }
        },
        setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
          const cache2 = ensureCache(fromFileName, preferences, options);
          const info = cache2.get(toFileName);
          if (info) {
            info.modulePaths = modulePaths;
          } else {
            cache2.set(toFileName, createInfo(
              /*kind*/
              void 0,
              modulePaths,
              /*moduleSpecifiers*/
              void 0,
              /*isBlockedByPackageJsonDependencies*/
              void 0
            ));
          }
        },
        setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, isBlockedByPackageJsonDependencies) {
          const cache2 = ensureCache(fromFileName, preferences, options);
          const info = cache2.get(toFileName);
          if (info) {
            info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
          } else {
            cache2.set(toFileName, createInfo(
              /*kind*/
              void 0,
              /*modulePaths*/
              void 0,
              /*moduleSpecifiers*/
              void 0,
              isBlockedByPackageJsonDependencies
            ));
          }
        },
        clear() {
          containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.forEach((watcher) => watcher.close());
          cache === null || cache === void 0 ? void 0 : cache.clear();
          containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.clear();
          currentKey = void 0;
        },
        count() {
          return cache ? cache.size : 0;
        }
      };
      return result;
      function ensureCache(fromFileName, preferences, options) {
        const newKey = key(fromFileName, preferences, options);
        if (cache && currentKey !== newKey) {
          result.clear();
        }
        currentKey = newKey;
        return cache || (cache = /* @__PURE__ */ new Map());
      }
      function key(fromFileName, preferences, options) {
        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
      }
      function createInfo(kind, modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies) {
        return { kind, modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies };
      }
    }
    exports2.createModuleSpecifierCache = createModuleSpecifierCache;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_5/project.js
var require_project3 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_5/project.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProject = void 0;
    var project_1 = require_project2();
    var moduleSpecifierCache_1 = require_moduleSpecifierCache4();
    function createProject(ts, host, createLanguageService, options) {
      options.createModuleSpecifierCache = moduleSpecifierCache_1.createModuleSpecifierCache;
      return (0, project_1.createProject)(ts, host, createLanguageService, options);
    }
    exports2.createProject = createProject;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_5/index.js
var require__6 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_5/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _5_0_1 = require__4();
    var project_1 = require_project3();
    function default_1(ts, sys, host, createLanguageService) {
      return (0, _5_0_1.default)(ts, sys, host, createLanguageService, project_1.createProject);
    }
    exports2.default = default_1;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_6/moduleSpecifierCache.js
var require_moduleSpecifierCache5 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_6/moduleSpecifierCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createModuleSpecifierCache = void 0;
    function createModuleSpecifierCache() {
      let containedNodeModulesWatchers;
      let cache;
      let currentKey;
      const result = {
        get(fromFileName, toFileName, preferences, options) {
          if (!cache || currentKey !== key(fromFileName, preferences, options))
            return void 0;
          return cache.get(toFileName);
        },
        set(fromFileName, toFileName, preferences, options, kind, modulePaths, moduleSpecifiers) {
          ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(
            kind,
            modulePaths,
            moduleSpecifiers,
            /*packageName */
            void 0,
            /*isBlockedByPackageJsonDependencies*/
            false
          ));
          if (moduleSpecifiers) {
            for (const p of modulePaths) {
              if (p.isInNodeModules) {
              }
            }
          }
        },
        setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
          const cache2 = ensureCache(fromFileName, preferences, options);
          const info = cache2.get(toFileName);
          if (info) {
            info.modulePaths = modulePaths;
          } else {
            cache2.set(toFileName, createInfo(
              /*kind*/
              void 0,
              modulePaths,
              /*moduleSpecifiers*/
              void 0,
              /*packageName */
              void 0,
              /*isBlockedByPackageJsonDependencies*/
              void 0
            ));
          }
        },
        setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, packageName, isBlockedByPackageJsonDependencies) {
          const cache2 = ensureCache(fromFileName, preferences, options);
          const info = cache2.get(toFileName);
          if (info) {
            info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
            info.packageName = packageName;
          } else {
            cache2.set(toFileName, createInfo(
              /*kind*/
              void 0,
              /*modulePaths*/
              void 0,
              /*moduleSpecifiers*/
              void 0,
              /*packageName */
              void 0,
              isBlockedByPackageJsonDependencies
            ));
          }
        },
        clear() {
          containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.forEach((watcher) => watcher.close());
          cache === null || cache === void 0 ? void 0 : cache.clear();
          containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.clear();
          currentKey = void 0;
        },
        count() {
          return cache ? cache.size : 0;
        }
      };
      return result;
      function ensureCache(fromFileName, preferences, options) {
        const newKey = key(fromFileName, preferences, options);
        if (cache && currentKey !== newKey) {
          result.clear();
        }
        currentKey = newKey;
        return cache || (cache = /* @__PURE__ */ new Map());
      }
      function key(fromFileName, preferences, options) {
        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
      }
      function createInfo(kind, modulePaths, moduleSpecifiers, packageName, isBlockedByPackageJsonDependencies) {
        return { kind, modulePaths, moduleSpecifiers, packageName, isBlockedByPackageJsonDependencies };
      }
    }
    exports2.createModuleSpecifierCache = createModuleSpecifierCache;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_6/project.js
var require_project4 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_6/project.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProject = void 0;
    var project_1 = require_project2();
    var moduleSpecifierCache_1 = require_moduleSpecifierCache5();
    function createProject(ts, host, createLanguageService, options) {
      options.createModuleSpecifierCache = moduleSpecifierCache_1.createModuleSpecifierCache;
      return (0, project_1.createProject)(ts, host, createLanguageService, options);
    }
    exports2.createProject = createProject;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_6/index.js
var require__7 = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/5_6/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _5_0_1 = require__4();
    var project_1 = require_project4();
    function default_1(ts, sys, host, createLanguageService) {
      return (0, _5_0_1.default)(ts, sys, host, createLanguageService, project_1.createProject);
    }
    exports2.default = default_1;
  }
});

// node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/index.js
var require_out = __commonJS({
  "node_modules/.pnpm/typescript-auto-import-cache@0.3.6/node_modules/typescript-auto-import-cache/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLanguageService = void 0;
    var semver = require_semver2();
    var _4_0_1 = require__();
    var _4_4_1 = require__2();
    var _4_7_1 = require__3();
    var _5_0_1 = require__4();
    var _5_3_1 = require__5();
    var _5_5_1 = require__6();
    var _5_6_1 = require__7();
    function createLanguageService(ts, sys, host, createLanguageService2) {
      if (semver.gte(ts.version, "5.6.1-rc")) {
        return (0, _5_6_1.default)(ts, sys, host, createLanguageService2);
      }
      if (semver.gte(ts.version, "5.5.1")) {
        return (0, _5_5_1.default)(ts, sys, host, createLanguageService2);
      } else if (semver.gte(ts.version, "5.3.0")) {
        return (0, _5_3_1.default)(ts, sys, host, createLanguageService2);
      } else if (semver.gte(ts.version, "5.0.0")) {
        return (0, _5_0_1.default)(ts, sys, host, createLanguageService2);
      } else if (semver.gte(ts.version, "4.7.0")) {
        const service = createLanguageService2(host);
        (0, _4_7_1.default)(ts, host, service);
        return { languageService: service };
      } else if (semver.gte(ts.version, "4.4.0")) {
        const service = createLanguageService2(host);
        (0, _4_4_1.default)(ts, host, service);
        return { languageService: service };
      } else if (semver.gte(ts.version, "4.0.0")) {
        const service = createLanguageService2(host);
        (0, _4_0_1.default)(ts, host, service);
        return { languageService: service };
      }
      return { languageService: createLanguageService2(host) };
    }
    exports2.createLanguageService = createLanguageService;
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/configs/getUserPreferences.js
var require_getUserPreferences = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/configs/getUserPreferences.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUserPreferences = getUserPreferences;
    var path3 = require_path_browserify();
    var vscode_uri_1 = require_umd();
    var shared_1 = require_shared();
    async function getUserPreferences(ctx, document) {
      let currentDirectory = "";
      if (ctx.project.typescript) {
        currentDirectory = ctx.project.typescript.languageServiceHost.getCurrentDirectory();
      }
      const uri = vscode_uri_1.URI.parse(document.uri);
      const documentUri = ctx.decodeEmbeddedDocumentUri(uri)?.[0] ?? uri;
      const config = await ctx.env.getConfiguration?.((0, shared_1.getConfigTitle)(document)) ?? {};
      const preferencesConfig = config?.preferences ?? {};
      const preferences = {
        ...config.unstable ?? {},
        quotePreference: getQuoteStylePreference(preferencesConfig),
        importModuleSpecifierPreference: getImportModuleSpecifierPreference(preferencesConfig),
        importModuleSpecifierEnding: getImportModuleSpecifierEndingPreference(preferencesConfig),
        jsxAttributeCompletionStyle: getJsxAttributeCompletionStyle(preferencesConfig),
        allowTextChangesInNewFiles: documentUri.scheme === "file",
        providePrefixAndSuffixTextForRename: (preferencesConfig.renameShorthandProperties ?? true) === false ? false : preferencesConfig.useAliasesForRenames ?? true,
        allowRenameOfImportPath: true,
        includeAutomaticOptionalChainCompletions: config.suggest?.includeAutomaticOptionalChainCompletions ?? true,
        provideRefactorNotApplicableReason: true,
        generateReturnInDocTemplate: config.suggest?.jsdoc?.generateReturns ?? true,
        includeCompletionsForImportStatements: config.suggest?.includeCompletionsForImportStatements ?? true,
        includeCompletionsWithSnippetText: config.suggest?.includeCompletionsWithSnippetText ?? true,
        includeCompletionsWithClassMemberSnippets: config.suggest?.classMemberSnippets?.enabled ?? true,
        includeCompletionsWithObjectLiteralMethodSnippets: config.suggest?.objectLiteralMethodSnippets?.enabled ?? true,
        autoImportFileExcludePatterns: getAutoImportFileExcludePatternsPreference(preferencesConfig, currentDirectory),
        autoImportSpecifierExcludeRegexes: preferencesConfig.autoImportSpecifierExcludeRegexes,
        useLabelDetailsInCompletionEntries: true,
        allowIncompleteCompletions: true,
        displayPartsForJSDoc: true,
        // inlay hints
        includeInlayParameterNameHints: getInlayParameterNameHintsPreference(config),
        includeInlayParameterNameHintsWhenArgumentMatchesName: !(config.inlayHints?.parameterNames?.suppressWhenArgumentMatchesName ?? true),
        includeInlayFunctionParameterTypeHints: config.inlayHints?.parameterTypes?.enabled ?? false,
        includeInlayVariableTypeHints: config.inlayHints?.variableTypes?.enabled ?? false,
        includeInlayVariableTypeHintsWhenTypeMatchesName: !(config.inlayHints?.variableTypes?.suppressWhenTypeMatchesName ?? true),
        includeInlayPropertyDeclarationTypeHints: config.inlayHints?.propertyDeclarationTypes?.enabled ?? false,
        includeInlayFunctionLikeReturnTypeHints: config.inlayHints?.functionLikeReturnTypes?.enabled ?? false,
        includeInlayEnumMemberValueHints: config.inlayHints?.enumMemberValues?.enabled ?? false,
        // https://github.com/microsoft/vscode/blob/main/extensions/typescript-language-features/src/languageFeatures/completions.ts#L728-L730
        includeCompletionsForModuleExports: config.suggest?.autoImports ?? true,
        includeCompletionsWithInsertText: true,
        includePackageJsonAutoImports: preferencesConfig.includePackageJsonAutoImports ?? "auto"
      };
      return preferences;
    }
    function getQuoteStylePreference(config) {
      switch (config.quoteStyle) {
        case "single":
          return "single";
        case "double":
          return "double";
        default:
          return "auto";
      }
    }
    function getAutoImportFileExcludePatternsPreference(config, workspacePath) {
      return workspacePath && config.autoImportFileExcludePatterns?.map((p) => {
        const slashNormalized = p.replace(/\\/g, "/");
        const isRelative = /^\.\.?($|\/)/.test(slashNormalized);
        return path3.isAbsolute(p) ? p : p.startsWith("*") ? "/" + slashNormalized : isRelative ? path3.join(workspacePath, p) : "/**/" + slashNormalized;
      });
    }
    function getImportModuleSpecifierPreference(config) {
      switch (config.importModuleSpecifier) {
        case "project-relative":
          return "project-relative";
        case "relative":
          return "relative";
        case "non-relative":
          return "non-relative";
        default:
          return void 0;
      }
    }
    function getImportModuleSpecifierEndingPreference(config) {
      switch (config.importModuleSpecifierEnding) {
        case "minimal":
          return "minimal";
        case "index":
          return "index";
        case "js":
          return "js";
        default:
          return "minimal";
      }
    }
    function getJsxAttributeCompletionStyle(config) {
      switch (config.jsxAttributeCompletionStyle) {
        case "braces":
          return "braces";
        case "none":
          return "none";
        default:
          return "auto";
      }
    }
    function getInlayParameterNameHintsPreference(config) {
      switch (config.inlayHints?.parameterNames?.enabled) {
        case "none":
          return "none";
        case "literals":
          return "literals";
        case "all":
          return "all";
        default:
          return void 0;
      }
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/fixNames.js
var require_fixNames = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/fixNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addMissingOverride = exports2.addMissingAwait = exports2.fixImport = exports2.spelling = exports2.forgottenThisPropertyAccess = exports2.unusedIdentifier = exports2.unreachableCode = exports2.classDoesntImplementInheritedAbstractMember = exports2.classIncorrectlyImplementsInterface = exports2.awaitInSyncFunction = exports2.extendsInterfaceBecomesImplements = exports2.constructorForDerivedNeedSuperCall = exports2.annotateWithTypeFromJSDoc = void 0;
    exports2.annotateWithTypeFromJSDoc = "annotateWithTypeFromJSDoc";
    exports2.constructorForDerivedNeedSuperCall = "constructorForDerivedNeedSuperCall";
    exports2.extendsInterfaceBecomesImplements = "extendsInterfaceBecomesImplements";
    exports2.awaitInSyncFunction = "fixAwaitInSyncFunction";
    exports2.classIncorrectlyImplementsInterface = "fixClassIncorrectlyImplementsInterface";
    exports2.classDoesntImplementInheritedAbstractMember = "fixClassDoesntImplementInheritedAbstractMember";
    exports2.unreachableCode = "fixUnreachableCode";
    exports2.unusedIdentifier = "unusedIdentifier";
    exports2.forgottenThisPropertyAccess = "forgottenThisPropertyAccess";
    exports2.spelling = "spelling";
    exports2.fixImport = "import";
    exports2.addMissingAwait = "addMissingAwait";
    exports2.addMissingOverride = "fixOverrideModifier";
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/semanticFeatures/codeActionResolve.js
var require_codeActionResolve = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/semanticFeatures/codeActionResolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    exports2.resolveFixAllCodeAction = resolveFixAllCodeAction;
    exports2.resolveRefactorCodeAction = resolveRefactorCodeAction;
    exports2.resolveOrganizeImportsCodeAction = resolveOrganizeImportsCodeAction;
    var vscode_uri_1 = require_umd();
    var getFormatCodeSettings_1 = require_getFormatCodeSettings();
    var getUserPreferences_1 = require_getUserPreferences();
    var shared_1 = require_shared();
    var lspConverters_1 = require_lspConverters();
    function register(ctx) {
      return async (codeAction, formattingOptions) => {
        const data = codeAction.data;
        const document = ctx.getTextDocument(vscode_uri_1.URI.parse(data.uri));
        const [formatOptions, preferences] = await Promise.all([
          (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document, formattingOptions),
          (0, getUserPreferences_1.getUserPreferences)(ctx, document)
        ]);
        if (data?.type === "fixAll") {
          resolveFixAllCodeAction(ctx, codeAction, data, formatOptions, preferences);
        } else if (data?.type === "refactor") {
          resolveRefactorCodeAction(ctx, codeAction, data, document, formatOptions, preferences);
        } else if (data?.type === "organizeImports") {
          resolveOrganizeImportsCodeAction(ctx, codeAction, data, formatOptions, preferences);
        }
        return codeAction;
      };
    }
    function resolveFixAllCodeAction(ctx, codeAction, data, formatOptions, preferences) {
      const fixes = data.fixIds.map((fixId) => (0, shared_1.safeCall)(() => ctx.languageService.getCombinedCodeFix({ type: "file", fileName: data.fileName }, fixId, formatOptions, preferences)));
      const changes = fixes.map((fix) => fix?.changes ?? []).flat();
      codeAction.edit = (0, lspConverters_1.convertFileTextChanges)(changes, ctx.fileNameToUri, ctx.getTextDocument);
    }
    function resolveRefactorCodeAction(ctx, codeAction, data, document, formatOptions, preferences) {
      const editInfo = (0, shared_1.safeCall)(() => ctx.languageService.getEditsForRefactor(data.fileName, formatOptions, data.range, data.refactorName, data.actionName, preferences));
      if (!editInfo) {
        return;
      }
      codeAction.edit = (0, lspConverters_1.convertFileTextChanges)(editInfo.edits, ctx.fileNameToUri, ctx.getTextDocument);
      if (editInfo.renameLocation !== void 0 && editInfo.renameFilename !== void 0) {
        codeAction.command = ctx.commands.rename.create(document.uri, document.positionAt(editInfo.renameLocation));
      }
    }
    function resolveOrganizeImportsCodeAction(ctx, codeAction, data, formatOptions, preferences) {
      const changes = (0, shared_1.safeCall)(() => ctx.languageService.organizeImports({ type: "file", fileName: data.fileName }, formatOptions, preferences));
      codeAction.edit = (0, lspConverters_1.convertFileTextChanges)(changes ?? [], ctx.fileNameToUri, ctx.getTextDocument);
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/semanticFeatures/codeAction.js
var require_codeAction = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/semanticFeatures/codeAction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    var getFormatCodeSettings_1 = require_getFormatCodeSettings();
    var getUserPreferences_1 = require_getUserPreferences();
    var shared_1 = require_shared();
    var fixNames = require_fixNames();
    var lspConverters_1 = require_lspConverters();
    var codeActionResolve_1 = require_codeActionResolve();
    var renameCommandRefactors = /* @__PURE__ */ new Set([
      "refactor.rewrite.property.generateAccessors",
      "refactor.extract.type",
      "refactor.extract.interface",
      "refactor.extract.typedef",
      "refactor.extract.constant",
      "refactor.extract.function"
    ]);
    function register(ctx) {
      let resolveCommandSupport = ctx.env.clientCapabilities?.textDocument?.codeAction?.resolveSupport?.properties?.includes("command");
      let resolveEditSupport = ctx.env.clientCapabilities?.textDocument?.codeAction?.resolveSupport?.properties?.includes("edit");
      let loged = false;
      const wranUnsupportResolve = () => {
        if (loged) {
          return;
        }
        loged = true;
        console.warn("[volar-service-typescript] The language client lacks support for the command/edit properties in the resolve code action. Therefore, the code action resolve is pre-calculated.");
      };
      if (!ctx.env.clientCapabilities) {
        resolveCommandSupport = true;
        resolveEditSupport = true;
      }
      return async (uri, document, range, context, formattingOptions) => {
        const [formatOptions, preferences] = await Promise.all([
          (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document, formattingOptions),
          (0, getUserPreferences_1.getUserPreferences)(ctx, document)
        ]);
        const fileName = ctx.uriToFileName(uri);
        const start = document.offsetAt(range.start);
        const end = document.offsetAt(range.end);
        let result = [];
        const onlyQuickFix = matchOnlyKind(`${"quickfix"}.ts`);
        if (!context.only || onlyQuickFix) {
          for (const error of context.diagnostics) {
            const codeFixes = (0, shared_1.safeCall)(() => ctx.languageService.getCodeFixesAtPosition(fileName, document.offsetAt(error.range.start), document.offsetAt(error.range.end), [Number(error.code)], formatOptions, preferences)) ?? [];
            for (const codeFix of codeFixes) {
              result = result.concat(convertCodeFixAction(codeFix, [error], onlyQuickFix ?? ""));
            }
          }
        }
        if (context.only) {
          for (const only of context.only) {
            if (only.split(".")[0] === "refactor") {
              const refactors = (0, shared_1.safeCall)(() => ctx.languageService.getApplicableRefactors(fileName, { pos: start, end }, preferences, void 0, only)) ?? [];
              for (const refactor of refactors) {
                result = result.concat(convertApplicableRefactorInfo(refactor));
              }
            }
          }
        } else {
          const refactors = (0, shared_1.safeCall)(() => ctx.languageService.getApplicableRefactors(fileName, { pos: start, end }, preferences, void 0, void 0)) ?? [];
          for (const refactor of refactors) {
            result = result.concat(convertApplicableRefactorInfo(refactor));
          }
        }
        const onlySourceOrganizeImports = matchOnlyKind(`${"source.organizeImports"}.ts`);
        if (onlySourceOrganizeImports) {
          const action = {
            title: "Organize Imports",
            kind: onlySourceOrganizeImports
          };
          const data = {
            type: "organizeImports",
            uri: document.uri,
            fileName
          };
          if (resolveEditSupport) {
            action.data = data;
          } else {
            wranUnsupportResolve();
            (0, codeActionResolve_1.resolveOrganizeImportsCodeAction)(ctx, action, data, formatOptions, preferences);
          }
          result.push(action);
        }
        const onlySourceFixAll = matchOnlyKind(`${"source.fixAll"}.ts`);
        if (onlySourceFixAll) {
          const action = {
            title: "Fix All",
            kind: onlySourceFixAll
          };
          const data = {
            uri: document.uri,
            type: "fixAll",
            fileName,
            fixIds: [
              fixNames.classIncorrectlyImplementsInterface,
              fixNames.awaitInSyncFunction,
              fixNames.unreachableCode
            ]
          };
          if (resolveEditSupport) {
            action.data = data;
          } else {
            wranUnsupportResolve();
            (0, codeActionResolve_1.resolveFixAllCodeAction)(ctx, action, data, formatOptions, preferences);
          }
          result.push(action);
        }
        const onlyRemoveUnused = matchOnlyKind(`${"source"}.removeUnused.ts`);
        if (onlyRemoveUnused) {
          const action = {
            title: "Remove all unused code",
            kind: onlyRemoveUnused
          };
          const data = {
            uri: document.uri,
            type: "fixAll",
            fileName,
            fixIds: [
              // not working and throw
              fixNames.unusedIdentifier,
              // TODO: remove patching
              "unusedIdentifier_prefix",
              "unusedIdentifier_deleteImports",
              "unusedIdentifier_delete",
              "unusedIdentifier_infer"
            ]
          };
          if (resolveEditSupport) {
            action.data = data;
          } else {
            wranUnsupportResolve();
            (0, codeActionResolve_1.resolveFixAllCodeAction)(ctx, action, data, formatOptions, preferences);
          }
          result.push(action);
        }
        const onlyAddMissingImports = matchOnlyKind(`${"source"}.addMissingImports.ts`);
        if (onlyAddMissingImports) {
          const action = {
            title: "Add all missing imports",
            kind: onlyAddMissingImports
          };
          const data = {
            uri: document.uri,
            type: "fixAll",
            fileName,
            fixIds: [
              // not working and throw
              fixNames.fixImport,
              // TODO: remove patching
              "fixMissingImport"
            ]
          };
          if (resolveEditSupport) {
            action.data = data;
          } else {
            wranUnsupportResolve();
            (0, codeActionResolve_1.resolveFixAllCodeAction)(ctx, action, data, formatOptions, preferences);
          }
          result.push(action);
        }
        for (const codeAction of result) {
          if (codeAction.diagnostics === void 0) {
            codeAction.diagnostics = context.diagnostics;
          }
        }
        return result;
        function matchOnlyKind(kind) {
          if (context.only) {
            for (const only of context.only) {
              const a = only.split(".");
              const b = kind.split(".");
              if (a.length <= b.length) {
                let matchNums = 0;
                for (let i = 0; i < a.length; i++) {
                  if (a[i] === b[i]) {
                    matchNums++;
                  }
                }
                if (matchNums === a.length) {
                  return only;
                }
              }
            }
          }
        }
        function convertCodeFixAction(codeFix, diagnostics, kind) {
          const edit = (0, lspConverters_1.convertFileTextChanges)(codeFix.changes, ctx.fileNameToUri, ctx.getTextDocument);
          const codeActions = [];
          const fix = {
            title: codeFix.description,
            kind,
            edit
          };
          fix.diagnostics = diagnostics;
          codeActions.push(fix);
          if (codeFix.fixAllDescription && codeFix.fixId) {
            const fixAll = {
              title: codeFix.fixAllDescription,
              kind
            };
            const data = {
              uri: document.uri,
              type: "fixAll",
              fileName,
              fixIds: [codeFix.fixId]
            };
            if (resolveEditSupport) {
              fixAll.data = data;
            } else {
              wranUnsupportResolve();
              (0, codeActionResolve_1.resolveFixAllCodeAction)(ctx, fixAll, data, formatOptions, preferences);
            }
            fixAll.diagnostics = diagnostics;
            codeActions.push(fixAll);
          }
          return codeActions;
        }
        function convertApplicableRefactorInfo(refactor) {
          const codeActions = [];
          for (const action of refactor.actions) {
            const codeAction = {
              title: action.description,
              kind: action.kind
            };
            if (action.notApplicableReason) {
              codeAction.disabled = { reason: action.notApplicableReason };
            }
            if (refactor.inlineable) {
              codeAction.isPreferred = true;
            }
            const data = {
              uri: document.uri,
              type: "refactor",
              fileName,
              range: { pos: start, end },
              refactorName: refactor.name,
              actionName: action.name
            };
            const hasCommand = renameCommandRefactors.has(action.kind);
            if (hasCommand && resolveCommandSupport && resolveEditSupport) {
              codeAction.data = data;
            } else if (!hasCommand && resolveEditSupport) {
              codeAction.data = data;
            } else if (!codeAction.disabled) {
              wranUnsupportResolve();
              (0, codeActionResolve_1.resolveRefactorCodeAction)(ctx, codeAction, data, document, formatOptions, preferences);
            }
            codeActions.push(codeAction);
          }
          return codeActions;
        }
      };
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/semanticFeatures/semanticTokens.js
var require_semanticTokens2 = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/semanticFeatures/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.register = register;
    exports2.convertClassificationsToSemanticTokens = convertClassificationsToSemanticTokens;
    var shared_1 = require_shared();
    function register(ts, ctx) {
      return (uri, document, range, legend) => {
        const fileName = ctx.uriToFileName(uri);
        const start = range ? document.offsetAt(range.start) : 0;
        const length = range ? document.offsetAt(range.end) - start : document.getText().length;
        if (ctx.project.typescript?.languageServiceHost.getCancellationToken?.().isCancellationRequested()) {
          return;
        }
        const response = (0, shared_1.safeCall)(() => ctx.languageService.getEncodedSemanticClassifications(fileName, { start, length }, ts.SemanticClassificationFormat.TwentyTwenty));
        if (!response) {
          return;
        }
        return convertClassificationsToSemanticTokens(document, { start, length }, legend, response);
      };
    }
    function convertClassificationsToSemanticTokens(document, { start, length }, legend, response) {
      let tokenModifiersTable = [];
      tokenModifiersTable[
        2
        /* TokenModifier.async */
      ] = 1 << legend.tokenModifiers.indexOf("async");
      tokenModifiersTable[
        0
        /* TokenModifier.declaration */
      ] = 1 << legend.tokenModifiers.indexOf("declaration");
      tokenModifiersTable[
        3
        /* TokenModifier.readonly */
      ] = 1 << legend.tokenModifiers.indexOf("readonly");
      tokenModifiersTable[
        1
        /* TokenModifier.static */
      ] = 1 << legend.tokenModifiers.indexOf("static");
      tokenModifiersTable[
        5
        /* TokenModifier.local */
      ] = 1 << legend.tokenModifiers.indexOf("local");
      tokenModifiersTable[
        4
        /* TokenModifier.defaultLibrary */
      ] = 1 << legend.tokenModifiers.indexOf("defaultLibrary");
      tokenModifiersTable = tokenModifiersTable.map((mod) => Math.max(mod, 0));
      const end = start + length;
      const tokenSpan = response.spans;
      const tokens = [];
      let i = 0;
      while (i < tokenSpan.length) {
        const offset = tokenSpan[i++];
        if (offset >= end) {
          break;
        }
        const length2 = tokenSpan[i++];
        const tsClassification = tokenSpan[i++];
        const tokenType = getTokenTypeFromClassification(tsClassification);
        if (tokenType === void 0) {
          continue;
        }
        const tokenModifiers2 = getTokenModifierFromClassification(tsClassification);
        const startPos = document.positionAt(offset);
        const endPos = document.positionAt(offset + length2);
        const serverToken = tsTokenTypeToServerTokenType(tokenType);
        if (serverToken === void 0) {
          continue;
        }
        const serverTokenModifiers = tsTokenModifierToServerTokenModifier(tokenModifiers2);
        for (let line = startPos.line; line <= endPos.line; line++) {
          const startCharacter = line === startPos.line ? startPos.character : 0;
          const endCharacter = line === endPos.line ? endPos.character : docLineLength(document, line);
          tokens.push([line, startCharacter, endCharacter - startCharacter, serverToken, serverTokenModifiers]);
        }
      }
      return tokens;
      function tsTokenTypeToServerTokenType(tokenType) {
        return legend.tokenTypes.indexOf(tokenTypes[tokenType]);
      }
      function tsTokenModifierToServerTokenModifier(input) {
        let m = 0;
        let i2 = 0;
        while (input) {
          if (input & 1) {
            m |= tokenModifiersTable[i2];
          }
          input = input >> 1;
          i2++;
        }
        return m;
      }
    }
    function docLineLength(document, line) {
      const currentLineOffset = document.offsetAt({ line, character: 0 });
      const nextLineOffset = document.offsetAt({ line: line + 1, character: 0 });
      return nextLineOffset - currentLineOffset;
    }
    function getTokenTypeFromClassification(tsClassification) {
      if (tsClassification > 255) {
        return (tsClassification >> 8) - 1;
      }
      return void 0;
    }
    function getTokenModifierFromClassification(tsClassification) {
      return tsClassification & 255;
    }
    var tokenTypes = [];
    tokenTypes[
      0
      /* TokenType.class */
    ] = "class";
    tokenTypes[
      1
      /* TokenType.enum */
    ] = "enum";
    tokenTypes[
      2
      /* TokenType.interface */
    ] = "interface";
    tokenTypes[
      3
      /* TokenType.namespace */
    ] = "namespace";
    tokenTypes[
      4
      /* TokenType.typeParameter */
    ] = "typeParameter";
    tokenTypes[
      5
      /* TokenType.type */
    ] = "type";
    tokenTypes[
      6
      /* TokenType.parameter */
    ] = "parameter";
    tokenTypes[
      7
      /* TokenType.variable */
    ] = "variable";
    tokenTypes[
      8
      /* TokenType.enumMember */
    ] = "enumMember";
    tokenTypes[
      9
      /* TokenType.property */
    ] = "property";
    tokenTypes[
      10
      /* TokenType.function */
    ] = "function";
    tokenTypes[
      11
      /* TokenType.method */
    ] = "method";
    var tokenModifiers = [];
    tokenModifiers[
      2
      /* TokenModifier.async */
    ] = "async";
    tokenModifiers[
      0
      /* TokenModifier.declaration */
    ] = "declaration";
    tokenModifiers[
      3
      /* TokenModifier.readonly */
    ] = "readonly";
    tokenModifiers[
      1
      /* TokenModifier.static */
    ] = "static";
    tokenModifiers[
      5
      /* TokenModifier.local */
    ] = "local";
    tokenModifiers[
      4
      /* TokenModifier.defaultLibrary */
    ] = "defaultLibrary";
    var tokenTypeMap = [];
    tokenTypeMap[
      11
      /* ExperimentalProtocol.ClassificationType.className */
    ] = 0;
    tokenTypeMap[
      12
      /* ExperimentalProtocol.ClassificationType.enumName */
    ] = 1;
    tokenTypeMap[
      13
      /* ExperimentalProtocol.ClassificationType.interfaceName */
    ] = 2;
    tokenTypeMap[
      14
      /* ExperimentalProtocol.ClassificationType.moduleName */
    ] = 3;
    tokenTypeMap[
      15
      /* ExperimentalProtocol.ClassificationType.typeParameterName */
    ] = 4;
    tokenTypeMap[
      16
      /* ExperimentalProtocol.ClassificationType.typeAliasName */
    ] = 5;
    tokenTypeMap[
      17
      /* ExperimentalProtocol.ClassificationType.parameterName */
    ] = 6;
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/snippetForFunctionCall.js
var require_snippetForFunctionCall = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/utils/snippetForFunctionCall.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.snippetForFunctionCall = snippetForFunctionCall;
    var PConst = require_protocol_const();
    function snippetForFunctionCall(item, displayParts) {
      if (item.insertText && typeof item.insertText !== "string") {
        return { snippet: item.insertText, parameterCount: 0 };
      }
      let _tabstop = 1;
      const parameterListParts = getParameterListParts(displayParts);
      let snippet = "";
      snippet += `${item.insertText || item.label}(`;
      snippet = appendJoinedPlaceholders(snippet, parameterListParts.parts, ", ");
      if (parameterListParts.hasOptionalParameters) {
        snippet += "$" + _tabstop++;
      }
      snippet += ")";
      snippet += "$" + _tabstop++;
      return {
        snippet,
        parameterCount: parameterListParts.parts.length + (parameterListParts.hasOptionalParameters ? 1 : 0)
      };
      function appendJoinedPlaceholders(snippet2, parts, joiner) {
        for (let i = 0; i < parts.length; ++i) {
          const paramterPart = parts[i];
          snippet2 += "${" + _tabstop++ + ":" + paramterPart.text + "}";
          if (i !== parts.length - 1) {
            snippet2 += joiner;
          }
        }
        return snippet2;
      }
    }
    function getParameterListParts(displayParts) {
      const parts = [];
      let isInMethod = false;
      let hasOptionalParameters = false;
      let parenCount = 0;
      let braceCount = 0;
      outer: {
        for (let i = 0; i < displayParts.length; ++i) {
          const part = displayParts[i];
          switch (part.kind) {
            case PConst.DisplayPartKind.methodName:
            case PConst.DisplayPartKind.functionName:
            case PConst.DisplayPartKind.text:
            case PConst.DisplayPartKind.propertyName:
              if (parenCount === 0 && braceCount === 0) {
                isInMethod = true;
              }
              break;
            case PConst.DisplayPartKind.parameterName:
              if (parenCount === 1 && braceCount === 0 && isInMethod) {
                const next = displayParts[i + 1];
                const nameIsFollowedByOptionalIndicator = next && next.text === "?";
                const nameIsThis = part.text === "this";
                if (!nameIsFollowedByOptionalIndicator && !nameIsThis) {
                  parts.push(part);
                }
                hasOptionalParameters = hasOptionalParameters || nameIsFollowedByOptionalIndicator;
              }
              break;
            case PConst.DisplayPartKind.punctuation:
              if (part.text === "(") {
                ++parenCount;
              } else if (part.text === ")") {
                --parenCount;
                if (parenCount <= 0 && isInMethod) {
                  break outer;
                }
              } else if (part.text === "..." && parenCount === 1) {
                hasOptionalParameters = true;
                break outer;
              } else if (part.text === "{") {
                ++braceCount;
              } else if (part.text === "}") {
                --braceCount;
              }
              break;
          }
        }
      }
      return { hasOptionalParameters, parts };
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/plugins/semantic.js
var require_semantic = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/lib/plugins/semantic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.create = create;
    var path3 = require_path_browserify();
    var semver = require_semver2();
    var tsWithImportCache = require_out();
    var vscode_uri_1 = require_umd();
    var getFormatCodeSettings_1 = require_getFormatCodeSettings();
    var getUserPreferences_1 = require_getUserPreferences();
    var codeActions = require_codeAction();
    var codeActionResolve = require_codeActionResolve();
    var semanticTokens = require_semanticTokens2();
    var shared_1 = require_shared();
    var lspConverters_1 = require_lspConverters();
    var snippetForFunctionCall_1 = require_snippetForFunctionCall();
    var documentRegistries = [];
    function getDocumentRegistry(ts, useCaseSensitiveFileNames, currentDirectory) {
      let documentRegistry = documentRegistries.find((item) => item[0] === useCaseSensitiveFileNames && item[1] === currentDirectory)?.[2];
      if (!documentRegistry) {
        documentRegistry = ts.createDocumentRegistry(useCaseSensitiveFileNames, currentDirectory);
        documentRegistries.push([useCaseSensitiveFileNames, currentDirectory, documentRegistry]);
      }
      return documentRegistry;
    }
    function create(ts, { disableAutoImportCache = false, isValidationEnabled = async (document, context) => {
      return await context.env.getConfiguration?.((0, shared_1.getConfigTitle)(document) + ".validate.enable") ?? true;
    }, isSuggestionsEnabled = async (document, context) => {
      return await context.env.getConfiguration?.((0, shared_1.getConfigTitle)(document) + ".suggest.enabled") ?? true;
    } } = {}) {
      return {
        name: "typescript-semantic",
        capabilities: {
          completionProvider: {
            triggerCharacters: getBasicTriggerCharacters(ts.version),
            resolveProvider: true
          },
          renameProvider: {
            prepareProvider: true
          },
          fileRenameEditsProvider: true,
          codeActionProvider: {
            codeActionKinds: [
              "",
              "quickfix",
              "refactor",
              "refactor.extract",
              "refactor.inline",
              "refactor.rewrite",
              "source",
              "source.fixAll",
              "source.organizeImports"
            ],
            resolveProvider: true
          },
          inlayHintProvider: {},
          callHierarchyProvider: true,
          definitionProvider: true,
          typeDefinitionProvider: true,
          diagnosticProvider: {
            interFileDependencies: true,
            workspaceDiagnostics: false
          },
          hoverProvider: true,
          implementationProvider: true,
          referencesProvider: true,
          fileReferencesProvider: true,
          documentHighlightProvider: true,
          semanticTokensProvider: {
            // https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#standard-token-types-and-modifiers
            legend: {
              tokenTypes: [
                "namespace",
                "class",
                "enum",
                "interface",
                "typeParameter",
                "type",
                "parameter",
                "variable",
                "property",
                "enumMember",
                "function",
                "method"
              ],
              tokenModifiers: [
                "declaration",
                "readonly",
                "static",
                "async",
                "defaultLibrary",
                "local"
                // additional
              ]
            }
          },
          workspaceSymbolProvider: {},
          signatureHelpProvider: {
            triggerCharacters: ["(", ",", "<"],
            retriggerCharacters: [")"]
          }
        },
        create(context) {
          if (!context.project.typescript) {
            console.warn(`[volar] typescript-semantic requires typescript project.`);
            return {};
          }
          const { sys, languageServiceHost, uriConverter, getExtraServiceScript } = context.project.typescript;
          let languageService;
          let created;
          if (disableAutoImportCache) {
            languageService = ts.createLanguageService(languageServiceHost, getDocumentRegistry(ts, sys.useCaseSensitiveFileNames, languageServiceHost.getCurrentDirectory()));
          } else {
            created = tsWithImportCache.createLanguageService(ts, sys, languageServiceHost, (proxiedHost) => ts.createLanguageService(proxiedHost, getDocumentRegistry(ts, sys.useCaseSensitiveFileNames, languageServiceHost.getCurrentDirectory())));
            languageService = created.languageService;
          }
          const ctx = {
            ...context,
            languageServiceHost,
            languageService,
            uriToFileName(uri) {
              const virtualScript = getVirtualScriptByUri(uri);
              if (virtualScript) {
                return virtualScript.fileName;
              }
              return uriConverter.asFileName(uri);
            },
            fileNameToUri(fileName) {
              const extraServiceScript = getExtraServiceScript(fileName);
              if (extraServiceScript) {
                const sourceScript2 = context.language.scripts.fromVirtualCode(extraServiceScript.code);
                return context.encodeEmbeddedDocumentUri(sourceScript2.id, extraServiceScript.code.id);
              }
              const uri = uriConverter.asUri(fileName);
              const sourceScript = context.language.scripts.get(uri);
              const serviceScript = sourceScript?.generated?.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
              if (sourceScript && serviceScript) {
                return context.encodeEmbeddedDocumentUri(sourceScript.id, serviceScript.code.id);
              }
              return uri;
            },
            getTextDocument(uri) {
              const decoded = context.decodeEmbeddedDocumentUri(uri);
              if (decoded) {
                const sourceScript = context.language.scripts.get(decoded[0]);
                const virtualCode = sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                if (virtualCode) {
                  return context.documents.get(uri, virtualCode.languageId, virtualCode.snapshot);
                }
              } else {
                const sourceFile = context.language.scripts.get(uri);
                if (sourceFile) {
                  return context.documents.get(uri, sourceFile.languageId, sourceFile.snapshot);
                }
              }
            }
          };
          const getCodeActions = codeActions.register(ctx);
          const doCodeActionResolve = codeActionResolve.register(ctx);
          const getDocumentSemanticTokens = semanticTokens.register(ts, ctx);
          const renameInfoOptions = { allowRenameOfImportPath: true };
          let formattingOptions;
          if (created?.setPreferences && context.env.getConfiguration) {
            updatePreferences();
            context.env.onDidChangeConfiguration?.(updatePreferences);
            async function updatePreferences() {
              const preferences = await context.env.getConfiguration?.("typescript.preferences");
              if (preferences) {
                created.setPreferences?.(preferences);
              }
            }
          }
          if (created?.projectUpdated) {
            let updateSourceScriptFileNames = function() {
              sourceScriptNames.clear();
              for (const fileName of languageServiceHost.getScriptFileNames()) {
                const maybeEmbeddedUri = ctx.fileNameToUri(fileName);
                const decoded = context.decodeEmbeddedDocumentUri(maybeEmbeddedUri);
                const uri = decoded ? decoded[0] : maybeEmbeddedUri;
                const sourceScript = context.language.scripts.get(uri);
                if (sourceScript?.generated) {
                  const tsCode = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
                  if (tsCode) {
                    sourceScriptNames.add(normalizeFileName(fileName));
                  }
                } else if (sourceScript) {
                  sourceScriptNames.add(normalizeFileName(fileName));
                }
              }
            };
            const sourceScriptNames = /* @__PURE__ */ new Set();
            const normalizeFileName = sys.useCaseSensitiveFileNames ? (id) => id : (id) => id.toLowerCase();
            updateSourceScriptFileNames();
            context.env.onDidChangeWatchedFiles?.((params) => {
              const someFileCreateOrDeiete = params.changes.some((change) => change.type !== 2);
              if (someFileCreateOrDeiete) {
                updateSourceScriptFileNames();
              }
              for (const change of params.changes) {
                const fileName = uriConverter.asFileName(vscode_uri_1.URI.parse(change.uri));
                if (sourceScriptNames.has(normalizeFileName(fileName))) {
                  created.projectUpdated?.(languageServiceHost.getCurrentDirectory());
                }
              }
            });
          }
          return {
            provide: {
              "typescript/languageService": () => languageService,
              "typescript/languageServiceHost": () => languageServiceHost,
              "typescript/documentFileName": (uri) => ctx.uriToFileName(uri),
              "typescript/documentUri": (fileName) => ctx.fileNameToUri(fileName)
            },
            dispose() {
              languageService.dispose();
            },
            provideDocumentFormattingEdits(_document, _range, options) {
              formattingOptions = options;
              return void 0;
            },
            provideOnTypeFormattingEdits(_document, _position, _key, options) {
              formattingOptions = options;
              return void 0;
            },
            async provideCompletionItems(document, position, completeContext, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (!await isSuggestionsEnabled(document, context)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const preferences = await (0, getUserPreferences_1.getUserPreferences)(ctx, document);
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const info = (0, shared_1.safeCall)(() => ctx.languageService.getCompletionsAtPosition(fileName, offset, {
                ...preferences,
                triggerCharacter: completeContext.triggerCharacter,
                triggerKind: completeContext.triggerKind
              }));
              if (info) {
                return (0, lspConverters_1.convertCompletionInfo)(ts, info, document, position, (tsEntry) => ({
                  uri: document.uri,
                  fileName,
                  offset,
                  originalItem: {
                    name: tsEntry.name,
                    source: tsEntry.source,
                    data: tsEntry.data,
                    labelDetails: tsEntry.labelDetails
                  }
                }));
              }
            },
            async resolveCompletionItem(item, token) {
              if (await isCancellationRequestedWhileSync(token)) {
                return item;
              }
              const data = item.data;
              if (!data) {
                return item;
              }
              const { fileName, offset } = data;
              const uri = vscode_uri_1.URI.parse(data.uri);
              const document = ctx.getTextDocument(uri);
              const [formatOptions, preferences] = await Promise.all([
                (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document, formattingOptions),
                (0, getUserPreferences_1.getUserPreferences)(ctx, document)
              ]);
              const details = (0, shared_1.safeCall)(() => ctx.languageService.getCompletionEntryDetails(fileName, offset, data.originalItem.name, formatOptions, data.originalItem.source, preferences, data.originalItem.data));
              if (!details) {
                return item;
              }
              if (data.originalItem.labelDetails) {
                item.labelDetails ??= {};
                Object.assign(item.labelDetails, data.originalItem.labelDetails);
              }
              (0, lspConverters_1.applyCompletionEntryDetails)(ts, item, details, document, ctx.fileNameToUri, ctx.getTextDocument);
              const useCodeSnippetsOnMethodSuggest = await ctx.env.getConfiguration?.((0, shared_1.getConfigTitle)(document) + ".suggest.completeFunctionCalls") ?? false;
              const useCodeSnippet = useCodeSnippetsOnMethodSuggest && (item.kind === 3 || item.kind === 2);
              if (useCodeSnippet) {
                const shouldCompleteFunction = isValidFunctionCompletionContext(ctx.languageService, fileName, offset, document);
                if (shouldCompleteFunction) {
                  const { snippet, parameterCount } = (0, snippetForFunctionCall_1.snippetForFunctionCall)({
                    insertText: item.insertText ?? item.textEdit?.newText,
                    // insertText is dropped by LSP in some case: https://github.com/microsoft/vscode-languageserver-node/blob/9b742021fb04ad081aa3676a9eecf4fa612084b4/client/src/common/codeConverter.ts#L659-L664
                    label: item.label
                  }, details.displayParts);
                  if (item.textEdit) {
                    item.textEdit.newText = snippet;
                  }
                  if (item.insertText) {
                    item.insertText = snippet;
                  }
                  item.insertTextFormat = 2;
                  if (parameterCount > 0) {
                  }
                }
              }
              return item;
              function isValidFunctionCompletionContext(client, filepath, offset2, document2) {
                try {
                  const response = client.getQuickInfoAtPosition(filepath, offset2);
                  if (response) {
                    switch (response.kind) {
                      case "var":
                      case "let":
                      case "const":
                      case "alias":
                        return false;
                    }
                  }
                } catch {
                }
                const position = document2.positionAt(offset2);
                const after = (0, lspConverters_1.getLineText)(document2, position.line).slice(position.character);
                return after.match(/^[a-z_$0-9]*\s*\(/gi) === null;
              }
            },
            async provideRenameRange(document, position, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const renameInfo = (0, shared_1.safeCall)(() => ctx.languageService.getRenameInfo(fileName, offset, renameInfoOptions));
              if (!renameInfo) {
                return;
              }
              if (!renameInfo.canRename) {
                return { message: renameInfo.localizedErrorMessage };
              }
              return (0, lspConverters_1.convertTextSpan)(renameInfo.triggerSpan, document);
            },
            async provideRenameEdits(document, position, newName, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document, true)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const renameInfo = (0, shared_1.safeCall)(() => ctx.languageService.getRenameInfo(fileName, offset, renameInfoOptions));
              if (!renameInfo?.canRename) {
                return;
              }
              if (renameInfo.fileToRename) {
                const [formatOptions, preferences] = await Promise.all([
                  (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document, formattingOptions),
                  (0, getUserPreferences_1.getUserPreferences)(ctx, document)
                ]);
                return renameFile(renameInfo.fileToRename, newName, formatOptions, preferences);
              }
              const { providePrefixAndSuffixTextForRename } = await (0, getUserPreferences_1.getUserPreferences)(ctx, document);
              const entries = ctx.languageService.findRenameLocations(fileName, offset, false, false, providePrefixAndSuffixTextForRename);
              if (!entries) {
                return;
              }
              return (0, lspConverters_1.convertRenameLocations)(newName, entries, ctx.fileNameToUri, ctx.getTextDocument);
              function renameFile(fileToRename, newName2, formatOptions, preferences) {
                if (!path3.extname(newName2)) {
                  newName2 += path3.extname(fileToRename);
                }
                const dirname2 = path3.dirname(fileToRename);
                const newFilePath = path3.join(dirname2, newName2);
                const response = (0, shared_1.safeCall)(() => ctx.languageService.getEditsForFileRename(fileToRename, newFilePath, formatOptions, preferences));
                if (!response) {
                  return;
                }
                const edits = (0, lspConverters_1.convertFileTextChanges)(response, ctx.fileNameToUri, ctx.getTextDocument);
                if (!edits.documentChanges) {
                  edits.documentChanges = [];
                }
                edits.documentChanges.push({
                  kind: "rename",
                  oldUri: ctx.fileNameToUri(fileToRename).toString(),
                  newUri: ctx.fileNameToUri(newFilePath).toString()
                });
                return edits;
              }
            },
            async provideCodeActions(document, range, context2, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              return getCodeActions(uri, document, range, context2, formattingOptions);
            },
            async resolveCodeAction(codeAction, token) {
              if (await isCancellationRequestedWhileSync(token)) {
                return codeAction;
              }
              return doCodeActionResolve(codeAction, formattingOptions);
            },
            async provideInlayHints(document, range, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const preferences = await (0, getUserPreferences_1.getUserPreferences)(ctx, document);
              const fileName = ctx.uriToFileName(uri);
              const start = document.offsetAt(range.start);
              const end = document.offsetAt(range.end);
              const inlayHints = (0, shared_1.safeCall)(() => "provideInlayHints" in ctx.languageService ? ctx.languageService.provideInlayHints(fileName, { start, length: end - start }, preferences) : []);
              if (!inlayHints) {
                return [];
              }
              return inlayHints.map((hint) => (0, lspConverters_1.convertInlayHint)(hint, document));
            },
            async provideCallHierarchyItems(document, position, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const calls = (0, shared_1.safeCall)(() => ctx.languageService.prepareCallHierarchy(fileName, offset));
              if (!calls) {
                return [];
              }
              const items = Array.isArray(calls) ? calls : [calls];
              return items.map((item) => (0, lspConverters_1.convertCallHierarchyItem)(item, ctx));
            },
            async provideCallHierarchyIncomingCalls(item, token) {
              if (await isCancellationRequestedWhileSync(token)) {
                return [];
              }
              const uri = vscode_uri_1.URI.parse(item.uri);
              const document = ctx.getTextDocument(uri);
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(item.selectionRange.start);
              const calls = (0, shared_1.safeCall)(() => ctx.languageService.provideCallHierarchyIncomingCalls(fileName, offset));
              if (!calls) {
                return [];
              }
              const items = Array.isArray(calls) ? calls : [calls];
              return items.map((item2) => (0, lspConverters_1.convertCallHierarchyIncomingCall)(item2, ctx));
            },
            async provideCallHierarchyOutgoingCalls(item, token) {
              if (await isCancellationRequestedWhileSync(token)) {
                return [];
              }
              const uri = vscode_uri_1.URI.parse(item.uri);
              const document = ctx.getTextDocument(uri);
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(item.selectionRange.start);
              const calls = (0, shared_1.safeCall)(() => ctx.languageService.provideCallHierarchyOutgoingCalls(fileName, offset));
              if (!calls) {
                return [];
              }
              const items = Array.isArray(calls) ? calls : [calls];
              return items.map((item2) => (0, lspConverters_1.convertCallHierarchyOutgoingCall)(item2, document, ctx));
            },
            async provideDefinition(document, position, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const info = (0, shared_1.safeCall)(() => ctx.languageService.getDefinitionAndBoundSpan(fileName, offset));
              if (!info) {
                return [];
              }
              return (0, lspConverters_1.convertDefinitionInfoAndBoundSpan)(info, document, ctx);
            },
            async provideTypeDefinition(document, position, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const entries = (0, shared_1.safeCall)(() => ctx.languageService.getTypeDefinitionAtPosition(fileName, offset));
              if (!entries) {
                return [];
              }
              return entries.map((entry) => (0, lspConverters_1.convertDocumentSpantoLocationLink)(entry, ctx));
            },
            async provideDiagnostics(document, token) {
              return [
                ...await provideDiagnosticsWorker(document, token, "syntactic") ?? [],
                ...await provideDiagnosticsWorker(document, token, "semantic") ?? []
              ];
            },
            async provideHover(document, position, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const info = (0, shared_1.safeCall)(() => ctx.languageService.getQuickInfoAtPosition(fileName, offset));
              if (!info) {
                return;
              }
              return (0, lspConverters_1.convertQuickInfo)(ts, info, document, ctx.fileNameToUri, ctx.getTextDocument);
            },
            async provideImplementation(document, position, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const entries = (0, shared_1.safeCall)(() => ctx.languageService.getImplementationAtPosition(fileName, offset));
              if (!entries) {
                return [];
              }
              return entries.map((entry) => (0, lspConverters_1.convertDocumentSpantoLocationLink)(entry, ctx));
            },
            async provideReferences(document, position, referenceContext, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document, true)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const references = (0, shared_1.safeCall)(() => ctx.languageService.findReferences(fileName, offset));
              if (!references) {
                return [];
              }
              const result = [];
              for (const reference of references) {
                if (referenceContext.includeDeclaration) {
                  const definition = (0, lspConverters_1.convertDocumentSpanToLocation)(reference.definition, ctx);
                  if (definition) {
                    result.push(definition);
                  }
                }
                for (const referenceEntry of reference.references) {
                  const reference2 = (0, lspConverters_1.convertDocumentSpanToLocation)(referenceEntry, ctx);
                  if (reference2) {
                    result.push(reference2);
                  }
                }
              }
              return result;
            },
            async provideFileReferences(document, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document, true)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const entries = (0, shared_1.safeCall)(() => ctx.languageService.getFileReferences(fileName));
              if (!entries) {
                return [];
              }
              return entries.map((entry) => (0, lspConverters_1.convertDocumentSpanToLocation)(entry, ctx));
            },
            async provideDocumentHighlights(document, position, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const highlights = (0, shared_1.safeCall)(() => ctx.languageService.getDocumentHighlights(fileName, offset, [fileName]));
              if (!highlights) {
                return [];
              }
              const results = [];
              for (const highlight of highlights) {
                for (const span of highlight.highlightSpans) {
                  results.push((0, lspConverters_1.convertHighlightSpan)(span, document));
                }
              }
              return results;
            },
            async provideDocumentSemanticTokens(document, range, legend, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              return getDocumentSemanticTokens(uri, document, range, legend);
            },
            async provideWorkspaceSymbols(query, token) {
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const items = (0, shared_1.safeCall)(() => ctx.languageService.getNavigateToItems(query));
              if (!items) {
                return [];
              }
              return items.filter((item) => item.containerName || item.kind !== "alias").map((item) => (0, lspConverters_1.convertNavigateToItem)(item, ctx.getTextDocument(ctx.fileNameToUri(item.fileName)))).filter((item) => !!item);
            },
            async provideFileRenameEdits(oldUri, newUri, token) {
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const document = ctx.getTextDocument(oldUri);
              const [formatOptions, preferences] = await Promise.all([
                (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document, formattingOptions),
                (0, getUserPreferences_1.getUserPreferences)(ctx, document)
              ]);
              const fileToRename = ctx.uriToFileName(oldUri);
              const newFilePath = ctx.uriToFileName(newUri);
              const response = (0, shared_1.safeCall)(() => ctx.languageService.getEditsForFileRename(fileToRename, newFilePath, formatOptions, preferences));
              if (!response?.length) {
                return;
              }
              return (0, lspConverters_1.convertFileTextChanges)(response, ctx.fileNameToUri, ctx.getTextDocument);
            },
            async provideSignatureHelp(document, position, context2, token) {
              const uri = vscode_uri_1.URI.parse(document.uri);
              if (!isSemanticDocument(uri, document)) {
                return;
              }
              if (await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const options = {};
              if (context2?.triggerKind === 1) {
                options.triggerReason = {
                  kind: "invoked"
                };
              } else if (context2?.triggerKind === 2) {
                options.triggerReason = {
                  kind: "characterTyped",
                  triggerCharacter: context2.triggerCharacter
                };
              } else if (context2?.triggerKind === 3) {
                options.triggerReason = {
                  kind: "retrigger",
                  triggerCharacter: context2.triggerCharacter
                };
              }
              const fileName = ctx.uriToFileName(uri);
              const offset = document.offsetAt(position);
              const helpItems = (0, shared_1.safeCall)(() => ctx.languageService.getSignatureHelpItems(fileName, offset, options));
              if (!helpItems) {
                return;
              }
              return {
                activeSignature: helpItems.selectedItemIndex,
                activeParameter: helpItems.argumentIndex,
                signatures: helpItems.items.map((item) => {
                  const signature = {
                    label: "",
                    documentation: void 0,
                    parameters: []
                  };
                  signature.label += ts.displayPartsToString(item.prefixDisplayParts);
                  item.parameters.forEach((p, i, a) => {
                    const label = ts.displayPartsToString(p.displayParts);
                    const parameter = {
                      label,
                      documentation: ts.displayPartsToString(p.documentation)
                    };
                    signature.label += label;
                    signature.parameters.push(parameter);
                    if (i < a.length - 1) {
                      signature.label += ts.displayPartsToString(item.separatorDisplayParts);
                    }
                  });
                  signature.label += ts.displayPartsToString(item.suffixDisplayParts);
                  return signature;
                })
              };
            }
          };
          async function provideDiagnosticsWorker(document, token, mode) {
            const uri = vscode_uri_1.URI.parse(document.uri);
            if (!isSemanticDocument(uri, document)) {
              return;
            }
            if (!await isValidationEnabled(document, context)) {
              return;
            }
            if (mode === "semantic" && await isCancellationRequestedWhileSync(token)) {
              return;
            }
            const fileName = ctx.uriToFileName(uri);
            const program = ctx.languageService.getProgram();
            const sourceFile = program?.getSourceFile(fileName);
            if (!program || !sourceFile) {
              return [];
            }
            const tsToken = {
              isCancellationRequested() {
                return ctx.project.typescript?.languageServiceHost.getCancellationToken?.().isCancellationRequested() ?? false;
              },
              throwIfCancellationRequested() {
              }
            };
            if (mode === "syntactic") {
              const syntacticDiagnostics = (0, shared_1.safeCall)(() => program.getSyntacticDiagnostics(sourceFile, tsToken)) ?? [];
              const suggestionDiagnostics = (0, shared_1.safeCall)(() => ctx.languageService.getSuggestionDiagnostics(fileName)) ?? [];
              return [...syntacticDiagnostics, ...suggestionDiagnostics].map((diagnostic) => (0, lspConverters_1.convertDiagnostic)(diagnostic, document, ctx.fileNameToUri, ctx.getTextDocument)).filter((diagnostic) => !!diagnostic);
            } else if (mode === "semantic") {
              const semanticDiagnostics = (0, shared_1.safeCall)(() => program.getSemanticDiagnostics(sourceFile, tsToken)) ?? [];
              const declarationDiagnostics = getEmitDeclarations(program.getCompilerOptions()) ? (0, shared_1.safeCall)(() => program.getDeclarationDiagnostics(sourceFile, tsToken)) ?? [] : [];
              return [...semanticDiagnostics, ...declarationDiagnostics].map((diagnostic) => (0, lspConverters_1.convertDiagnostic)(diagnostic, document, ctx.fileNameToUri, ctx.getTextDocument)).filter((diagnostic) => !!diagnostic);
            }
          }
          function getEmitDeclarations(compilerOptions) {
            return !!(compilerOptions.declaration || compilerOptions.composite);
          }
          function isSemanticDocument(uri, document, withJson = false) {
            const virtualScript = getVirtualScriptByUri(uri);
            if (virtualScript) {
              return true;
            }
            if (withJson && (0, shared_1.isJsonDocument)(document)) {
              return true;
            }
            return (0, shared_1.isTsDocument)(document);
          }
          async function isCancellationRequestedWhileSync(token) {
            if (sys.sync) {
              let oldSysVersion;
              let newSysVersion = sys.version;
              do {
                oldSysVersion = newSysVersion;
                languageService.getProgram();
                newSysVersion = await aggressiveSync(sys.sync);
              } while (newSysVersion !== oldSysVersion && !token.isCancellationRequested);
            }
            return token.isCancellationRequested;
          }
          async function aggressiveSync(fn) {
            const promise = fn();
            let newVersion;
            let syncing = true;
            promise.then((version) => {
              newVersion = version;
              syncing = false;
            });
            while (syncing) {
              languageService.getProgram();
              await Promise.race([promise, sleep(10)]);
            }
            return newVersion;
          }
          function sleep(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
          }
          function getVirtualScriptByUri(uri) {
            const decoded = context.decodeEmbeddedDocumentUri(uri);
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (virtualCode && sourceScript?.generated?.languagePlugin.typescript) {
              const { getServiceScript, getExtraServiceScripts } = sourceScript.generated.languagePlugin.typescript;
              const sourceFileName = uriConverter.asFileName(sourceScript.id);
              if (getServiceScript(sourceScript.generated.root)?.code === virtualCode) {
                return {
                  fileName: sourceFileName,
                  code: virtualCode
                };
              }
              for (const extraScript of getExtraServiceScripts?.(sourceFileName, sourceScript.generated.root) ?? []) {
                if (extraScript.code === virtualCode) {
                  return extraScript;
                }
              }
            }
          }
        }
      };
    }
    function getBasicTriggerCharacters(tsVersion) {
      const triggerCharacters = [".", '"', "'", "`", "/", "<"];
      if (semver.lt(tsVersion, "3.1.0") || semver.gte(tsVersion, "3.2.0")) {
        triggerCharacters.push("@");
      }
      if (semver.gte(tsVersion, "3.8.1")) {
        triggerCharacters.push("#");
      }
      if (semver.gte(tsVersion, "4.3.0")) {
        triggerCharacters.push(" ");
      }
      return triggerCharacters;
    }
  }
});

// node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/index.js
var require_volar_service_typescript = __commonJS({
  "node_modules/.pnpm/volar-service-typescript@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-typescript/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.create = create;
    var directiveComment_1 = require_directiveComment();
    var docCommentTemplate_1 = require_docCommentTemplate();
    var semantic_1 = require_semantic();
    var syntactic_1 = require_syntactic();
    function create(ts, options) {
      return [
        (0, semantic_1.create)(ts, options),
        (0, syntactic_1.create)(ts, options),
        (0, docCommentTemplate_1.create)(ts),
        (0, directiveComment_1.create)()
      ];
    }
  }
});

// node_modules/.pnpm/@emmetio+stream-reader@2.2.0/node_modules/@emmetio/stream-reader/dist/stream-reader.cjs.js
var require_stream_reader_cjs = __commonJS({
  "node_modules/.pnpm/@emmetio+stream-reader@2.2.0/node_modules/@emmetio/stream-reader/dist/stream-reader.cjs.js"(exports2, module2) {
    "use strict";
    var StreamReader = class {
      constructor(string, start, end) {
        if (end == null && typeof string === "string") {
          end = string.length;
        }
        this.string = string;
        this.pos = this.start = start || 0;
        this.end = end;
      }
      /**
       * Returns true only if the stream is at the end of the file.
       * @returns {Boolean}
       */
      eof() {
        return this.pos >= this.end;
      }
      /**
       * Creates a new stream instance which is limited to given `start` and `end`
       * range. E.g. its `eof()` method will look at `end` property, not actual
       * stream end
       * @param  {Point} start
       * @param  {Point} end
       * @return {StreamReader}
       */
      limit(start, end) {
        return new this.constructor(this.string, start, end);
      }
      /**
       * Returns the next character code in the stream without advancing it.
       * Will return NaN at the end of the file.
       * @returns {Number}
       */
      peek() {
        return this.string.charCodeAt(this.pos);
      }
      /**
       * Returns the next character in the stream and advances it.
       * Also returns <code>undefined</code> when no more characters are available.
       * @returns {Number}
       */
      next() {
        if (this.pos < this.string.length) {
          return this.string.charCodeAt(this.pos++);
        }
      }
      /**
       * `match` can be a character code or a function that takes a character code
       * and returns a boolean. If the next character in the stream 'matches'
       * the given argument, it is consumed and returned.
       * Otherwise, `false` is returned.
       * @param {Number|Function} match
       * @returns {Boolean}
       */
      eat(match) {
        const ch = this.peek();
        const ok = typeof match === "function" ? match(ch) : ch === match;
        if (ok) {
          this.next();
        }
        return ok;
      }
      /**
       * Repeatedly calls <code>eat</code> with the given argument, until it
       * fails. Returns <code>true</code> if any characters were eaten.
       * @param {Object} match
       * @returns {Boolean}
       */
      eatWhile(match) {
        const start = this.pos;
        while (!this.eof() && this.eat(match)) {
        }
        return this.pos !== start;
      }
      /**
       * Backs up the stream n characters. Backing it up further than the
       * start of the current token will cause things to break, so be careful.
       * @param {Number} n
       */
      backUp(n) {
        this.pos -= n || 1;
      }
      /**
       * Get the string between the start of the current token and the
       * current stream position.
       * @returns {String}
       */
      current() {
        return this.substring(this.start, this.pos);
      }
      /**
       * Returns substring for given range
       * @param  {Number} start
       * @param  {Number} [end]
       * @return {String}
       */
      substring(start, end) {
        return this.string.slice(start, end);
      }
      /**
       * Creates error object with current stream state
       * @param {String} message
       * @return {Error}
       */
      error(message) {
        const err = new Error(`${message} at char ${this.pos + 1}`);
        err.originalMessage = message;
        err.pos = this.pos;
        err.string = this.string;
        return err;
      }
    };
    module2.exports = StreamReader;
  }
});

// node_modules/.pnpm/@emmetio+stream-reader-utils@0.1.0/node_modules/@emmetio/stream-reader-utils/dist/stream-reader-utils.cjs.js
var require_stream_reader_utils_cjs = __commonJS({
  "node_modules/.pnpm/@emmetio+stream-reader-utils@0.1.0/node_modules/@emmetio/stream-reader-utils/dist/stream-reader-utils.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var SINGLE_QUOTE = 39;
    var DOUBLE_QUOTE = 34;
    var defaultOptions = {
      escape: 92,
      // \ character
      throws: false
    };
    var eatQuoted = function(stream, options) {
      options = options ? Object.assign({}, defaultOptions, options) : defaultOptions;
      const start = stream.pos;
      const quote = stream.peek();
      if (stream.eat(isQuote)) {
        while (!stream.eof()) {
          switch (stream.next()) {
            case quote:
              stream.start = start;
              return true;
            case options.escape:
              stream.next();
              break;
          }
        }
        stream.pos = start;
        if (options.throws) {
          throw stream.error("Unable to consume quoted string");
        }
      }
      return false;
    };
    function isQuote(code) {
      return code === SINGLE_QUOTE || code === DOUBLE_QUOTE;
    }
    function isNumber(code) {
      return code > 47 && code < 58;
    }
    function isAlpha(code, from, to) {
      from = from || 65;
      to = to || 90;
      code &= ~32;
      return code >= from && code <= to;
    }
    function isAlphaNumeric(code) {
      return isNumber(code) || isAlpha(code);
    }
    function isWhiteSpace(code) {
      return code === 32 || code === 9 || code === 160;
    }
    function isSpace(code) {
      return isWhiteSpace(code) || code === 10 || code === 13;
    }
    var defaultOptions$1 = {
      escape: 92,
      // \ character
      throws: false
    };
    function eatPair(stream, open, close, options) {
      options = options ? Object.assign({}, defaultOptions$1, options) : defaultOptions$1;
      const start = stream.pos;
      if (stream.eat(open)) {
        let stack = 1, ch;
        while (!stream.eof()) {
          if (eatQuoted(stream, options)) {
            continue;
          }
          ch = stream.next();
          if (ch === open) {
            stack++;
          } else if (ch === close) {
            stack--;
            if (!stack) {
              stream.start = start;
              return true;
            }
          } else if (ch === options.escape) {
            stream.next();
          }
        }
        stream.pos = start;
        if (options.throws) {
          throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);
        }
      }
      return false;
    }
    exports2.eatQuoted = eatQuoted;
    exports2.isQuote = isQuote;
    exports2.isAlpha = isAlpha;
    exports2.isNumber = isNumber;
    exports2.isAlphaNumeric = isAlphaNumeric;
    exports2.isSpace = isSpace;
    exports2.isWhiteSpace = isWhiteSpace;
    exports2.eatPair = eatPair;
  }
});

// node_modules/.pnpm/@emmetio+css-parser@0.4.1/node_modules/@emmetio/css-parser/dist/css-parser.cjs.js
var require_css_parser_cjs = __commonJS({
  "node_modules/.pnpm/@emmetio+css-parser@0.4.1/node_modules/@emmetio/css-parser/dist/css-parser.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var StreamReader = _interopDefault(require_stream_reader_cjs());
    var _emmetio_streamReaderUtils = require_stream_reader_utils_cjs();
    var Node = class {
      constructor(type) {
        this.type = type;
        this.children = [];
        this.parent = null;
      }
      get firstChild() {
        return this.children[0];
      }
      get nextSibling() {
        const ix = this.index();
        return ix !== -1 ? this.parent.children[ix + 1] : null;
      }
      get previousSibling() {
        const ix = this.index();
        return ix !== -1 ? this.parent.children[ix - 1] : null;
      }
      /**
       * Returns current elements index in parent list of child nodes
       * @return {Number}
       */
      index() {
        return this.parent ? this.parent.children.indexOf(this) : -1;
      }
      /**
       * Adds given node as a child
       * @param {Node} node
       * @return {Node} Current node
       */
      add(node) {
        if (node) {
          node.remove();
          this.children.push(node);
          node.parent = this;
        }
        return this;
      }
      /**
       * Removes current node from its parent
       * @return {Node} Current node
       */
      remove() {
        if (this.parent) {
          const ix = this.index();
          if (ix !== -1) {
            this.parent.children.splice(ix, 1);
            this.parent = null;
          }
        }
        return this;
      }
    };
    var Stylesheet = class extends Node {
      constructor() {
        super("stylesheet");
        this.comments = [];
      }
      /**
       * Returns nodes start position in stream
       * @return {*}
       */
      get start() {
        const node = this.firstChild;
        return node && node.start;
      }
      /**
       * Returns nodes end position in stream
       * @return {*}
       */
      get end() {
        const node = this.children[this.children.length - 1];
        return node && node.end;
      }
      /**
       * Adds comment token into a list.
       * This somewhat awkward feature is required to properly detect comment
       * ranges. Specifically, in Atom: its API provides scopes limited to current
       * line only
       * @param {Token} token
       */
      addComment(token) {
        this.comments.push(token);
      }
    };
    function trimTokens(tokens) {
      tokens = tokens.slice();
      let len;
      while (len !== tokens.length) {
        len = tokens.length;
        if (isFormattingToken(tokens[0])) {
          tokens.shift();
        }
        if (isFormattingToken(last(tokens))) {
          tokens.pop();
        }
      }
      return tokens;
    }
    function trimFormatting(tokens) {
      return trimTokens(tokens, isFormattingToken);
    }
    function isFormattingToken(token) {
      const type = token && token.type;
      return type === "whitespace" || type === "comment";
    }
    function eatString(stream, string2) {
      const start = stream.pos;
      for (let i = 0, il = string2.length; i < il; i++) {
        if (!stream.eat(string2.charCodeAt(i))) {
          stream.pos = start;
          return false;
        }
      }
      return true;
    }
    function consume(stream, match) {
      const start = stream.pos;
      if (stream.eat(match)) {
        stream.start = start;
        return true;
      }
      return false;
    }
    function consumeWhile(stream, match) {
      const start = stream.pos;
      if (stream.eatWhile(match)) {
        stream.start = start;
        return true;
      }
      return false;
    }
    function last(arr) {
      return arr[arr.length - 1];
    }
    function valueOf(token) {
      return token && token.valueOf();
    }
    var Token = class {
      /**
       * @param {StreamReader} stream
       * @param {String}       type    Token type
       * @param {Object}       [start] Tokens start position in `stream`
       * @param {Object}       [end]   Tokens end position in `stream`
       */
      constructor(stream, type, start, end) {
        this.stream = stream;
        this.start = start != null ? start : stream.start;
        this.end = end != null ? end : stream.pos;
        this.type = type;
        this._props = null;
        this._value = null;
        this._items = null;
      }
      get size() {
        return this._items ? this._items.length : 0;
      }
      get items() {
        return this._items;
      }
      clone(start, end) {
        return new this.constructor(
          this.stream,
          this.type,
          start != null ? start : this.start,
          end != null ? end : this.end
        );
      }
      add(item) {
        if (Array.isArray(item)) {
          for (let i = 0, il = item.length; i < il; i++) {
            this.add(item[i]);
          }
        } else if (item) {
          if (!this._items) {
            this._items = [item];
          } else {
            this._items.push(item);
          }
        }
        return this;
      }
      remove(item) {
        if (this._items) {
          const ix = this._items.indexOf(item);
          if (ix !== -1) {
            this._items.splice(ix, 1);
          }
        }
        return this;
      }
      item(i) {
        const size = this.size;
        return this._items && this._items[(size + i) % size];
      }
      limit() {
        return this.stream.limit(this.start, this.end);
      }
      slice(from, to) {
        const token = this.clone();
        const items = this._items && this._items.slice(from, to);
        if (items && items.length) {
          token.start = items[0].start;
          token.end = items[items.length - 1].end;
          token.add(items);
        } else if (items) {
          token.start = token.end;
        }
        return token;
      }
      property(name, value2) {
        if (typeof value2 !== "undefined") {
          if (!this._props) {
            this._props = {};
          }
          this._props[name] = value2;
        }
        return this._props && this._props[name];
      }
      /**
       * Returns token textual representation
       * @return {String}
       */
      toString() {
        return `${this.valueOf()} [${this.start}, ${this.end}] (${this.type})`;
      }
      valueOf() {
        if (this._value === null) {
          this._value = this.stream.substring(this.start, this.end);
        }
        return this._value;
      }
    };
    var COMMA = 44;
    var PROP_DELIMITER$1 = 58;
    var PROP_TERMINATOR$1 = 59;
    var RULE_START$1 = 123;
    var RULE_END$1 = 125;
    var types = (/* @__PURE__ */ new Map()).set(COMMA, "comma").set(PROP_DELIMITER$1, "propertyDelimiter").set(PROP_TERMINATOR$1, "propertyTerminator").set(RULE_START$1, "ruleStart").set(RULE_END$1, "ruleEnd");
    function separator(stream) {
      if (isSeparator(stream.peek())) {
        const start = stream.pos;
        const type = types.get(stream.next());
        const token = new Token(stream, "separator", start);
        token.property("type", type);
        return token;
      }
    }
    function isSeparator(code) {
      return code === COMMA || code === PROP_DELIMITER$1 || code === PROP_TERMINATOR$1 || code === RULE_START$1 || code === RULE_END$1;
    }
    var ARGUMENTS_START = 40;
    var ARGUMENTS_END = 41;
    var args = function(stream, tokenConsumer) {
      if (stream.peek() === ARGUMENTS_START) {
        const start = stream.pos;
        stream.next();
        const tokens = [];
        let t;
        let usePropTerminator = false;
        while (!stream.eof()) {
          if (isUnexpectedTerminator(stream.peek()) || stream.eat(ARGUMENTS_END)) {
            break;
          }
          t = tokenConsumer(stream);
          if (!t) {
            break;
          }
          if (isSemicolonSeparator(t)) {
            usePropTerminator = true;
          }
          tokens.push(t);
        }
        stream.start = start;
        return createArgumentList(stream, tokens, usePropTerminator);
      }
    };
    function isUnexpectedTerminator(code) {
      return code === RULE_START$1 || code === RULE_END$1;
    }
    function createArgumentList(stream, tokens, usePropTerminator) {
      const argsToken = new Token(stream, "arguments");
      const isSeparator2 = usePropTerminator ? isSemicolonSeparator : isCommaSeparator;
      let arg = [];
      for (let i = 0, il = tokens.length, token; i < il; i++) {
        token = tokens[i];
        if (isSeparator2(token)) {
          argsToken.add(createArgument(stream, arg) || createEmptyArgument(stream, token.start));
          arg.length = 0;
        } else {
          arg.push(token);
        }
      }
      if (arg.length) {
        argsToken.add(createArgument(stream, arg));
      }
      return argsToken;
    }
    function createArgument(stream, tokens) {
      tokens = trimFormatting(tokens);
      if (tokens.length) {
        const arg = new Token(stream, "argument", tokens[0].start, last(tokens).end);
        for (let i = 0; i < tokens.length; i++) {
          arg.add(tokens[i]);
        }
        return arg;
      }
    }
    function createEmptyArgument(stream, pos) {
      const token = new Token(stream, "argument", pos, pos);
      token.property("empty", true);
      return token;
    }
    function isCommaSeparator(token) {
      return token.property("type") === "comma";
    }
    function isSemicolonSeparator(token) {
      return token.property("type") === "propertyTerminator";
    }
    var HYPHEN = 45;
    var UNDERSCORE = 95;
    function ident(stream) {
      return eatIdent(stream) && new Token(stream, "ident");
    }
    function eatIdent(stream) {
      const start = stream.pos;
      stream.eat(HYPHEN);
      if (stream.eat(isIdentStart)) {
        stream.eatWhile(isIdent);
        stream.start = start;
        return true;
      }
      stream.pos = start;
      return false;
    }
    function isIdentStart(code) {
      return code === UNDERSCORE || code === HYPHEN || _emmetio_streamReaderUtils.isAlpha(code) || code >= 128;
    }
    function isIdent(code) {
      return _emmetio_streamReaderUtils.isNumber(code) || isIdentStart(code);
    }
    function prefixed(stream, tokenType, prefix, body, allowEmptyBody) {
      const start = stream.pos;
      if (stream.eat(prefix)) {
        const bodyToken = body(stream, start);
        if (bodyToken || allowEmptyBody) {
          stream.start = start;
          return new Token(stream, tokenType, start).add(bodyToken);
        }
      }
      stream.pos = start;
    }
    var AT = 64;
    function atKeyword(stream) {
      return prefixed(stream, "at-keyword", AT, ident);
    }
    var HASH = 35;
    var AT$1 = 64;
    function interpolation(stream, tokenConsumer) {
      const start = stream.pos;
      tokenConsumer = tokenConsumer || defaultTokenConsumer;
      if ((stream.eat(HASH) || stream.eat(AT$1)) && stream.eat(RULE_START$1)) {
        const container = new Token(stream, "interpolation", start);
        let stack = 1, token;
        while (!stream.eof()) {
          if (stream.eat(RULE_START$1)) {
            stack++;
          } else if (stream.eat(RULE_END$1)) {
            stack--;
            if (!stack) {
              container.end = stream.pos;
              return container;
            }
          } else if (token = tokenConsumer(stream)) {
            container.add(token);
          } else {
            break;
          }
        }
      }
      stream.pos = start;
    }
    function eatInterpolation(stream) {
      const start = stream.pos;
      if ((stream.eat(HASH) || stream.eat(AT$1)) && _emmetio_streamReaderUtils.eatPair(stream, RULE_START$1, RULE_END$1)) {
        stream.start = start;
        return true;
      }
      stream.pos = start;
      return false;
    }
    function defaultTokenConsumer(stream) {
      const start = stream.pos;
      while (!stream.eof()) {
        if (stream.peek() === RULE_END$1) {
          break;
        }
        eatString$1(stream) || stream.next();
      }
      if (start !== stream.pos) {
        return new Token(stream, "expression", start);
      }
    }
    function string(stream) {
      return eatString$1(stream, true);
    }
    function eatString$1(stream, asToken) {
      let ch = stream.peek(), pos, tokens, token;
      if (_emmetio_streamReaderUtils.isQuote(ch)) {
        stream.start = stream.pos;
        stream.next();
        const quote = ch;
        const valueStart = stream.pos;
        while (!stream.eof()) {
          pos = stream.pos;
          if (stream.eat(quote) || stream.eat(isNewline)) {
            break;
          } else if (stream.eat(
            92
            /* \ */
          )) {
            stream.eat(isNewline);
          } else if (asToken && (token = interpolation(stream))) {
            if (!tokens) {
              tokens = [token];
            } else {
              tokens.push(token);
            }
          }
          stream.next();
        }
        if (asToken) {
          const token2 = new Token(stream, "string");
          const inner = new Token(stream, "unquoted", valueStart, pos);
          inner.add(tokens);
          token2.add(inner);
          token2.property("quote", quote);
          return token2;
        }
        return true;
      }
      return false;
    }
    function isNewline(code) {
      return code === 10 || code === 13;
    }
    var ASTERISK = 42;
    var SLASH = 47;
    var comment = function(stream) {
      return singleLineComment(stream) || multiLineComment(stream);
    };
    function singleLineComment(stream) {
      if (eatSingleLineComment(stream)) {
        const token = new Token(stream, "comment");
        token.property("type", "single-line");
        return token;
      }
    }
    function multiLineComment(stream) {
      if (eatMultiLineComment(stream)) {
        const token = new Token(stream, "comment");
        token.property("type", "multiline");
        return token;
      }
    }
    function eatComment(stream) {
      return eatSingleLineComment(stream) || eatMultiLineComment(stream);
    }
    function eatSingleLineComment(stream) {
      const start = stream.pos;
      if (stream.eat(SLASH) && stream.eat(SLASH)) {
        stream.start = start;
        while (!stream.eof()) {
          if (isLineBreak(stream.next())) {
            break;
          }
        }
        return true;
      }
      stream.pos = start;
      return false;
    }
    function eatMultiLineComment(stream) {
      const start = stream.pos;
      if (stream.eat(SLASH) && stream.eat(ASTERISK)) {
        while (!stream.eof()) {
          if (stream.next() === ASTERISK && stream.eat(SLASH)) {
            break;
          }
        }
        stream.start = start;
        return true;
      }
      stream.pos = start;
      return false;
    }
    function isLineBreak(code) {
      return code === 10 || code === 13;
    }
    function whitespace(stream) {
      return eatWhitespace(stream) && new Token(stream, "whitespace");
    }
    function eatWhitespace(stream) {
      return consumeWhile(stream, _emmetio_streamReaderUtils.isSpace);
    }
    var ATTR_START = 91;
    var ATTR_END = 93;
    function eatAttribuite(stream) {
      const start = stream.pos;
      if (stream.eat(ATTR_START)) {
        skip(stream);
        const name = ident(stream);
        skip(stream);
        const op = operator(stream);
        skip(stream);
        const value2 = string(stream) || ident(stream);
        skip(stream);
        stream.eat(ATTR_END);
        return new Token(stream, "attribute", start).add(name).add(op).add(value2);
      }
    }
    function skip(stream) {
      while (!stream.eof()) {
        if (!eatWhitespace(stream) && !eatComment(stream)) {
          return true;
        }
      }
    }
    function operator(stream) {
      return consumeWhile(stream, isOperator) && new Token(stream, "operator");
    }
    function isOperator(code) {
      return code === 126 || code === 124 || code === 94 || code === 36 || code === 42 || code === 61;
    }
    var BACKTICK = 96;
    function backtick(stream) {
      if (eatBacktick(stream)) {
        return new Token(stream, "backtick");
      }
    }
    function eatBacktick(stream) {
      const start = stream.pos;
      if (_emmetio_streamReaderUtils.eatPair(stream, BACKTICK, BACKTICK)) {
        stream.start = start;
        return true;
      }
      return false;
    }
    var CLASS = 46;
    function className(stream) {
      return prefixed(stream, "class", CLASS, ident);
    }
    var ADJACENT_SIBLING = 43;
    var GENERAL_SIBLING = 126;
    var CHILD = 62;
    var NESTING = 38;
    var types$1 = {
      [ADJACENT_SIBLING]: "adjacentSibling",
      [GENERAL_SIBLING]: "generalSibling",
      [CHILD]: "child",
      [NESTING]: "nesting"
    };
    var combinator = function(stream) {
      if (isCombinator(stream.peek())) {
        const start = stream.pos;
        const type = types$1[stream.next()];
        const token = new Token(stream, "combinator", start);
        token.property("type", type);
        return token;
      }
    };
    function isCombinator(code) {
      return code === ADJACENT_SIBLING || code === GENERAL_SIBLING || code === NESTING || code === CHILD;
    }
    var HASH$1 = 35;
    function hash(stream) {
      return prefixed(stream, "hash", HASH$1, hashValue, true);
    }
    function hashValue(stream) {
      if (eatHashValue(stream)) {
        return new Token(stream, "hash-value");
      }
    }
    function eatHashValue(stream) {
      return consumeWhile(stream, isHashValue);
    }
    function isHashValue(code) {
      return _emmetio_streamReaderUtils.isNumber(code) || _emmetio_streamReaderUtils.isAlpha(
        code,
        65,
        70
        /* F */
      ) || code === 95 || code === 45 || code > 128;
    }
    var ID = 35;
    function id(stream) {
      return prefixed(stream, "id", ID, ident);
    }
    var IMPORTANT = 33;
    function important(stream) {
      return prefixed(stream, "important", IMPORTANT, ident);
    }
    var DOT = 46;
    function number(stream) {
      if (eatNumericPart(stream)) {
        const start = stream.start;
        const num = new Token(stream, "value");
        const unit = eatUnitPart(stream) ? new Token(stream, "unit") : null;
        return new Token(stream, "number", start).add(num).add(unit);
      }
    }
    function eatNumericPart(stream) {
      const start = stream.pos;
      stream.eat(isOperator$1);
      if (stream.eatWhile(_emmetio_streamReaderUtils.isNumber)) {
        stream.start = start;
        const decimalEnd = stream.pos;
        if (!(stream.eat(DOT) && stream.eatWhile(_emmetio_streamReaderUtils.isNumber))) {
          stream.pos = decimalEnd;
        }
        return true;
      } else if (stream.eat(DOT) && stream.eatWhile(_emmetio_streamReaderUtils.isNumber)) {
        stream.start = start;
        return true;
      }
      stream.pos = start;
      return false;
    }
    function eatUnitPart(stream) {
      return eatIdent(stream) || eatPercent(stream);
    }
    function eatPercent(stream) {
      return consume(
        stream,
        37
        /* % */
      );
    }
    function isOperator$1(code) {
      return code === 45 || code === 43;
    }
    var NOT = 33;
    var MULTIPLY = 42;
    var PLUS = 43;
    var MINUS = 45;
    var DIVIDE = 47;
    var LESS_THAN = 60;
    var EQUALS = 61;
    var GREATER_THAN = 62;
    function operator$1(stream) {
      return eatOperator(stream) && new Token(stream, "operator");
    }
    function eatOperator(stream) {
      if (consume(stream, isEquality)) {
        stream.eatWhile(EQUALS);
        return true;
      } else if (consume(stream, isOperator$2)) {
        return true;
      }
      return false;
    }
    function isEquality(code) {
      return code === NOT || code === LESS_THAN || code === EQUALS || code === GREATER_THAN;
    }
    function isOperator$2(code) {
      return code === MULTIPLY || code === PLUS || code === MINUS || code === DIVIDE || isEquality(code);
    }
    var PSEUDO = 58;
    var pseudo = function(stream) {
      const start = stream.pos;
      if (stream.eatWhile(PSEUDO)) {
        const name = ident(stream);
        if (name) {
          return new Token(stream, "pseudo", start).add(name);
        }
      }
      stream.pos = start;
    };
    var unquoted = function(stream) {
      return eatUnquoted(stream) && new Token(stream, "unquoted");
    };
    function eatUnquoted(stream) {
      return consumeWhile(stream, isUnquoted);
    }
    function isUnquoted(code) {
      return !isNaN(code) && !_emmetio_streamReaderUtils.isQuote(code) && !_emmetio_streamReaderUtils.isSpace(code) && code !== 40 && code !== 41 && code !== 92 && !isNonPrintable(code);
    }
    function isNonPrintable(code) {
      return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
    }
    function url(stream) {
      const start = stream.pos;
      if (eatString(stream, "url(")) {
        eatWhitespace(stream);
        const value2 = string(stream) || unquoted(stream);
        eatWhitespace(stream);
        stream.eat(41);
        return new Token(stream, "url", start).add(value2);
      }
      stream.pos = start;
    }
    function eatUrl(stream) {
      const start = stream.pos;
      if (eatString(stream, "url(")) {
        eatWhitespace(stream);
        eatString$1(stream) || eatUnquoted(stream);
        eatWhitespace(stream);
        stream.eat(41);
        stream.start = start;
        return true;
      }
      stream.pos = start;
      return false;
    }
    var VARIABLE = 36;
    function variable(stream) {
      return prefixed(stream, "variable", VARIABLE, variableName);
    }
    function variableName(stream) {
      if (eatVariableName(stream)) {
        return new Token(stream, "name");
      }
    }
    function eatVariableName(stream) {
      return consumeWhile(stream, isVariableName);
    }
    function isVariableName(code) {
      return code === VARIABLE || isIdent(code);
    }
    function consumeToken(stream) {
      const _token = any(stream) || args(stream, consumeToken);
      if (_token && _token.type === "ident") {
        const _args = args(stream, consumeToken);
        if (_args) {
          return new Token(stream, "function", _token.start, _args.end).add(_token).add(_args);
        }
      }
      return _token || unknown(stream);
    }
    function any(stream) {
      return formatting(stream) || url(stream) || selector(stream) || value(stream) || separator(stream);
    }
    function selector(stream) {
      return interpolation(stream) || backtick(stream) || ident(stream) || atKeyword(stream) || className(stream) || id(stream) || pseudo(stream) || eatAttribuite(stream) || combinator(stream);
    }
    function value(stream) {
      return url(stream) || string(stream) || interpolation(stream) || backtick(stream) || number(stream) || hash(stream) || keyword(stream) || important(stream) || operator$1(stream);
    }
    function keyword(stream) {
      return backtick(stream) || variable(stream) || atKeyword(stream) || ident(stream);
    }
    function formatting(stream) {
      return comment(stream) || whitespace(stream);
    }
    function unknown(stream) {
      stream.start = stream.pos;
      const ch = stream.next();
      if (ch != null) {
        return new Token(stream, "unknown");
      }
    }
    function parseSelector(source) {
      return parseList(source, "selector");
    }
    function parsePropertyName(source) {
      const stream = typeof source === "string" ? new StreamReader(source) : source;
      const items = [];
      while (!stream.eof()) {
        items.push(consumeToken(stream));
      }
      let token;
      if (items.length === 1) {
        token = items[0];
      } else {
        token = new Token(stream, "property-name", stream.start, stream.end);
        for (let i = 0, il = items.length; i < il; i++) {
          token.add(items[i]);
        }
      }
      return token;
    }
    function parsePropertyValue(source) {
      return parseList(source);
    }
    function parseMediaExpression(source) {
      return parseList(source);
    }
    function parseList(source, tokenType) {
      tokenType = tokenType || "item";
      const stream = typeof source === "string" ? new StreamReader(source) : source;
      const items = [];
      const fragments = [];
      const flush = () => {
        const clean = trimFormatting(fragments);
        if (clean.length) {
          const item = new Token(stream, tokenType, clean[0].start, last(clean).end);
          for (let i = 0; i < clean.length; i++) {
            item.add(clean[i]);
          }
          items.push(item);
        }
        fragments.length = 0;
      };
      let token;
      while (!stream.eof()) {
        if (stream.eat(
          44
          /* , */
        )) {
          flush();
        } else if (token = consumeToken(stream)) {
          if (token.type !== "comment") {
            fragments.push(token);
          }
        } else {
          throw stream.error("Unexpected character");
        }
      }
      flush();
      return items;
    }
    function createRule(stream, tokens, contentStart, contentEnd) {
      if (!tokens.length) {
        return null;
      }
      const name = tokens[0];
      name.end = last(tokens).end;
      return new Rule(stream, name, contentStart, contentEnd);
    }
    var Rule = class extends Node {
      /**
       * @param {StreamReader} stream
       * @param {Token} name         Rules name token
       * @param {Token} contentStart Rules content start token
       * @param {Token} [contentEnd] Rules content end token
       */
      constructor(stream, name, contentStart, contentEnd) {
        super("rule");
        this.stream = stream;
        this.selectorToken = name;
        this.contentStartToken = contentStart;
        this.contentEndToken = contentEnd || contentStart;
        this._parsedSelector = null;
      }
      /**
       * Returns rule selector
       * @return {String}
       */
      get selector() {
        return valueOf(this.selectorToken);
      }
      get parsedSelector() {
        if (!this._parsedSelector) {
          this._parsedSelector = parseSelector(this.selectorToken.limit());
        }
        return this._parsedSelector;
      }
      /**
       * Returns nodes start position in stream
       * @return {*}
       */
      get start() {
        return this.selectorToken && this.selectorToken.start;
      }
      /**
       * Returns nodes end position in stream
       * @return {*}
       */
      get end() {
        const token = this.contentEndToken || this.contentStartToken || this.nameToken;
        return token && token.end;
      }
    };
    function createAtRule(stream, tokens, contentStart, contentEnd) {
      if (!tokens.length) {
        return null;
      }
      let ix = 0, expression;
      const name = tokens[ix++];
      if (ix < tokens.length) {
        expression = tokens[ix++];
        expression.type = "expression";
        expression.end = last(tokens).end;
      } else {
        expression = new Token(stream, "expression", name.end, name.end);
      }
      return new AtRule(stream, name, expression, contentStart, contentEnd);
    }
    var AtRule = class extends Node {
      constructor(stream, name, expression, contentStart, contentEnd) {
        super("at-rule");
        this.stream = stream;
        this.nameToken = name;
        this.expressionToken = expression;
        this.contentStartToken = contentStart;
        this.contentEndToken = contentEnd || contentStart;
        this._parsedExpression = null;
      }
      /**
       * Returns at-rule name
       * @return {String}
       */
      get name() {
        return valueOf(this.nameToken && this.nameToken.item(0));
      }
      get expression() {
        return valueOf(this.expressionToken);
      }
      get parsedExpression() {
        if (!this._parsedExpression) {
          this._parsedExpression = parseMediaExpression(this.expressionToken.limit());
        }
        return this._parsedExpression;
      }
      /**
       * Returns nodes start position in stream
       * @return {*}
       */
      get start() {
        return this.nameToken && this.nameToken.start;
      }
      /**
       * Returns nodes end position in stream
       * @return {*}
       */
      get end() {
        const token = this.contentEndToken || this.contentStartToken || this.nameToken;
        return token && token.end;
      }
    };
    function createProperty(stream, tokens, terminator) {
      if (!tokens.length) {
        return null;
      }
      let separator2, value2, ix = 0;
      const name = tokens[ix++];
      if (ix < tokens.length) {
        value2 = tokens[ix++];
        value2.type = "value";
        value2.end = last(tokens).end;
      }
      if (name && value2) {
        separator2 = new Token(stream, "separator", name.end, value2.start);
      }
      return new Property(
        stream,
        name,
        value2,
        separator2,
        terminator
      );
    }
    var Property = class extends Node {
      constructor(stream, name, value2, separator2, terminator) {
        super("property");
        this.stream = stream;
        this.nameToken = name;
        this.valueToken = value2;
        this._parsedName = null;
        this._parsedValue = null;
        this.separatorToken = separator2;
        this.terminatorToken = terminator;
      }
      /**
       * Property name
       * @return {String}
       */
      get name() {
        return valueOf(this.nameToken);
      }
      /**
       * Returns parsed sub-tokens of current property name
       * @return {Token[]}
       */
      get parsedName() {
        if (!this._parsedName) {
          this._parsedName = parsePropertyName(this.nameToken.limit());
        }
        return this._parsedName;
      }
      /**
       * Property value
       * @return {String}
       */
      get value() {
        return valueOf(this.valueToken);
      }
      /**
       * Parsed value parts: a list of tokens, separated by comma. Each token may
       * contains parsed sub-tokens and so on
       * @return {Token[]}
       */
      get parsedValue() {
        if (!this._parsedValue) {
          this._parsedValue = parsePropertyValue(this.valueToken.limit());
        }
        return this._parsedValue;
      }
      get separator() {
        return valueOf(this.separatorToken);
      }
      get terminator() {
        return valueOf(this.terminatorToken);
      }
      get start() {
        const token = this.nameToken || this.separatorToken || this.valueToken || this.terminatorToken;
        return token && token.start;
      }
      get end() {
        const token = this.terminatorToken || this.valueToken || this.separatorToken || this.nameToken;
        return token && token.end;
      }
    };
    var LBRACE = 40;
    var RBRACE = 41;
    var PROP_DELIMITER = 58;
    var PROP_TERMINATOR = 59;
    var RULE_START = 123;
    var RULE_END = 125;
    function parseStylesheet(source) {
      const stream = typeof source === "string" ? new StreamReader(source) : source;
      const root = new Stylesheet();
      let ctx = root, child, accum, token;
      let tokens = [];
      const flush = () => {
        if (accum) {
          tokens.push(accum);
          accum = null;
        }
      };
      while (!stream.eof()) {
        if (eatWhitespace(stream)) {
          continue;
        }
        if (token = comment(stream)) {
          root.addComment(token);
          continue;
        }
        stream.start = stream.pos;
        if (stream.eatWhile(PROP_DELIMITER)) {
          if (!tokens.length) {
            if (accum) {
              flush();
            } else {
              accum = new Token(stream, "preparse");
            }
          }
        } else if (stream.eat(PROP_TERMINATOR)) {
          flush();
          ctx.add(createProperty(stream, tokens, new Token(stream, "termintator")));
          tokens.length = 0;
        } else if (stream.eat(RULE_START)) {
          flush();
          if (tokens.length > 0) {
            child = tokens[0].type === "at-keyword" ? createAtRule(stream, tokens, new Token(stream, "body-start")) : createRule(stream, tokens, new Token(stream, "body-start"));
            ctx.add(child);
            ctx = child;
            tokens.length = 0;
          }
        } else if (stream.eat(RULE_END)) {
          flush();
          ctx.add(createProperty(stream, tokens));
          if (ctx.type !== "stylesheet") {
            ctx.contentEndToken = new Token(stream, "body-end");
            ctx = ctx.parent;
          }
          tokens.length = 0;
        } else if (token = atKeyword(stream)) {
          flush();
          tokens.push(token);
        } else if (eatUrl(stream) || eatInterpolation(stream) || eatBacktick(stream) || eatBraces(stream, root) || eatString$1(stream) || stream.next()) {
          accum = accum || new Token(stream, "preparse");
          accum.end = stream.pos;
        } else {
          throw new Error(`Unexpected end-of-stream at ${stream.pos}`);
        }
      }
      if (accum) {
        tokens.push(accum);
      }
      ctx.add(createProperty(stream, tokens));
      stream.start = stream.pos;
      while (ctx && ctx !== root) {
        ctx.contentEndToken = new Token(stream, "body-end");
        ctx = ctx.parent;
      }
      return root;
    }
    function lexer(source, consumer) {
      consumer = consumer || consumeToken;
      const stream = typeof source === "string" ? new StreamReader(source) : source;
      const result = [];
      let token;
      while (!stream.eof() && (token = consumer(stream))) {
        result.push(token);
      }
      return result;
    }
    function eatBraces(stream, root) {
      if (stream.eat(LBRACE)) {
        let stack = 1, token;
        while (!stream.eof()) {
          if (stream.eat(RBRACE)) {
            stack--;
            if (!stack) {
              break;
            }
          } else if (stream.eat(LBRACE)) {
            stack++;
          } else if (eatUrl(stream) || eatString$1(stream)) {
            continue;
          } else if (token = comment(stream)) {
            root.addComment(token);
            continue;
          } else {
            stream.next();
          }
        }
        return true;
      }
      return false;
    }
    exports2["default"] = parseStylesheet;
    exports2.lexer = lexer;
    exports2.Token = Token;
    exports2.any = any;
    exports2.selector = selector;
    exports2.value = value;
    exports2.keyword = keyword;
    exports2.variable = variable;
    exports2.formatting = formatting;
    exports2.comment = comment;
    exports2.whitespace = whitespace;
    exports2.ident = ident;
    exports2.string = string;
    exports2.url = url;
    exports2.interpolation = interpolation;
    exports2.backtick = backtick;
    exports2.parseMediaExpression = parseMediaExpression;
    exports2.parsePropertyName = parsePropertyName;
    exports2.parsePropertyValue = parsePropertyValue;
    exports2.parseSelector = parseSelector;
    exports2.createProperty = createProperty;
    exports2.createRule = createRule;
    exports2.createAtRule = createAtRule;
  }
});

// node_modules/.pnpm/@emmetio+scanner@1.0.4/node_modules/@emmetio/scanner/scanner.cjs
var require_scanner = __commonJS({
  "node_modules/.pnpm/@emmetio+scanner@1.0.4/node_modules/@emmetio/scanner/scanner.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var defaultQuotedOptions = {
      escape: 92,
      throws: false
    };
    function isNumber(code) {
      return code > 47 && code < 58;
    }
    function isAlpha(code, from, to) {
      from = from || 65;
      to = to || 90;
      code &= ~32;
      return code >= from && code <= to;
    }
    function isAlphaNumeric(code) {
      return isNumber(code) || isAlpha(code);
    }
    function isAlphaNumericWord(code) {
      return isNumber(code) || isAlphaWord(code);
    }
    function isAlphaWord(code) {
      return code === 95 || isAlpha(code);
    }
    function isUmlaut(code) {
      return code === 196 || code == 214 || code === 220 || code === 228 || code === 246 || code === 252;
    }
    function isWhiteSpace(code) {
      return code === 32 || code === 9 || code === 160;
    }
    function isSpace(code) {
      return isWhiteSpace(code) || code === 10 || code === 13;
    }
    function eatQuoted(stream, options) {
      options = Object.assign(Object.assign({}, defaultQuotedOptions), options);
      const start = stream.pos;
      const quote = stream.peek();
      if (stream.eat(isQuote)) {
        while (!stream.eof()) {
          switch (stream.next()) {
            case quote:
              stream.start = start;
              return true;
            case options.escape:
              stream.next();
              break;
          }
        }
        stream.pos = start;
        if (options.throws) {
          throw stream.error("Unable to consume quoted string");
        }
      }
      return false;
    }
    function isQuote(code) {
      return code === 39 || code === 34;
    }
    function eatPair(stream, open, close, options) {
      options = Object.assign(Object.assign({}, defaultQuotedOptions), options);
      const start = stream.pos;
      if (stream.eat(open)) {
        let stack = 1;
        let ch;
        while (!stream.eof()) {
          if (eatQuoted(stream, options)) {
            continue;
          }
          ch = stream.next();
          if (ch === open) {
            stack++;
          } else if (ch === close) {
            stack--;
            if (!stack) {
              stream.start = start;
              return true;
            }
          } else if (ch === options.escape) {
            stream.next();
          }
        }
        stream.pos = start;
        if (options.throws) {
          throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);
        }
      }
      return false;
    }
    var Scanner = class _Scanner {
      constructor(str, start, end) {
        if (end == null && typeof str === "string") {
          end = str.length;
        }
        this.string = str;
        this.pos = this.start = start || 0;
        this.end = end || 0;
      }
      /**
       * Returns true only if the stream is at the end of the file.
       */
      eof() {
        return this.pos >= this.end;
      }
      /**
       * Creates a new stream instance which is limited to given `start` and `end`
       * range. E.g. its `eof()` method will look at `end` property, not actual
       * stream end
       */
      limit(start, end) {
        return new _Scanner(this.string, start, end);
      }
      /**
       * Returns the next character code in the stream without advancing it.
       * Will return NaN at the end of the file.
       */
      peek() {
        return this.string.charCodeAt(this.pos);
      }
      /**
       * Returns the next character in the stream and advances it.
       * Also returns <code>undefined</code> when no more characters are available.
       */
      next() {
        if (this.pos < this.string.length) {
          return this.string.charCodeAt(this.pos++);
        }
      }
      /**
       * `match` can be a character code or a function that takes a character code
       * and returns a boolean. If the next character in the stream 'matches'
       * the given argument, it is consumed and returned.
       * Otherwise, `false` is returned.
       */
      eat(match) {
        const ch = this.peek();
        const ok = typeof match === "function" ? match(ch) : ch === match;
        if (ok) {
          this.next();
        }
        return ok;
      }
      /**
       * Repeatedly calls <code>eat</code> with the given argument, until it
       * fails. Returns <code>true</code> if any characters were eaten.
       */
      eatWhile(match) {
        const start = this.pos;
        while (!this.eof() && this.eat(match)) {
        }
        return this.pos !== start;
      }
      /**
       * Backs up the stream n characters. Backing it up further than the
       * start of the current token will cause things to break, so be careful.
       */
      backUp(n) {
        this.pos -= n || 1;
      }
      /**
       * Get the string between the start of the current token and the
       * current stream position.
       */
      current() {
        return this.substring(this.start, this.pos);
      }
      /**
       * Returns substring for given range
       */
      substring(start, end) {
        return this.string.slice(start, end);
      }
      /**
       * Creates error object with current stream state
       */
      error(message, pos = this.pos) {
        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);
      }
    };
    var ScannerError = class extends Error {
      constructor(message, pos, str) {
        super(message);
        this.pos = pos;
        this.string = str;
      }
    };
    exports2.ScannerError = ScannerError;
    exports2.default = Scanner;
    exports2.eatPair = eatPair;
    exports2.eatQuoted = eatQuoted;
    exports2.isAlpha = isAlpha;
    exports2.isAlphaNumeric = isAlphaNumeric;
    exports2.isAlphaNumericWord = isAlphaNumericWord;
    exports2.isAlphaWord = isAlphaWord;
    exports2.isNumber = isNumber;
    exports2.isQuote = isQuote;
    exports2.isSpace = isSpace;
    exports2.isUmlaut = isUmlaut;
    exports2.isWhiteSpace = isWhiteSpace;
  }
});

// node_modules/.pnpm/@emmetio+html-matcher@1.3.0/node_modules/@emmetio/html-matcher/dist/html-matcher.cjs.js
var require_html_matcher_cjs = __commonJS({
  "node_modules/.pnpm/@emmetio+html-matcher@1.3.0/node_modules/@emmetio/html-matcher/dist/html-matcher.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Scanner = require_scanner();
    var Scanner__default = _interopDefault(Scanner);
    var defaultOptions = {
      xml: false,
      allTokens: false,
      special: {
        style: null,
        script: ["", "text/javascript", "application/x-javascript", "javascript", "typescript", "ts", "coffee", "coffeescript"]
      },
      empty: ["img", "meta", "link", "br", "base", "hr", "area", "wbr", "col", "embed", "input", "param", "source", "track"]
    };
    var opt = { throws: false };
    function createOptions(options = {}) {
      return Object.assign(Object.assign({}, defaultOptions), options);
    }
    function toCharCodes(str) {
      return str.split("").map((ch) => ch.charCodeAt(0));
    }
    function consumeArray(scanner, codes) {
      const start = scanner.pos;
      for (let i = 0; i < codes.length; i++) {
        if (!scanner.eat(codes[i])) {
          scanner.pos = start;
          return false;
        }
      }
      scanner.start = start;
      return true;
    }
    function consumeSection(scanner, open, close, allowUnclosed) {
      const start = scanner.pos;
      if (consumeArray(scanner, open)) {
        while (!scanner.eof()) {
          if (consumeArray(scanner, close)) {
            scanner.start = start;
            return true;
          }
          scanner.pos++;
        }
        if (allowUnclosed) {
          scanner.start = start;
          return true;
        }
        scanner.pos = start;
        return false;
      }
      scanner.pos = start;
      return false;
    }
    function nameStartChar(ch) {
      return Scanner.isAlpha(ch) || ch === 58 || ch === 95 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 767 || ch >= 880 && ch <= 893 || ch >= 895 && ch <= 8191;
    }
    function nameChar(ch) {
      return nameStartChar(ch) || ch === 45 || ch === 46 || Scanner.isNumber(ch) || ch === 183 || ch >= 768 && ch <= 879;
    }
    function ident(scanner) {
      const start = scanner.pos;
      if (scanner.eat(nameStartChar)) {
        scanner.eatWhile(nameChar);
        scanner.start = start;
        return true;
      }
      return false;
    }
    function isTerminator(code) {
      return code === 62 || code === 47;
    }
    function isUnquoted(code) {
      return !isNaN(code) && !Scanner.isQuote(code) && !Scanner.isSpace(code) && !isTerminator(code);
    }
    function consumePaired(scanner) {
      return Scanner.eatPair(scanner, 60, 62, opt) || Scanner.eatPair(scanner, 40, 41, opt) || Scanner.eatPair(scanner, 91, 93, opt) || Scanner.eatPair(scanner, 123, 125, opt);
    }
    function getUnquotedValue(value) {
      if (Scanner.isQuote(value.charCodeAt(0))) {
        value = value.slice(1);
      }
      if (Scanner.isQuote(value.charCodeAt(value.length - 1))) {
        value = value.slice(0, -1);
      }
      return value;
    }
    function attributes(src, name) {
      const result = [];
      let start = 0;
      let end = src.length;
      if (name) {
        start = name.length + 1;
        end -= src.slice(-2) === "/>" ? 2 : 1;
      }
      const scanner = new Scanner__default(src, start, end);
      while (!scanner.eof()) {
        scanner.eatWhile(Scanner.isSpace);
        if (attributeName(scanner)) {
          const token = {
            name: scanner.current(),
            nameStart: scanner.start,
            nameEnd: scanner.pos
          };
          if (scanner.eat(
            61
            /* Equals */
          ) && attributeValue(scanner)) {
            token.value = scanner.current();
            token.valueStart = scanner.start;
            token.valueEnd = scanner.pos;
          }
          result.push(token);
        } else {
          scanner.pos++;
        }
      }
      return result;
    }
    function attributeName(scanner) {
      const start = scanner.pos;
      if (scanner.eat(
        42
        /* Asterisk */
      ) || scanner.eat(
        35
        /* Hash */
      )) {
        ident(scanner);
        scanner.start = start;
        return true;
      }
      return consumePaired(scanner) || ident(scanner);
    }
    function attributeValue(scanner) {
      return Scanner.eatQuoted(scanner, opt) || consumePaired(scanner) || unquoted(scanner);
    }
    function getAttributeValue(attrs, name) {
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (attr.name === name) {
          return attr.value && getUnquotedValue(attr.value);
        }
      }
    }
    function unquoted(scanner) {
      const start = scanner.pos;
      if (scanner.eatWhile(isUnquoted)) {
        scanner.start = start;
        return true;
      }
    }
    var cdataOpen = toCharCodes("<![CDATA[");
    var cdataClose = toCharCodes("]]>");
    var commentOpen = toCharCodes("<!--");
    var commentClose = toCharCodes("-->");
    var piStart = toCharCodes("<?");
    var piEnd = toCharCodes("?>");
    var erbStart = toCharCodes("<%");
    var erbEnd = toCharCodes("%>");
    function scan(source, callback, options) {
      const scanner = new Scanner__default(source);
      const special = options ? options.special : null;
      const allTokens = options ? options.allTokens : false;
      let type;
      let name;
      let nameStart;
      let nameEnd;
      let nameCodes;
      let found = false;
      let piName = null;
      while (!scanner.eof()) {
        const start = scanner.pos;
        if (cdata(scanner)) {
          if (allTokens && callback("#cdata", 4, scanner.start, scanner.pos) === false) {
            break;
          }
        } else if (comment(scanner)) {
          if (allTokens && callback("#comment", 6, scanner.start, scanner.pos) === false) {
            break;
          }
        } else if (erb(scanner)) {
          if (allTokens && callback("#erb", 7, scanner.start, scanner.pos) === false) {
            break;
          }
        } else if (piName = processingInstruction(scanner)) {
          if (allTokens && callback(piName, 5, scanner.start, scanner.pos) === false) {
            break;
          }
        } else if (scanner.eat(
          60
          /* LeftAngle */
        )) {
          type = scanner.eat(
            47
            /* Slash */
          ) ? 2 : 1;
          nameStart = scanner.pos;
          if (ident(scanner)) {
            nameEnd = scanner.pos;
            if (type !== 2) {
              skipAttributes(scanner);
              scanner.eatWhile(Scanner.isSpace);
              if (scanner.eat(
                47
                /* Slash */
              )) {
                type = 3;
              }
            }
            if (scanner.eat(
              62
              /* RightAngle */
            )) {
              name = scanner.substring(nameStart, nameEnd);
              if (callback(name, type, start, scanner.pos) === false) {
                break;
              }
              if (type === 1 && special && isSpecial(special, name, source, start, scanner.pos)) {
                nameCodes = toCharCodes(name);
                found = false;
                while (!scanner.eof()) {
                  if (consumeClosing(scanner, nameCodes)) {
                    found = true;
                    break;
                  }
                  scanner.pos++;
                }
                if (found && callback(name, 2, scanner.start, scanner.pos) === false) {
                  break;
                }
              }
            }
          }
        } else {
          scanner.pos++;
        }
      }
    }
    function skipAttributes(scanner) {
      while (!scanner.eof()) {
        scanner.eatWhile(Scanner.isSpace);
        if (attributeName(scanner)) {
          if (scanner.eat(
            61
            /* Equals */
          )) {
            attributeValue(scanner);
          }
        } else if (isTerminator(scanner.peek())) {
          break;
        } else {
          scanner.pos++;
        }
      }
    }
    function consumeClosing(scanner, name) {
      const start = scanner.pos;
      if (scanner.eat(
        60
        /* LeftAngle */
      ) && scanner.eat(
        47
        /* Slash */
      ) && consumeArray(scanner, name) && scanner.eat(
        62
        /* RightAngle */
      )) {
        scanner.start = start;
        return true;
      }
      scanner.pos = start;
      return false;
    }
    function cdata(scanner) {
      return consumeSection(scanner, cdataOpen, cdataClose, true);
    }
    function comment(scanner) {
      return consumeSection(scanner, commentOpen, commentClose, true);
    }
    function processingInstruction(scanner) {
      const start = scanner.pos;
      if (consumeArray(scanner, piStart) && ident(scanner)) {
        const name = scanner.current();
        while (!scanner.eof()) {
          if (consumeArray(scanner, piEnd)) {
            break;
          }
          Scanner.eatQuoted(scanner) || scanner.pos++;
        }
        scanner.start = start;
        return name;
      }
      scanner.pos = start;
      return null;
    }
    function erb(scanner) {
      const start = scanner.pos;
      if (consumeArray(scanner, erbStart)) {
        while (!scanner.eof()) {
          if (consumeArray(scanner, erbEnd)) {
            break;
          }
          Scanner.eatQuoted(scanner) || scanner.pos++;
        }
        scanner.start = start;
        return true;
      }
      scanner.pos = start;
      return false;
    }
    function isSpecial(special, name, source, start, end) {
      if (name in special) {
        const typeValues = special[name];
        if (!Array.isArray(typeValues)) {
          return true;
        }
        const attrs = attributes(source.substring(start + name.length + 1, end - 1));
        return typeValues.includes(getAttributeValue(attrs, "type") || "");
      }
      return false;
    }
    function match(source, pos, opt2) {
      const pool = [];
      const stack = [];
      const options = createOptions(opt2);
      let result = null;
      scan(source, (name, type, start, end) => {
        if (type === 1 && isSelfClose(name, options)) {
          type = 3;
        }
        if (type === 1) {
          stack.push(allocTag(pool, name, start, end));
        } else if (type === 3) {
          if (start < pos && pos < end) {
            result = {
              name,
              attributes: getAttributes(source, start, end, name),
              open: [start, end]
            };
            return false;
          }
        } else {
          const tag = last(stack);
          if (tag && tag.name === name) {
            if (tag.start < pos && pos < end) {
              result = {
                name,
                attributes: getAttributes(source, tag.start, tag.end, name),
                open: [tag.start, tag.end],
                close: [start, end]
              };
              return false;
            } else if (stack.length) {
              releaseTag(pool, stack.pop());
            }
          }
        }
      }, options);
      stack.length = pool.length = 0;
      return result;
    }
    function balancedOutward(source, pos, opt2) {
      const pool = [];
      const stack = [];
      const options = createOptions(opt2);
      const result = [];
      scan(source, (name, type, start, end) => {
        if (type === 2) {
          const tag = last(stack);
          if (tag && tag.name === name) {
            if (tag.start < pos && pos < end) {
              result.push({
                name,
                open: [tag.start, tag.end],
                close: [start, end]
              });
            }
            releaseTag(pool, stack.pop());
          }
        } else if (type === 3 || isSelfClose(name, options)) {
          if (start < pos && pos < end) {
            result.push({ name, open: [start, end] });
          }
        } else {
          stack.push(allocTag(pool, name, start, end));
        }
      }, options);
      stack.length = pool.length = 0;
      return result;
    }
    function balancedInward(source, pos, opt2) {
      const pool = [];
      const stack = [];
      const options = createOptions(opt2);
      const result = [];
      const alloc = (name, start, end) => {
        if (pool.length) {
          const tag = pool.pop();
          tag.name = name;
          tag.ranges.push(start, end);
          return tag;
        }
        return { name, ranges: [start, end] };
      };
      const release = (tag) => {
        tag.ranges.length = 0;
        tag.firstChild = void 0;
        pool.push(tag);
      };
      scan(source, (name, type, start, end) => {
        if (type === 2) {
          if (!stack.length) {
            return;
          }
          let tag = last(stack);
          if (tag.name === name) {
            if (tag.ranges[0] <= pos && pos <= end) {
              result.push({
                name,
                open: tag.ranges.slice(0, 2),
                close: [start, end]
              });
              while (tag.firstChild) {
                const child = tag.firstChild;
                const res = {
                  name: child.name,
                  open: child.ranges.slice(0, 2)
                };
                if (child.ranges.length > 2) {
                  res.close = child.ranges.slice(2, 4);
                }
                result.push(res);
                release(tag);
                tag = child;
              }
              return false;
            } else {
              stack.pop();
              const parent = last(stack);
              if (parent && !parent.firstChild) {
                tag.ranges.push(start, end);
                parent.firstChild = tag;
              } else {
                release(tag);
              }
            }
          }
        } else if (type === 3 || isSelfClose(name, options)) {
          if (start < pos && pos < end) {
            result.push({ name, open: [start, end] });
            return false;
          }
          const parent = last(stack);
          if (parent && !parent.firstChild) {
            parent.firstChild = alloc(name, start, end);
          }
        } else {
          stack.push(alloc(name, start, end));
        }
      }, options);
      stack.length = pool.length = 0;
      return result;
    }
    function allocTag(pool, name, start, end) {
      if (pool.length) {
        const tag = pool.pop();
        tag.name = name;
        tag.start = start;
        tag.end = end;
        return tag;
      }
      return { name, start, end };
    }
    function releaseTag(pool, tag) {
      pool.push(tag);
    }
    function getAttributes(source, start, end, name) {
      const tokens = attributes(source.slice(start, end), name);
      tokens.forEach((attr) => {
        attr.nameStart += start;
        attr.nameEnd += start;
        if (attr.value != null) {
          attr.valueStart += start;
          attr.valueEnd += start;
        }
      });
      return tokens;
    }
    function isSelfClose(name, options) {
      return !options.xml && options.empty.includes(name);
    }
    function last(arr) {
      return arr.length ? arr[arr.length - 1] : null;
    }
    exports2.attributes = attributes;
    exports2.balancedInward = balancedInward;
    exports2.balancedOutward = balancedOutward;
    exports2.createOptions = createOptions;
    exports2.default = match;
    exports2.scan = scan;
  }
});

// node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/lib/bufferStream.js
var require_bufferStream = __commonJS({
  "node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/lib/bufferStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentStreamReader = void 0;
    var DocumentStreamReader = class _DocumentStreamReader {
      constructor(document, pos, limit) {
        this.document = document;
        this.start = this.pos = pos ? pos : 0;
        this._sof = limit ? limit[0] : 0;
        this._eof = limit ? limit[1] : document.getText().length;
      }
      /**
       * Returns true only if the stream is at the start of the file.
       */
      sof() {
        return this.pos <= this._sof;
      }
      /**
       * Returns true only if the stream is at the end of the file.
       */
      eof() {
        return this.pos >= this._eof;
      }
      /**
       * Creates a new stream instance which is limited to given range for given document
       */
      limit(start, end) {
        return new _DocumentStreamReader(this.document, start, [start, end]);
      }
      /**
       * Returns the next character code in the stream without advancing it.
       * Will return NaN at the end of the file.
       */
      peek() {
        if (this.eof()) {
          return NaN;
        }
        return this.document.getText().charCodeAt(this.pos);
      }
      /**
       * Returns the next character in the stream and advances it.
       * Also returns NaN when no more characters are available.
       */
      next() {
        if (this.eof()) {
          return NaN;
        }
        const code = this.document.getText().charCodeAt(this.pos);
        this.pos++;
        if (this.eof()) {
          this.pos = this._eof;
        }
        return code;
      }
      /**
       * Backs up the stream n characters. Backing it up further than the
       * start of the current token will cause things to break, so be careful.
       */
      backUp(n) {
        this.pos -= n;
        if (this.pos < 0) {
          this.pos = 0;
        }
        return this.peek();
      }
      /**
       * Get the string between the start of the current token and the
       * current stream position.
       */
      current() {
        return this.substring(this.start, this.pos);
      }
      /**
       * Returns contents for given range
       */
      substring(from, to) {
        return this.document.getText().substring(from, to);
      }
      /**
       * Creates error object with current stream state
       */
      error(message) {
        const err = new Error(`${message} at offset ${this.pos}`);
        return err;
      }
      /**
       * `match` can be a character code or a function that takes a character code
       * and returns a boolean. If the next character in the stream 'matches'
       * the given argument, it is consumed and returned.
       * Otherwise, `false` is returned.
       */
      eat(match) {
        const ch = this.peek();
        const ok = typeof match === "function" ? match(ch) : ch === match;
        if (ok) {
          this.next();
        }
        return ok;
      }
      /**
       * Repeatedly calls <code>eat</code> with the given argument, until it
       * fails. Returns <code>true</code> if any characters were eaten.
       */
      eatWhile(match) {
        const start = this.pos;
        while (!this.eof() && this.eat(match)) {
        }
        return this.pos !== start;
      }
    };
    exports2.DocumentStreamReader = DocumentStreamReader;
  }
});

// node_modules/.pnpm/jsonc-parser@2.3.1/node_modules/jsonc-parser/lib/umd/main.js
var require_main7 = __commonJS({
  "node_modules/.pnpm/jsonc-parser@2.3.1/node_modules/jsonc-parser/lib/umd/main.js"(exports2, module2) {
    "use strict";
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./impl/format", "./impl/edit", "./impl/scanner", "./impl/parser"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.applyEdits = exports3.modify = exports3.format = exports3.printParseErrorCode = exports3.stripComments = exports3.visit = exports3.getNodeValue = exports3.getNodePath = exports3.findNodeAtOffset = exports3.findNodeAtLocation = exports3.parseTree = exports3.parse = exports3.getLocation = exports3.createScanner = void 0;
      var formatter = require2("./impl/format");
      var edit = require2("./impl/edit");
      var scanner = require2("./impl/scanner");
      var parser = require2("./impl/parser");
      exports3.createScanner = scanner.createScanner;
      exports3.getLocation = parser.getLocation;
      exports3.parse = parser.parse;
      exports3.parseTree = parser.parseTree;
      exports3.findNodeAtLocation = parser.findNodeAtLocation;
      exports3.findNodeAtOffset = parser.findNodeAtOffset;
      exports3.getNodePath = parser.getNodePath;
      exports3.getNodeValue = parser.getNodeValue;
      exports3.visit = parser.visit;
      exports3.stripComments = parser.stripComments;
      function printParseErrorCode(code) {
        switch (code) {
          case 1:
            return "InvalidSymbol";
          case 2:
            return "InvalidNumberFormat";
          case 3:
            return "PropertyNameExpected";
          case 4:
            return "ValueExpected";
          case 5:
            return "ColonExpected";
          case 6:
            return "CommaExpected";
          case 7:
            return "CloseBraceExpected";
          case 8:
            return "CloseBracketExpected";
          case 9:
            return "EndOfFileExpected";
          case 10:
            return "InvalidCommentToken";
          case 11:
            return "UnexpectedEndOfComment";
          case 12:
            return "UnexpectedEndOfString";
          case 13:
            return "UnexpectedEndOfNumber";
          case 14:
            return "InvalidUnicode";
          case 15:
            return "InvalidEscapeCharacter";
          case 16:
            return "InvalidCharacter";
        }
        return "<unknown ParseErrorCode>";
      }
      exports3.printParseErrorCode = printParseErrorCode;
      function format(documentText, range, options) {
        return formatter.format(documentText, range, options);
      }
      exports3.format = format;
      function modify(text, path3, value, options) {
        return edit.setProperty(text, path3, value, options);
      }
      exports3.modify = modify;
      function applyEdits(text, edits) {
        for (var i = edits.length - 1; i >= 0; i--) {
          text = edit.applyEdit(text, edits[i]);
        }
        return text;
      }
      exports3.applyEdits = applyEdits;
    });
  }
});

// node_modules/.pnpm/@vscode+emmet-helper@2.11.0/node_modules/@vscode/emmet-helper/lib/cjs/data.js
var require_data = __commonJS({
  "node_modules/.pnpm/@vscode+emmet-helper@2.11.0/node_modules/@vscode/emmet-helper/lib/cjs/data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.htmlData = exports2.cssData = void 0;
    exports2.cssData = {
      "properties": ["additive-symbols", "align-content", "align-items", "justify-items", "justify-self", "justify-items", "align-self", "all", "alt", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-position-x", "background-position-y", "background-repeat", "background-size", "behavior", "block-size", "border", "border-block-end", "border-block-start", "border-block-end-color", "border-block-start-color", "border-block-end-style", "border-block-start-style", "border-block-end-width", "border-block-start-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-inline-end", "border-inline-start", "border-inline-end-color", "border-inline-start-color", "border-inline-end-style", "border-inline-start-style", "border-inline-end-width", "border-inline-start-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "color-interpolation-filters", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "columns", "column-span", "column-width", "contain", "content", "counter-increment", "counter-reset", "cursor", "direction", "display", "empty-cells", "enable-background", "fallback", "fill", "fill-opacity", "fill-rule", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flood-color", "flood-opacity", "font", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "glyph-orientation-horizontal", "glyph-orientation-vertical", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "height", "hyphens", "image-orientation", "image-rendering", "ime-mode", "inline-size", "isolation", "justify-content", "kerning", "left", "letter-spacing", "lighting-color", "line-break", "line-height", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "marker", "marker-end", "marker-mid", "marker-start", "mask-type", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "motion", "motion-offset", "motion-path", "motion-rotation", "-moz-animation", "-moz-animation-delay", "-moz-animation-direction", "-moz-animation-duration", "-moz-animation-iteration-count", "-moz-animation-name", "-moz-animation-play-state", "-moz-animation-timing-function", "-moz-appearance", "-moz-backface-visibility", "-moz-background-clip", "-moz-background-inline-policy", "-moz-background-origin", "-moz-border-bottom-colors", "-moz-border-image", "-moz-border-left-colors", "-moz-border-right-colors", "-moz-border-top-colors", "-moz-box-align", "-moz-box-direction", "-moz-box-flex", "-moz-box-flexgroup", "-moz-box-ordinal-group", "-moz-box-orient", "-moz-box-pack", "-moz-box-sizing", "-moz-column-count", "-moz-column-gap", "-moz-column-rule", "-moz-column-rule-color", "-moz-column-rule-style", "-moz-column-rule-width", "-moz-columns", "-moz-column-width", "-moz-font-feature-settings", "-moz-hyphens", "-moz-perspective", "-moz-perspective-origin", "-moz-text-align-last", "-moz-text-decoration-color", "-moz-text-decoration-line", "-moz-text-decoration-style", "-moz-text-size-adjust", "-moz-transform", "-moz-transform-origin", "-moz-transition", "-moz-transition-delay", "-moz-transition-duration", "-moz-transition-property", "-moz-transition-timing-function", "-moz-user-focus", "-moz-user-select", "-ms-accelerator", "-ms-behavior", "-ms-block-progression", "-ms-content-zoom-chaining", "-ms-content-zooming", "-ms-content-zoom-limit", "-ms-content-zoom-limit-max", "-ms-content-zoom-limit-min", "-ms-content-zoom-snap", "-ms-content-zoom-snap-points", "-ms-content-zoom-snap-type", "-ms-filter", "-ms-flex", "-ms-flex-align", "-ms-flex-direction", "-ms-flex-flow", "-ms-flex-item-align", "-ms-flex-line-pack", "-ms-flex-order", "-ms-flex-pack", "-ms-flex-wrap", "-ms-flow-from", "-ms-flow-into", "-ms-grid-column", "-ms-grid-column-align", "-ms-grid-columns", "-ms-grid-column-span", "-ms-grid-layer", "-ms-grid-row", "-ms-grid-row-align", "-ms-grid-rows", "-ms-grid-row-span", "-ms-high-contrast-adjust", "-ms-hyphenate-limit-chars", "-ms-hyphenate-limit-lines", "-ms-hyphenate-limit-zone", "-ms-hyphens", "-ms-ime-mode", "-ms-interpolation-mode", "-ms-layout-grid", "-ms-layout-grid-char", "-ms-layout-grid-line", "-ms-layout-grid-mode", "-ms-layout-grid-type", "-ms-line-break", "-ms-overflow-style", "-ms-perspective", "-ms-perspective-origin", "-ms-perspective-origin-x", "-ms-perspective-origin-y", "-ms-progress-appearance", "-ms-scrollbar-3dlight-color", "-ms-scrollbar-arrow-color", "-ms-scrollbar-base-color", "-ms-scrollbar-darkshadow-color", "-ms-scrollbar-face-color", "-ms-scrollbar-highlight-color", "-ms-scrollbar-shadow-color", "-ms-scrollbar-track-color", "-ms-scroll-chaining", "-ms-scroll-limit", "-ms-scroll-limit-x-max", "-ms-scroll-limit-x-min", "-ms-scroll-limit-y-max", "-ms-scroll-limit-y-min", "-ms-scroll-rails", "-ms-scroll-snap-points-x", "-ms-scroll-snap-points-y", "-ms-scroll-snap-type", "-ms-scroll-snap-x", "-ms-scroll-snap-y", "-ms-scroll-translation", "-ms-text-align-last", "-ms-text-autospace", "-ms-text-combine-horizontal", "-ms-text-justify", "-ms-text-kashida-space", "-ms-text-overflow", "-ms-text-size-adjust", "-ms-text-underline-position", "-ms-touch-action", "-ms-touch-select", "-ms-transform", "-ms-transform-origin", "-ms-transform-origin-x", "-ms-transform-origin-y", "-ms-transform-origin-z", "-ms-user-select", "-ms-word-break", "-ms-word-wrap", "-ms-wrap-flow", "-ms-wrap-margin", "-ms-wrap-through", "-ms-writing-mode", "-ms-zoom", "-ms-zoom-animation", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "negative", "-o-animation", "-o-animation-delay", "-o-animation-direction", "-o-animation-duration", "-o-animation-fill-mode", "-o-animation-iteration-count", "-o-animation-name", "-o-animation-play-state", "-o-animation-timing-function", "object-fit", "object-position", "-o-border-image", "-o-object-fit", "-o-object-position", "opacity", "order", "orphans", "-o-table-baseline", "-o-tab-size", "-o-text-overflow", "-o-transform", "-o-transform-origin", "-o-transition", "-o-transition-delay", "-o-transition-duration", "-o-transition-property", "-o-transition-timing-function", "offset-block-end", "offset-block-start", "offset-inline-end", "offset-inline-start", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-wrap", "overflow-x", "overflow-y", "pad", "padding", "padding-bottom", "padding-block-end", "padding-block-start", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "paint-order", "perspective", "perspective-origin", "pointer-events", "position", "prefix", "quotes", "range", "resize", "right", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "scrollbar-3dlight-color", "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-darkshadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-track-color", "scroll-behavior", "scroll-snap-coordinate", "scroll-snap-destination", "scroll-snap-points-x", "scroll-snap-points-y", "scroll-snap-type", "shape-image-threshold", "shape-margin", "shape-outside", "shape-rendering", "size", "src", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "suffix", "system", "symbols", "table-layout", "tab-size", "text-align", "text-align-last", "text-anchor", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-transform", "text-underline-position", "top", "touch-action", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "unicode-range", "user-select", "vertical-align", "visibility", "-webkit-animation", "-webkit-animation-delay", "-webkit-animation-direction", "-webkit-animation-duration", "-webkit-animation-fill-mode", "-webkit-animation-iteration-count", "-webkit-animation-name", "-webkit-animation-play-state", "-webkit-animation-timing-function", "-webkit-appearance", "-webkit-backdrop-filter", "-webkit-backface-visibility", "-webkit-background-clip", "-webkit-background-composite", "-webkit-background-origin", "-webkit-border-image", "-webkit-box-align", "-webkit-box-direction", "-webkit-box-flex", "-webkit-box-flex-group", "-webkit-box-ordinal-group", "-webkit-box-orient", "-webkit-box-pack", "-webkit-box-reflect", "-webkit-box-sizing", "-webkit-break-after", "-webkit-break-before", "-webkit-break-inside", "-webkit-column-break-after", "-webkit-column-break-before", "-webkit-column-break-inside", "-webkit-column-count", "-webkit-column-gap", "-webkit-column-rule", "-webkit-column-rule-color", "-webkit-column-rule-style", "-webkit-column-rule-width", "-webkit-columns", "-webkit-column-span", "-webkit-column-width", "-webkit-filter", "-webkit-flow-from", "-webkit-flow-into", "-webkit-font-feature-settings", "-webkit-hyphens", "-webkit-line-break", "-webkit-margin-bottom-collapse", "-webkit-margin-collapse", "-webkit-margin-start", "-webkit-margin-top-collapse", "-webkit-mask-clip", "-webkit-mask-image", "-webkit-mask-origin", "-webkit-mask-repeat", "-webkit-mask-size", "-webkit-nbsp-mode", "-webkit-overflow-scrolling", "-webkit-padding-start", "-webkit-perspective", "-webkit-perspective-origin", "-webkit-region-fragment", "-webkit-tap-highlight-color", "-webkit-text-fill-color", "-webkit-text-size-adjust", "-webkit-text-stroke", "-webkit-text-stroke-color", "-webkit-text-stroke-width", "-webkit-touch-callout", "-webkit-transform", "-webkit-transform-origin", "-webkit-transform-origin-x", "-webkit-transform-origin-y", "-webkit-transform-origin-z", "-webkit-transform-style", "-webkit-transition", "-webkit-transition-delay", "-webkit-transition-duration", "-webkit-transition-property", "-webkit-transition-timing-function", "-webkit-user-drag", "-webkit-user-modify", "-webkit-user-select", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index", "zoom"]
    };
    exports2.htmlData = {
      "tags": [
        "body",
        "head",
        "html",
        "address",
        "blockquote",
        "dd",
        "div",
        "section",
        "article",
        "aside",
        "header",
        "footer",
        "nav",
        "menu",
        "dl",
        "dt",
        "fieldset",
        "form",
        "frame",
        "frameset",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "iframe",
        "noframes",
        "object",
        "ol",
        "p",
        "ul",
        "applet",
        "center",
        "dir",
        "hr",
        "pre",
        "a",
        "abbr",
        "acronym",
        "area",
        "b",
        "base",
        "basefont",
        "bdo",
        "big",
        "br",
        "button",
        "caption",
        "cite",
        "code",
        "col",
        "colgroup",
        "del",
        "dfn",
        "em",
        "font",
        "i",
        "img",
        "input",
        "ins",
        "isindex",
        "kbd",
        "label",
        "legend",
        "li",
        "link",
        "map",
        "meta",
        "noscript",
        "optgroup",
        "option",
        "param",
        "q",
        "s",
        "samp",
        "script",
        "select",
        "small",
        "span",
        "strike",
        "strong",
        "style",
        "sub",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "title",
        "tr",
        "tt",
        "u",
        "var",
        "canvas",
        "main",
        "figure",
        "plaintext",
        "figcaption",
        "hgroup",
        "details",
        "summary",
        "audio",
        "bdi",
        "data",
        "datalist",
        "dialog",
        "embed",
        "mark",
        "math",
        "meter",
        "output",
        "picture",
        "portal",
        "progress",
        "rp",
        "rt",
        "ruby",
        "search",
        "slot",
        "source",
        "template",
        "time",
        "track",
        "video",
        "wbr"
      ]
    };
  }
});

// node_modules/.pnpm/@vscode+emmet-helper@2.11.0/node_modules/@vscode/emmet-helper/lib/cjs/fileService.js
var require_fileService = __commonJS({
  "node_modules/.pnpm/@vscode+emmet-helper@2.11.0/node_modules/@vscode/emmet-helper/lib/cjs/fileService.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileType = void 0;
    exports2.isAbsolutePath = isAbsolutePath;
    exports2.resolvePath = resolvePath;
    exports2.normalizePath = normalizePath;
    exports2.joinPath = joinPath;
    var FileType;
    (function(FileType2) {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
    })(FileType || (exports2.FileType = FileType = {}));
    var PathMatchRegex = new RegExp("^(/|//|\\\\\\\\|[A-Za-z]:(/|\\\\))");
    var Dot = ".".charCodeAt(0);
    function isAbsolutePath(path3) {
      return PathMatchRegex.test(path3);
    }
    function resolvePath(uri, path3) {
      if (isAbsolutePath(path3)) {
        return uri.with({ path: normalizePath(path3.split("/")) });
      }
      return joinPath(uri, path3);
    }
    function normalizePath(parts) {
      const newParts = [];
      for (const part of parts) {
        if (part.length === 0 || part.length === 1 && part.charCodeAt(0) === Dot) {
        } else if (part.length === 2 && part.charCodeAt(0) === Dot && part.charCodeAt(1) === Dot) {
          newParts.pop();
        } else {
          newParts.push(part);
        }
      }
      if (parts.length > 1 && parts[parts.length - 1].length === 0) {
        newParts.push("");
      }
      let res = newParts.join("/");
      if (parts[0].length === 0) {
        res = "/" + res;
      }
      return res;
    }
    function joinPath(uri, ...paths) {
      const parts = uri.path.split("/");
      for (const path3 of paths) {
        parts.push(...path3.split("/"));
      }
      return uri.with({ path: normalizePath(parts) });
    }
  }
});

// node_modules/.pnpm/emmet@2.4.11/node_modules/emmet/dist/emmet.cjs
var require_emmet = __commonJS({
  "node_modules/.pnpm/emmet@2.4.11/node_modules/emmet/dist/emmet.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isNumber$1(code2) {
      return code2 > 47 && code2 < 58;
    }
    function isAlpha$1(code2, from, to) {
      from = from || 65;
      to = to || 90;
      code2 &= ~32;
      return code2 >= from && code2 <= to;
    }
    function isAlphaNumericWord(code2) {
      return isNumber$1(code2) || isAlphaWord(code2);
    }
    function isAlphaWord(code2) {
      return code2 === 95 || isAlpha$1(code2);
    }
    function isUmlaut(code2) {
      return code2 === 196 || code2 == 214 || code2 === 220 || code2 === 228 || code2 === 246 || code2 === 252;
    }
    function isWhiteSpace$3(code2) {
      return code2 === 32 || code2 === 9 || code2 === 160;
    }
    function isSpace(code2) {
      return isWhiteSpace$3(code2) || code2 === 10 || code2 === 13;
    }
    function isQuote$2(code2) {
      return code2 === 39 || code2 === 34;
    }
    var Scanner = class _Scanner {
      constructor(str, start, end) {
        if (end == null && typeof str === "string") {
          end = str.length;
        }
        this.string = str;
        this.pos = this.start = start || 0;
        this.end = end || 0;
      }
      /**
       * Returns true only if the stream is at the end of the file.
       */
      eof() {
        return this.pos >= this.end;
      }
      /**
       * Creates a new stream instance which is limited to given `start` and `end`
       * range. E.g. its `eof()` method will look at `end` property, not actual
       * stream end
       */
      limit(start, end) {
        return new _Scanner(this.string, start, end);
      }
      /**
       * Returns the next character code in the stream without advancing it.
       * Will return NaN at the end of the file.
       */
      peek() {
        return this.string.charCodeAt(this.pos);
      }
      /**
       * Returns the next character in the stream and advances it.
       * Also returns <code>undefined</code> when no more characters are available.
       */
      next() {
        if (this.pos < this.string.length) {
          return this.string.charCodeAt(this.pos++);
        }
      }
      /**
       * `match` can be a character code or a function that takes a character code
       * and returns a boolean. If the next character in the stream 'matches'
       * the given argument, it is consumed and returned.
       * Otherwise, `false` is returned.
       */
      eat(match) {
        const ch = this.peek();
        const ok = typeof match === "function" ? match(ch) : ch === match;
        if (ok) {
          this.next();
        }
        return ok;
      }
      /**
       * Repeatedly calls <code>eat</code> with the given argument, until it
       * fails. Returns <code>true</code> if any characters were eaten.
       */
      eatWhile(match) {
        const start = this.pos;
        while (!this.eof() && this.eat(match)) {
        }
        return this.pos !== start;
      }
      /**
       * Backs up the stream n characters. Backing it up further than the
       * start of the current token will cause things to break, so be careful.
       */
      backUp(n) {
        this.pos -= n || 1;
      }
      /**
       * Get the string between the start of the current token and the
       * current stream position.
       */
      current() {
        return this.substring(this.start, this.pos);
      }
      /**
       * Returns substring for given range
       */
      substring(start, end) {
        return this.string.slice(start, end);
      }
      /**
       * Creates error object with current stream state
       */
      error(message, pos = this.pos) {
        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);
      }
    };
    var ScannerError = class extends Error {
      constructor(message, pos, str) {
        super(message);
        this.pos = pos;
        this.string = str;
      }
    };
    function tokenScanner$1(tokens) {
      return {
        tokens,
        start: 0,
        pos: 0,
        size: tokens.length
      };
    }
    function peek$3(scanner) {
      return scanner.tokens[scanner.pos];
    }
    function next(scanner) {
      return scanner.tokens[scanner.pos++];
    }
    function slice(scanner, from = scanner.start, to = scanner.pos) {
      return scanner.tokens.slice(from, to);
    }
    function readable$1(scanner) {
      return scanner.pos < scanner.size;
    }
    function consume$2(scanner, test) {
      const token = peek$3(scanner);
      if (token && test(token)) {
        scanner.pos++;
        return true;
      }
      return false;
    }
    function error$1(scanner, message, token = peek$3(scanner)) {
      if (token && token.start != null) {
        message += ` at ${token.start}`;
      }
      const err = new Error(message);
      err["pos"] = token && token.start;
      return err;
    }
    function abbreviation(abbr, options = {}) {
      const scanner = tokenScanner$1(abbr);
      const result = statements(scanner, options);
      if (readable$1(scanner)) {
        throw error$1(scanner, "Unexpected character");
      }
      return result;
    }
    function statements(scanner, options) {
      const result = {
        type: "TokenGroup",
        elements: []
      };
      let ctx = result;
      let node;
      const stack = [];
      while (readable$1(scanner)) {
        if (node = element$2(scanner, options) || group(scanner, options)) {
          ctx.elements.push(node);
          if (consume$2(scanner, isChildOperator)) {
            stack.push(ctx);
            ctx = node;
          } else if (consume$2(scanner, isSiblingOperator$1)) {
            continue;
          } else if (consume$2(scanner, isClimbOperator)) {
            do {
              if (stack.length) {
                ctx = stack.pop();
              }
            } while (consume$2(scanner, isClimbOperator));
          }
        } else {
          break;
        }
      }
      return result;
    }
    function group(scanner, options) {
      if (consume$2(scanner, isGroupStart)) {
        const result = statements(scanner, options);
        const token = next(scanner);
        if (isBracket$2(token, "group", false)) {
          result.repeat = repeater$1(scanner);
        }
        return result;
      }
    }
    function element$2(scanner, options) {
      let attr;
      const elem = {
        type: "TokenElement",
        name: void 0,
        attributes: void 0,
        value: void 0,
        repeat: void 0,
        selfClose: false,
        elements: []
      };
      if (elementName(scanner, options)) {
        elem.name = slice(scanner);
      }
      while (readable$1(scanner)) {
        scanner.start = scanner.pos;
        if (!elem.repeat && !isEmpty(elem) && consume$2(scanner, isRepeater)) {
          elem.repeat = scanner.tokens[scanner.pos - 1];
        } else if (!elem.value && text(scanner)) {
          elem.value = getText(scanner);
        } else if (attr = shortAttribute(scanner, "id", options) || shortAttribute(scanner, "class", options) || attributeSet(scanner)) {
          if (!elem.attributes) {
            elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];
          } else {
            elem.attributes = elem.attributes.concat(attr);
          }
        } else {
          if (!isEmpty(elem) && consume$2(scanner, isCloseOperator)) {
            elem.selfClose = true;
            if (!elem.repeat && consume$2(scanner, isRepeater)) {
              elem.repeat = scanner.tokens[scanner.pos - 1];
            }
          }
          break;
        }
      }
      return !isEmpty(elem) ? elem : void 0;
    }
    function attributeSet(scanner) {
      if (consume$2(scanner, isAttributeSetStart)) {
        const attributes = [];
        let attr;
        while (readable$1(scanner)) {
          if (attr = attribute(scanner)) {
            attributes.push(attr);
          } else if (consume$2(scanner, isAttributeSetEnd)) {
            break;
          } else if (!consume$2(scanner, isWhiteSpace$2)) {
            throw error$1(scanner, `Unexpected "${peek$3(scanner).type}" token`);
          }
        }
        return attributes;
      }
    }
    function shortAttribute(scanner, type, options) {
      if (isOperator$1(peek$3(scanner), type)) {
        scanner.pos++;
        let count = 1;
        while (isOperator$1(peek$3(scanner), type)) {
          scanner.pos++;
          count++;
        }
        const attr = {
          name: [createLiteral$1(type)]
        };
        if (count > 1) {
          attr.multiple = true;
        }
        if (options.jsx && text(scanner)) {
          attr.value = getText(scanner);
          attr.expression = true;
        } else {
          attr.value = literal$1$1(scanner) ? slice(scanner) : void 0;
        }
        return attr;
      }
    }
    function attribute(scanner) {
      if (quoted(scanner)) {
        return {
          value: slice(scanner)
        };
      }
      if (literal$1$1(scanner, true)) {
        const name = slice(scanner);
        let value;
        if (consume$2(scanner, isEquals)) {
          if (quoted(scanner) || literal$1$1(scanner, true)) {
            value = slice(scanner);
          }
        }
        return { name, value };
      }
    }
    function repeater$1(scanner) {
      return isRepeater(peek$3(scanner)) ? scanner.tokens[scanner.pos++] : void 0;
    }
    function quoted(scanner) {
      const start = scanner.pos;
      const quote2 = peek$3(scanner);
      if (isQuote$1(quote2)) {
        scanner.pos++;
        while (readable$1(scanner)) {
          if (isQuote$1(next(scanner), quote2.single)) {
            scanner.start = start;
            return true;
          }
        }
        throw error$1(scanner, "Unclosed quote", quote2);
      }
      return false;
    }
    function literal$1$1(scanner, allowBrackets) {
      const start = scanner.pos;
      const brackets = {
        attribute: 0,
        expression: 0,
        group: 0
      };
      while (readable$1(scanner)) {
        const token = peek$3(scanner);
        if (brackets.expression) {
          if (isBracket$2(token, "expression")) {
            brackets[token.context] += token.open ? 1 : -1;
          }
        } else if (isQuote$1(token) || isOperator$1(token) || isWhiteSpace$2(token) || isRepeater(token)) {
          break;
        } else if (isBracket$2(token)) {
          if (!allowBrackets) {
            break;
          }
          if (token.open) {
            brackets[token.context]++;
          } else if (!brackets[token.context]) {
            break;
          } else {
            brackets[token.context]--;
          }
        }
        scanner.pos++;
      }
      if (start !== scanner.pos) {
        scanner.start = start;
        return true;
      }
      return false;
    }
    function elementName(scanner, options) {
      const start = scanner.pos;
      if (options.jsx && consume$2(scanner, isCapitalizedLiteral)) {
        while (readable$1(scanner)) {
          const { pos } = scanner;
          if (!consume$2(scanner, isClassNameOperator) || !consume$2(scanner, isCapitalizedLiteral)) {
            scanner.pos = pos;
            break;
          }
        }
      }
      while (readable$1(scanner) && consume$2(scanner, isElementName$1)) {
      }
      if (scanner.pos !== start) {
        scanner.start = start;
        return true;
      }
      return false;
    }
    function text(scanner) {
      const start = scanner.pos;
      if (consume$2(scanner, isTextStart)) {
        let brackets = 0;
        while (readable$1(scanner)) {
          const token = next(scanner);
          if (isBracket$2(token, "expression")) {
            if (token.open) {
              brackets++;
            } else if (!brackets) {
              break;
            } else {
              brackets--;
            }
          }
        }
        scanner.start = start;
        return true;
      }
      return false;
    }
    function getText(scanner) {
      let from = scanner.start;
      let to = scanner.pos;
      if (isBracket$2(scanner.tokens[from], "expression", true)) {
        from++;
      }
      if (isBracket$2(scanner.tokens[to - 1], "expression", false)) {
        to--;
      }
      return slice(scanner, from, to);
    }
    function isBracket$2(token, context, isOpen) {
      return Boolean(token && token.type === "Bracket" && (!context || token.context === context) && (isOpen == null || token.open === isOpen));
    }
    function isOperator$1(token, type) {
      return Boolean(token && token.type === "Operator" && (!type || token.operator === type));
    }
    function isQuote$1(token, isSingle) {
      return Boolean(token && token.type === "Quote" && (isSingle == null || token.single === isSingle));
    }
    function isWhiteSpace$2(token) {
      return Boolean(token && token.type === "WhiteSpace");
    }
    function isEquals(token) {
      return isOperator$1(token, "equal");
    }
    function isRepeater(token) {
      return Boolean(token && token.type === "Repeater");
    }
    function isLiteral$2(token) {
      return token.type === "Literal";
    }
    function isCapitalizedLiteral(token) {
      if (isLiteral$2(token)) {
        const ch = token.value.charCodeAt(0);
        return ch >= 65 && ch <= 90;
      }
      return false;
    }
    function isElementName$1(token) {
      return token.type === "Literal" || token.type === "RepeaterNumber" || token.type === "RepeaterPlaceholder";
    }
    function isClassNameOperator(token) {
      return isOperator$1(token, "class");
    }
    function isAttributeSetStart(token) {
      return isBracket$2(token, "attribute", true);
    }
    function isAttributeSetEnd(token) {
      return isBracket$2(token, "attribute", false);
    }
    function isTextStart(token) {
      return isBracket$2(token, "expression", true);
    }
    function isGroupStart(token) {
      return isBracket$2(token, "group", true);
    }
    function createLiteral$1(value) {
      return { type: "Literal", value };
    }
    function isEmpty(elem) {
      return !elem.name && !elem.value && !elem.attributes;
    }
    function isChildOperator(token) {
      return isOperator$1(token, "child");
    }
    function isSiblingOperator$1(token) {
      return isOperator$1(token, "sibling");
    }
    function isClimbOperator(token) {
      return isOperator$1(token, "climb");
    }
    function isCloseOperator(token) {
      return isOperator$1(token, "close");
    }
    var Chars$3;
    (function(Chars2) {
      Chars2[Chars2["CurlyBracketOpen"] = 123] = "CurlyBracketOpen";
      Chars2[Chars2["CurlyBracketClose"] = 125] = "CurlyBracketClose";
      Chars2[Chars2["Escape"] = 92] = "Escape";
      Chars2[Chars2["Equals"] = 61] = "Equals";
      Chars2[Chars2["SquareBracketOpen"] = 91] = "SquareBracketOpen";
      Chars2[Chars2["SquareBracketClose"] = 93] = "SquareBracketClose";
      Chars2[Chars2["Asterisk"] = 42] = "Asterisk";
      Chars2[Chars2["Hash"] = 35] = "Hash";
      Chars2[Chars2["Dollar"] = 36] = "Dollar";
      Chars2[Chars2["Dash"] = 45] = "Dash";
      Chars2[Chars2["Dot"] = 46] = "Dot";
      Chars2[Chars2["Slash"] = 47] = "Slash";
      Chars2[Chars2["Colon"] = 58] = "Colon";
      Chars2[Chars2["Excl"] = 33] = "Excl";
      Chars2[Chars2["At"] = 64] = "At";
      Chars2[Chars2["Underscore"] = 95] = "Underscore";
      Chars2[Chars2["RoundBracketOpen"] = 40] = "RoundBracketOpen";
      Chars2[Chars2["RoundBracketClose"] = 41] = "RoundBracketClose";
      Chars2[Chars2["Sibling"] = 43] = "Sibling";
      Chars2[Chars2["Child"] = 62] = "Child";
      Chars2[Chars2["Climb"] = 94] = "Climb";
      Chars2[Chars2["SingleQuote"] = 39] = "SingleQuote";
      Chars2[Chars2["DoubleQuote"] = 34] = "DoubleQuote";
    })(Chars$3 || (Chars$3 = {}));
    function escaped(scanner) {
      if (scanner.eat(Chars$3.Escape)) {
        scanner.start = scanner.pos;
        if (!scanner.eof()) {
          scanner.pos++;
        }
        return true;
      }
      return false;
    }
    function tokenize$1(source) {
      const scanner = new Scanner(source);
      const result = [];
      const ctx = {
        group: 0,
        attribute: 0,
        expression: 0,
        quote: 0
      };
      let ch = 0;
      let token;
      while (!scanner.eof()) {
        ch = scanner.peek();
        token = getToken$1(scanner, ctx);
        if (token) {
          result.push(token);
          if (token.type === "Quote") {
            ctx.quote = ch === ctx.quote ? 0 : ch;
          } else if (token.type === "Bracket") {
            ctx[token.context] += token.open ? 1 : -1;
          }
        } else {
          throw scanner.error("Unexpected character");
        }
      }
      return result;
    }
    function getToken$1(scanner, ctx) {
      return field$2(scanner, ctx) || repeaterPlaceholder(scanner) || repeaterNumber(scanner) || repeater(scanner) || whiteSpace$1(scanner) || literal$2(scanner, ctx) || operator$1(scanner) || quote(scanner) || bracket$1(scanner);
    }
    function literal$2(scanner, ctx) {
      const start = scanner.pos;
      const expressionStart2 = ctx.expression;
      let value = "";
      while (!scanner.eof()) {
        if (escaped(scanner)) {
          value += scanner.current();
          continue;
        }
        const ch = scanner.peek();
        if (ch === Chars$3.Slash && !ctx.quote && !ctx.expression && !ctx.attribute) {
          const prev = scanner.string.charCodeAt(scanner.pos - 1);
          const next2 = scanner.string.charCodeAt(scanner.pos + 1);
          if (isNumber$1(prev) && isNumber$1(next2)) {
            value += scanner.string[scanner.pos++];
            continue;
          }
        }
        if (ch === ctx.quote || ch === Chars$3.Dollar || isAllowedOperator(ch, ctx)) {
          break;
        }
        if (expressionStart2) {
          if (ch === Chars$3.CurlyBracketOpen) {
            ctx.expression++;
          } else if (ch === Chars$3.CurlyBracketClose) {
            if (ctx.expression > expressionStart2) {
              ctx.expression--;
            } else {
              break;
            }
          }
        } else if (!ctx.quote) {
          if (!ctx.attribute && !isElementName(ch)) {
            break;
          }
          if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$2(ch) || bracketType(ch)) {
            break;
          }
        }
        value += scanner.string[scanner.pos++];
      }
      if (start !== scanner.pos) {
        scanner.start = start;
        return {
          type: "Literal",
          value,
          start,
          end: scanner.pos
        };
      }
    }
    function whiteSpace$1(scanner) {
      const start = scanner.pos;
      if (scanner.eatWhile(isSpace)) {
        return {
          type: "WhiteSpace",
          start,
          end: scanner.pos,
          value: scanner.substring(start, scanner.pos)
        };
      }
    }
    function quote(scanner) {
      const ch = scanner.peek();
      if (isQuote$2(ch)) {
        return {
          type: "Quote",
          single: ch === Chars$3.SingleQuote,
          start: scanner.pos++,
          end: scanner.pos
        };
      }
    }
    function bracket$1(scanner) {
      const ch = scanner.peek();
      const context = bracketType(ch);
      if (context) {
        return {
          type: "Bracket",
          open: isOpenBracket$2(ch),
          context,
          start: scanner.pos++,
          end: scanner.pos
        };
      }
    }
    function operator$1(scanner) {
      const op = operatorType$1(scanner.peek());
      if (op) {
        return {
          type: "Operator",
          operator: op,
          start: scanner.pos++,
          end: scanner.pos
        };
      }
    }
    function repeater(scanner) {
      const start = scanner.pos;
      if (scanner.eat(Chars$3.Asterisk)) {
        scanner.start = scanner.pos;
        let count = 1;
        let implicit = false;
        if (scanner.eatWhile(isNumber$1)) {
          count = Number(scanner.current());
        } else {
          implicit = true;
        }
        return {
          type: "Repeater",
          count,
          value: 0,
          implicit,
          start,
          end: scanner.pos
        };
      }
    }
    function repeaterPlaceholder(scanner) {
      const start = scanner.pos;
      if (scanner.eat(Chars$3.Dollar) && scanner.eat(Chars$3.Hash)) {
        return {
          type: "RepeaterPlaceholder",
          value: void 0,
          start,
          end: scanner.pos
        };
      }
      scanner.pos = start;
    }
    function repeaterNumber(scanner) {
      const start = scanner.pos;
      if (scanner.eatWhile(Chars$3.Dollar)) {
        const size = scanner.pos - start;
        let reverse = false;
        let base = 1;
        let parent = 0;
        if (scanner.eat(Chars$3.At)) {
          while (scanner.eat(Chars$3.Climb)) {
            parent++;
          }
          reverse = scanner.eat(Chars$3.Dash);
          scanner.start = scanner.pos;
          if (scanner.eatWhile(isNumber$1)) {
            base = Number(scanner.current());
          }
        }
        scanner.start = start;
        return {
          type: "RepeaterNumber",
          size,
          reverse,
          base,
          parent,
          start,
          end: scanner.pos
        };
      }
    }
    function field$2(scanner, ctx) {
      const start = scanner.pos;
      if ((ctx.expression || ctx.attribute) && scanner.eat(Chars$3.Dollar) && scanner.eat(Chars$3.CurlyBracketOpen)) {
        scanner.start = scanner.pos;
        let index;
        let name = "";
        if (scanner.eatWhile(isNumber$1)) {
          index = Number(scanner.current());
          name = scanner.eat(Chars$3.Colon) ? consumePlaceholder$2(scanner) : "";
        } else if (isAlpha$1(scanner.peek())) {
          name = consumePlaceholder$2(scanner);
        }
        if (scanner.eat(Chars$3.CurlyBracketClose)) {
          return {
            type: "Field",
            index,
            name,
            start,
            end: scanner.pos
          };
        }
        throw scanner.error("Expecting }");
      }
      scanner.pos = start;
    }
    function consumePlaceholder$2(stream) {
      const stack = [];
      stream.start = stream.pos;
      while (!stream.eof()) {
        if (stream.eat(Chars$3.CurlyBracketOpen)) {
          stack.push(stream.pos);
        } else if (stream.eat(Chars$3.CurlyBracketClose)) {
          if (!stack.length) {
            stream.pos--;
            break;
          }
          stack.pop();
        } else {
          stream.pos++;
        }
      }
      if (stack.length) {
        stream.pos = stack.pop();
        throw stream.error(`Expecting }`);
      }
      return stream.current();
    }
    function isAllowedOperator(ch, ctx) {
      const op = operatorType$1(ch);
      if (!op || ctx.quote || ctx.expression) {
        return false;
      }
      return !ctx.attribute || op === "equal";
    }
    function isAllowedSpace(ch, ctx) {
      return isSpace(ch) && !ctx.expression;
    }
    function isAllowedRepeater(ch, ctx) {
      return ch === Chars$3.Asterisk && !ctx.attribute && !ctx.expression;
    }
    function bracketType(ch) {
      if (ch === Chars$3.RoundBracketOpen || ch === Chars$3.RoundBracketClose) {
        return "group";
      }
      if (ch === Chars$3.SquareBracketOpen || ch === Chars$3.SquareBracketClose) {
        return "attribute";
      }
      if (ch === Chars$3.CurlyBracketOpen || ch === Chars$3.CurlyBracketClose) {
        return "expression";
      }
    }
    function operatorType$1(ch) {
      return ch === Chars$3.Child && "child" || ch === Chars$3.Sibling && "sibling" || ch === Chars$3.Climb && "climb" || ch === Chars$3.Dot && "class" || ch === Chars$3.Hash && "id" || ch === Chars$3.Slash && "close" || ch === Chars$3.Equals && "equal" || void 0;
    }
    function isOpenBracket$2(ch) {
      return ch === Chars$3.CurlyBracketOpen || ch === Chars$3.SquareBracketOpen || ch === Chars$3.RoundBracketOpen;
    }
    function isElementName(ch) {
      return isAlphaNumericWord(ch) || isUmlaut(ch) || ch === Chars$3.Dash || ch === Chars$3.Colon || ch === Chars$3.Excl;
    }
    var operators = {
      child: ">",
      class: ".",
      climb: "^",
      id: "#",
      equal: "=",
      close: "/",
      sibling: "+"
    };
    var tokenVisitor = {
      Literal(token) {
        return token.value;
      },
      Quote(token) {
        return token.single ? "'" : '"';
      },
      Bracket(token) {
        if (token.context === "attribute") {
          return token.open ? "[" : "]";
        } else if (token.context === "expression") {
          return token.open ? "{" : "}";
        } else {
          return token.open ? "(" : "}";
        }
      },
      Operator(token) {
        return operators[token.operator];
      },
      Field(token, state) {
        if (token.index != null) {
          return token.name ? `\${${token.index}:${token.name}}` : `\${${token.index}`;
        } else if (token.name) {
          return state.getVariable(token.name);
        }
        return "";
      },
      RepeaterPlaceholder(token, state) {
        let repeater2;
        for (let i = state.repeaters.length - 1; i >= 0; i--) {
          if (state.repeaters[i].implicit) {
            repeater2 = state.repeaters[i];
            break;
          }
        }
        state.inserted = true;
        return state.getText(repeater2 && repeater2.value);
      },
      RepeaterNumber(token, state) {
        let value = 1;
        const lastIx = state.repeaters.length - 1;
        const repeater2 = state.repeaters[lastIx];
        if (repeater2) {
          value = token.reverse ? token.base + repeater2.count - repeater2.value - 1 : token.base + repeater2.value;
          if (token.parent) {
            const parentIx = Math.max(0, lastIx - token.parent);
            if (parentIx !== lastIx) {
              const parentRepeater = state.repeaters[parentIx];
              value += repeater2.count * parentRepeater.value;
            }
          }
        }
        let result = String(value);
        while (result.length < token.size) {
          result = "0" + result;
        }
        return result;
      },
      WhiteSpace(token) {
        return token.value;
      }
    };
    function stringify$1(token, state) {
      if (!tokenVisitor[token.type]) {
        throw new Error(`Unknown token ${token.type}`);
      }
      return tokenVisitor[token.type](token, state);
    }
    var urlRegex = /^((https?:|ftp:|file:)?\/\/|(www|ftp)\.)[^ ]*$/;
    var emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,5}$/;
    function convert(abbr, options = {}) {
      let textInserted = false;
      let cleanText;
      if (options.text) {
        if (Array.isArray(options.text)) {
          cleanText = options.text.filter((s) => s.trim());
        } else {
          cleanText = options.text;
        }
      }
      const result = {
        type: "Abbreviation",
        children: convertGroup(abbr, {
          inserted: false,
          repeaters: [],
          text: options.text,
          cleanText,
          repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,
          getText(pos) {
            var _a;
            textInserted = true;
            let value;
            if (Array.isArray(options.text)) {
              if (pos !== void 0 && pos >= 0 && pos < cleanText.length) {
                return cleanText[pos];
              }
              value = pos !== void 0 ? options.text[pos] : options.text.join("\n");
            } else {
              value = (_a = options.text) !== null && _a !== void 0 ? _a : "";
            }
            return value;
          },
          getVariable(name) {
            const varValue = options.variables && options.variables[name];
            return varValue != null ? varValue : name;
          }
        })
      };
      if (options.text != null && !textInserted) {
        const deepest = deepestNode(last$1(result.children));
        if (deepest) {
          const text2 = Array.isArray(options.text) ? options.text.join("\n") : options.text;
          insertText(deepest, text2);
          if (deepest.name === "a" && options.href) {
            insertHref(deepest, text2);
          }
        }
      }
      return result;
    }
    function convertStatement(node, state) {
      let result = [];
      if (node.repeat) {
        const original = node.repeat;
        const repeat = Object.assign({}, original);
        repeat.count = repeat.implicit && Array.isArray(state.text) ? state.cleanText.length : repeat.count || 1;
        let items;
        state.repeaters.push(repeat);
        for (let i = 0; i < repeat.count; i++) {
          repeat.value = i;
          node.repeat = repeat;
          items = isGroup(node) ? convertGroup(node, state) : convertElement(node, state);
          if (repeat.implicit && !state.inserted) {
            const target = last$1(items);
            const deepest = target && deepestNode(target);
            if (deepest) {
              insertText(deepest, state.getText(repeat.value));
            }
          }
          result = result.concat(items);
          if (--state.repeatGuard <= 0) {
            break;
          }
        }
        state.repeaters.pop();
        node.repeat = original;
        if (repeat.implicit) {
          state.inserted = true;
        }
      } else {
        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));
      }
      return result;
    }
    function convertElement(node, state) {
      let children = [];
      const elem = {
        type: "AbbreviationNode",
        name: node.name && stringifyName(node.name, state),
        value: node.value && stringifyValue$1(node.value, state),
        attributes: void 0,
        children,
        repeat: node.repeat && Object.assign({}, node.repeat),
        selfClosing: node.selfClose
      };
      let result = [elem];
      for (const child of node.elements) {
        children = children.concat(convertStatement(child, state));
      }
      if (node.attributes) {
        elem.attributes = [];
        for (const attr of node.attributes) {
          elem.attributes.push(convertAttribute(attr, state));
        }
      }
      if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField$1)) {
        result = result.concat(children);
      } else {
        elem.children = children;
      }
      return result;
    }
    function convertGroup(node, state) {
      let result = [];
      for (const child of node.elements) {
        result = result.concat(convertStatement(child, state));
      }
      if (node.repeat) {
        result = attachRepeater(result, node.repeat);
      }
      return result;
    }
    function convertAttribute(node, state) {
      let implied = false;
      let isBoolean = false;
      let valueType = node.expression ? "expression" : "raw";
      let value;
      const name = node.name && stringifyName(node.name, state);
      if (name && name[0] === "!") {
        implied = true;
      }
      if (name && name[name.length - 1] === ".") {
        isBoolean = true;
      }
      if (node.value) {
        const tokens = node.value.slice();
        if (isQuote$1(tokens[0])) {
          const quote2 = tokens.shift();
          if (tokens.length && last$1(tokens).type === quote2.type) {
            tokens.pop();
          }
          valueType = quote2.single ? "singleQuote" : "doubleQuote";
        } else if (isBracket$2(tokens[0], "expression", true)) {
          valueType = "expression";
          tokens.shift();
          if (isBracket$2(last$1(tokens), "expression", false)) {
            tokens.pop();
          }
        }
        value = stringifyValue$1(tokens, state);
      }
      return {
        name: isBoolean || implied ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0) : name,
        value,
        boolean: isBoolean,
        implied,
        valueType,
        multiple: node.multiple
      };
    }
    function stringifyName(tokens, state) {
      let str = "";
      for (let i = 0; i < tokens.length; i++) {
        str += stringify$1(tokens[i], state);
      }
      return str;
    }
    function stringifyValue$1(tokens, state) {
      const result = [];
      let str = "";
      for (let i = 0, token; i < tokens.length; i++) {
        token = tokens[i];
        if (isField$1(token)) {
          if (str) {
            result.push(str);
            str = "";
          }
          result.push(token);
        } else {
          str += stringify$1(token, state);
        }
      }
      if (str) {
        result.push(str);
      }
      return result;
    }
    function isGroup(node) {
      return node.type === "TokenGroup";
    }
    function isField$1(token) {
      return typeof token === "object" && token.type === "Field" && token.index != null;
    }
    function last$1(arr) {
      return arr[arr.length - 1];
    }
    function deepestNode(node) {
      return node.children.length ? deepestNode(last$1(node.children)) : node;
    }
    function insertText(node, text2) {
      if (node.value) {
        const lastToken = last$1(node.value);
        if (typeof lastToken === "string") {
          node.value[node.value.length - 1] += text2;
        } else {
          node.value.push(text2);
        }
      } else {
        node.value = [text2];
      }
    }
    function insertHref(node, text2) {
      var _a;
      let href = "";
      if (urlRegex.test(text2)) {
        href = text2;
        if (!/\w+:/.test(href) && !href.startsWith("//")) {
          href = `http://${href}`;
        }
      } else if (emailRegex.test(text2)) {
        href = `mailto:${text2}`;
      }
      const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find((attr) => attr.name === "href");
      if (!hrefAttribute) {
        if (!node.attributes) {
          node.attributes = [];
        }
        node.attributes.push({ name: "href", value: [href], valueType: "doubleQuote" });
      } else if (!hrefAttribute.value) {
        hrefAttribute.value = [href];
      }
    }
    function attachRepeater(items, repeater2) {
      for (const item of items) {
        if (!item.repeat) {
          item.repeat = Object.assign({}, repeater2);
        }
      }
      return items;
    }
    function parseAbbreviation(abbr, options) {
      try {
        const tokens = typeof abbr === "string" ? tokenize$1(abbr) : abbr;
        return convert(abbreviation(tokens, options), options);
      } catch (err) {
        if (err instanceof ScannerError && typeof abbr === "string") {
          err.message += `
${abbr}
${"-".repeat(err.pos)}^`;
        }
        throw err;
      }
    }
    var OperatorType;
    (function(OperatorType2) {
      OperatorType2["Sibling"] = "+";
      OperatorType2["Important"] = "!";
      OperatorType2["ArgumentDelimiter"] = ",";
      OperatorType2["ValueDelimiter"] = "-";
      OperatorType2["PropertyDelimiter"] = ":";
    })(OperatorType || (OperatorType = {}));
    var Chars$2;
    (function(Chars2) {
      Chars2[Chars2["Hash"] = 35] = "Hash";
      Chars2[Chars2["Dollar"] = 36] = "Dollar";
      Chars2[Chars2["Dash"] = 45] = "Dash";
      Chars2[Chars2["Dot"] = 46] = "Dot";
      Chars2[Chars2["Colon"] = 58] = "Colon";
      Chars2[Chars2["Comma"] = 44] = "Comma";
      Chars2[Chars2["Excl"] = 33] = "Excl";
      Chars2[Chars2["At"] = 64] = "At";
      Chars2[Chars2["Percent"] = 37] = "Percent";
      Chars2[Chars2["Underscore"] = 95] = "Underscore";
      Chars2[Chars2["RoundBracketOpen"] = 40] = "RoundBracketOpen";
      Chars2[Chars2["RoundBracketClose"] = 41] = "RoundBracketClose";
      Chars2[Chars2["CurlyBracketOpen"] = 123] = "CurlyBracketOpen";
      Chars2[Chars2["CurlyBracketClose"] = 125] = "CurlyBracketClose";
      Chars2[Chars2["Sibling"] = 43] = "Sibling";
      Chars2[Chars2["SingleQuote"] = 39] = "SingleQuote";
      Chars2[Chars2["DoubleQuote"] = 34] = "DoubleQuote";
      Chars2[Chars2["Transparent"] = 116] = "Transparent";
      Chars2[Chars2["Slash"] = 47] = "Slash";
    })(Chars$2 || (Chars$2 = {}));
    function tokenize(abbr, isValue2) {
      let brackets = 0;
      let token;
      const scanner = new Scanner(abbr);
      const tokens = [];
      while (!scanner.eof()) {
        token = getToken(scanner, brackets === 0 && !isValue2);
        if (!token) {
          throw scanner.error("Unexpected character");
        }
        if (token.type === "Bracket") {
          if (!brackets && token.open) {
            mergeTokens(scanner, tokens);
          }
          brackets += token.open ? 1 : -1;
          if (brackets < 0) {
            throw scanner.error("Unexpected bracket", token.start);
          }
        }
        tokens.push(token);
        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {
          tokens.push(token);
        }
      }
      return tokens;
    }
    function getToken(scanner, short) {
      return field$1(scanner) || customProperty(scanner) || numberValue(scanner) || colorValue(scanner) || stringValue(scanner) || bracket(scanner) || operator(scanner) || whiteSpace(scanner) || literal$1(scanner, short);
    }
    function field$1(scanner) {
      const start = scanner.pos;
      if (scanner.eat(Chars$2.Dollar) && scanner.eat(Chars$2.CurlyBracketOpen)) {
        scanner.start = scanner.pos;
        let index;
        let name = "";
        if (scanner.eatWhile(isNumber$1)) {
          index = Number(scanner.current());
          name = scanner.eat(Chars$2.Colon) ? consumePlaceholder$1(scanner) : "";
        } else if (isAlpha$1(scanner.peek())) {
          name = consumePlaceholder$1(scanner);
        }
        if (scanner.eat(Chars$2.CurlyBracketClose)) {
          return {
            type: "Field",
            index,
            name,
            start,
            end: scanner.pos
          };
        }
        throw scanner.error("Expecting }");
      }
      scanner.pos = start;
    }
    function consumePlaceholder$1(stream) {
      const stack = [];
      stream.start = stream.pos;
      while (!stream.eof()) {
        if (stream.eat(Chars$2.CurlyBracketOpen)) {
          stack.push(stream.pos);
        } else if (stream.eat(Chars$2.CurlyBracketClose)) {
          if (!stack.length) {
            stream.pos--;
            break;
          }
          stack.pop();
        } else {
          stream.pos++;
        }
      }
      if (stack.length) {
        stream.pos = stack.pop();
        throw stream.error(`Expecting }`);
      }
      return stream.current();
    }
    function literal$1(scanner, short) {
      const start = scanner.pos;
      if (scanner.eat(isIdentPrefix)) {
        scanner.eatWhile(start ? isKeyword : isLiteral$1);
      } else if (scanner.eat(isAlphaWord)) {
        scanner.eatWhile(short ? isLiteral$1 : isKeyword);
      } else {
        scanner.eat(Chars$2.Dot);
        scanner.eatWhile(isLiteral$1);
      }
      if (start !== scanner.pos) {
        scanner.start = start;
        return createLiteral(scanner, scanner.start = start);
      }
    }
    function createLiteral(scanner, start = scanner.start, end = scanner.pos) {
      return {
        type: "Literal",
        value: scanner.substring(start, end),
        start,
        end
      };
    }
    function numberValue(scanner) {
      const start = scanner.pos;
      if (consumeNumber(scanner)) {
        scanner.start = start;
        const rawValue = scanner.current();
        scanner.start = scanner.pos;
        scanner.eat(Chars$2.Percent) || scanner.eatWhile(isAlphaWord);
        return {
          type: "NumberValue",
          value: Number(rawValue),
          rawValue,
          unit: scanner.current(),
          start,
          end: scanner.pos
        };
      }
    }
    function stringValue(scanner) {
      const ch = scanner.peek();
      const start = scanner.pos;
      let finished = false;
      if (isQuote$2(ch)) {
        scanner.pos++;
        while (!scanner.eof()) {
          if (scanner.eat(ch)) {
            finished = true;
            break;
          } else {
            scanner.pos++;
          }
        }
        scanner.start = start;
        return {
          type: "StringValue",
          value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),
          quote: ch === Chars$2.SingleQuote ? "single" : "double",
          start,
          end: scanner.pos
        };
      }
    }
    function colorValue(scanner) {
      const start = scanner.pos;
      if (scanner.eat(Chars$2.Hash)) {
        const valueStart = scanner.pos;
        let color2 = "";
        let alpha = "";
        if (scanner.eatWhile(isHex)) {
          color2 = scanner.substring(valueStart, scanner.pos);
          alpha = colorAlpha(scanner);
        } else if (scanner.eat(Chars$2.Transparent)) {
          color2 = "0";
          alpha = colorAlpha(scanner) || "0";
        } else {
          alpha = colorAlpha(scanner);
        }
        if (color2 || alpha || scanner.eof()) {
          const { r, g, b, a } = parseColor(color2, alpha);
          return {
            type: "ColorValue",
            r,
            g,
            b,
            a,
            raw: scanner.substring(start + 1, scanner.pos),
            start,
            end: scanner.pos
          };
        } else {
          return createLiteral(scanner, start);
        }
      }
      scanner.pos = start;
    }
    function colorAlpha(scanner) {
      const start = scanner.pos;
      if (scanner.eat(Chars$2.Dot)) {
        scanner.start = start;
        if (scanner.eatWhile(isNumber$1)) {
          return scanner.current();
        }
        return "1";
      }
      return "";
    }
    function whiteSpace(scanner) {
      const start = scanner.pos;
      if (scanner.eatWhile(isSpace)) {
        return {
          type: "WhiteSpace",
          start,
          end: scanner.pos
        };
      }
    }
    function customProperty(scanner) {
      const start = scanner.pos;
      if (scanner.eat(Chars$2.Dash) && scanner.eat(Chars$2.Dash)) {
        scanner.start = start;
        scanner.eatWhile(isKeyword);
        return {
          type: "CustomProperty",
          value: scanner.current(),
          start,
          end: scanner.pos
        };
      }
      scanner.pos = start;
    }
    function bracket(scanner) {
      const ch = scanner.peek();
      if (isBracket$1(ch)) {
        return {
          type: "Bracket",
          open: ch === Chars$2.RoundBracketOpen,
          start: scanner.pos++,
          end: scanner.pos
        };
      }
    }
    function operator(scanner) {
      const op = operatorType(scanner.peek());
      if (op) {
        return {
          type: "Operator",
          operator: op,
          start: scanner.pos++,
          end: scanner.pos
        };
      }
    }
    function consumeNumber(stream) {
      const start = stream.pos;
      stream.eat(Chars$2.Dash);
      const afterNegative = stream.pos;
      const hasDecimal = stream.eatWhile(isNumber$1);
      const prevPos = stream.pos;
      if (stream.eat(Chars$2.Dot)) {
        const hasFloat = stream.eatWhile(isNumber$1);
        if (!hasDecimal && !hasFloat) {
          stream.pos = prevPos;
        }
      }
      if (stream.pos === afterNegative) {
        stream.pos = start;
      }
      return stream.pos !== start;
    }
    function isIdentPrefix(code2) {
      return code2 === Chars$2.At || code2 === Chars$2.Dollar;
    }
    function operatorType(ch) {
      return ch === Chars$2.Sibling && OperatorType.Sibling || ch === Chars$2.Excl && OperatorType.Important || ch === Chars$2.Comma && OperatorType.ArgumentDelimiter || ch === Chars$2.Colon && OperatorType.PropertyDelimiter || ch === Chars$2.Dash && OperatorType.ValueDelimiter || void 0;
    }
    function isHex(code2) {
      return isNumber$1(code2) || isAlpha$1(code2, 65, 70);
    }
    function isKeyword(code2) {
      return isAlphaNumericWord(code2) || code2 === Chars$2.Dash;
    }
    function isBracket$1(code2) {
      return code2 === Chars$2.RoundBracketOpen || code2 === Chars$2.RoundBracketClose;
    }
    function isLiteral$1(code2) {
      return isAlphaWord(code2) || code2 === Chars$2.Percent || code2 === Chars$2.Slash;
    }
    function parseColor(value, alpha) {
      let r = "0";
      let g = "0";
      let b = "0";
      let a = Number(alpha != null && alpha !== "" ? alpha : 1);
      if (value === "t") {
        a = 0;
      } else {
        switch (value.length) {
          case 0:
            break;
          case 1:
            r = g = b = value + value;
            break;
          case 2:
            r = g = b = value;
            break;
          case 3:
            r = value[0] + value[0];
            g = value[1] + value[1];
            b = value[2] + value[2];
            break;
          default:
            value += value;
            r = value.slice(0, 2);
            g = value.slice(2, 4);
            b = value.slice(4, 6);
        }
      }
      return {
        r: parseInt(r, 16),
        g: parseInt(g, 16),
        b: parseInt(b, 16),
        a
      };
    }
    function shouldConsumeDashAfter(token) {
      return token.type === "ColorValue" || token.type === "NumberValue" && !token.unit;
    }
    function mergeTokens(scanner, tokens) {
      let start = 0;
      let end = 0;
      while (tokens.length) {
        const token = last(tokens);
        if (token.type === "Literal" || token.type === "NumberValue") {
          start = token.start;
          if (!end) {
            end = token.end;
          }
          tokens.pop();
        } else {
          break;
        }
      }
      if (start !== end) {
        tokens.push(createLiteral(scanner, start, end));
      }
    }
    function last(arr) {
      return arr[arr.length - 1];
    }
    function tokenScanner(tokens) {
      return {
        tokens,
        start: 0,
        pos: 0,
        size: tokens.length
      };
    }
    function peek$2(scanner) {
      return scanner.tokens[scanner.pos];
    }
    function readable(scanner) {
      return scanner.pos < scanner.size;
    }
    function consume$1(scanner, test) {
      if (test(peek$2(scanner))) {
        scanner.pos++;
        return true;
      }
      return false;
    }
    function error(scanner, message, token = peek$2(scanner)) {
      if (token && token.start != null) {
        message += ` at ${token.start}`;
      }
      const err = new Error(message);
      err["pos"] = token && token.start;
      return err;
    }
    function parser(tokens, options = {}) {
      const scanner = tokenScanner(tokens);
      const result = [];
      let property2;
      while (readable(scanner)) {
        if (property2 = consumeProperty(scanner, options)) {
          result.push(property2);
        } else if (!consume$1(scanner, isSiblingOperator)) {
          throw error(scanner, "Unexpected token");
        }
      }
      return result;
    }
    function consumeProperty(scanner, options) {
      let name;
      let important = false;
      let valueFragment;
      const value = [];
      const token = peek$2(scanner);
      const valueMode = !!options.value;
      if (!valueMode && isLiteral(token) && !isFunctionStart(scanner)) {
        scanner.pos++;
        name = token.value;
        consume$1(scanner, isValueDelimiter);
      }
      if (valueMode) {
        consume$1(scanner, isWhiteSpace$1);
      }
      while (readable(scanner)) {
        if (consume$1(scanner, isImportant)) {
          important = true;
        } else if (valueFragment = consumeValue(scanner, valueMode)) {
          value.push(valueFragment);
        } else if (!consume$1(scanner, isFragmentDelimiter)) {
          break;
        }
      }
      if (name || value.length || important) {
        return { name, value, important };
      }
    }
    function consumeValue(scanner, inArgument) {
      const result = [];
      let token;
      let args;
      while (readable(scanner)) {
        token = peek$2(scanner);
        if (isValue(token)) {
          scanner.pos++;
          if (isLiteral(token) && (args = consumeArguments(scanner))) {
            result.push({
              type: "FunctionCall",
              name: token.value,
              arguments: args
            });
          } else {
            result.push(token);
          }
        } else if (isValueDelimiter(token) || inArgument && isWhiteSpace$1(token)) {
          scanner.pos++;
        } else {
          break;
        }
      }
      return result.length ? { type: "CSSValue", value: result } : void 0;
    }
    function consumeArguments(scanner) {
      const start = scanner.pos;
      if (consume$1(scanner, isOpenBracket$1)) {
        const args = [];
        let value;
        while (readable(scanner) && !consume$1(scanner, isCloseBracket$1)) {
          if (value = consumeValue(scanner, true)) {
            args.push(value);
          } else if (!consume$1(scanner, isWhiteSpace$1) && !consume$1(scanner, isArgumentDelimiter)) {
            throw error(scanner, "Unexpected token");
          }
        }
        scanner.start = start;
        return args;
      }
    }
    function isLiteral(token) {
      return token && token.type === "Literal";
    }
    function isBracket(token, open) {
      return token && token.type === "Bracket" && (open == null || token.open === open);
    }
    function isOpenBracket$1(token) {
      return isBracket(token, true);
    }
    function isCloseBracket$1(token) {
      return isBracket(token, false);
    }
    function isWhiteSpace$1(token) {
      return token && token.type === "WhiteSpace";
    }
    function isOperator(token, operator2) {
      return token && token.type === "Operator" && (!operator2 || token.operator === operator2);
    }
    function isSiblingOperator(token) {
      return isOperator(token, OperatorType.Sibling);
    }
    function isArgumentDelimiter(token) {
      return isOperator(token, OperatorType.ArgumentDelimiter);
    }
    function isFragmentDelimiter(token) {
      return isArgumentDelimiter(token);
    }
    function isImportant(token) {
      return isOperator(token, OperatorType.Important);
    }
    function isValue(token) {
      return token.type === "StringValue" || token.type === "ColorValue" || token.type === "NumberValue" || token.type === "Literal" || token.type === "Field" || token.type === "CustomProperty";
    }
    function isValueDelimiter(token) {
      return isOperator(token, OperatorType.PropertyDelimiter) || isOperator(token, OperatorType.ValueDelimiter);
    }
    function isFunctionStart(scanner) {
      const t1 = scanner.tokens[scanner.pos];
      const t2 = scanner.tokens[scanner.pos + 1];
      return t1 && t2 && isLiteral(t1) && t2.type === "Bracket";
    }
    function parse$2(abbr, options) {
      try {
        const tokens = typeof abbr === "string" ? tokenize(abbr, options && options.value) : abbr;
        return parser(tokens, options);
      } catch (err) {
        if (err instanceof ScannerError && typeof abbr === "string") {
          err.message += `
${abbr}
${"-".repeat(err.pos)}^`;
        }
        throw err;
      }
    }
    function mergeAttributes(node, config) {
      if (!node.attributes) {
        return;
      }
      const attributes = [];
      const lookup = {};
      for (const attr of node.attributes) {
        if (attr.name) {
          const attrName2 = attr.name;
          if (attrName2 in lookup) {
            const prev = lookup[attrName2];
            if (attrName2 === "class") {
              prev.value = mergeValue(prev.value, attr.value, " ");
            } else {
              mergeDeclarations(prev, attr, config);
            }
          } else {
            attributes.push(lookup[attrName2] = Object.assign({}, attr));
          }
        } else {
          attributes.push(attr);
        }
      }
      node.attributes = attributes;
    }
    function mergeValue(prev, next2, glue) {
      if (prev && next2) {
        if (prev.length && glue) {
          append(prev, glue);
        }
        for (const t of next2) {
          append(prev, t);
        }
        return prev;
      }
      const result = prev || next2;
      return result && result.slice();
    }
    function mergeDeclarations(dest, src, config) {
      dest.name = src.name;
      if (!config.options["output.reverseAttributes"]) {
        dest.value = src.value;
      }
      if (!dest.implied) {
        dest.implied = src.implied;
      }
      if (!dest.boolean) {
        dest.boolean = src.boolean;
      }
      if (dest.valueType !== "expression") {
        dest.valueType = src.valueType;
      }
      return dest;
    }
    function append(tokens, value) {
      const lastIx = tokens.length - 1;
      if (typeof tokens[lastIx] === "string" && typeof value === "string") {
        tokens[lastIx] += value;
      } else {
        tokens.push(value);
      }
    }
    function walk$1(node, fn, state) {
      const ancestors = [node];
      const callback = (ctx) => {
        fn(ctx, ancestors, state);
        ancestors.push(ctx);
        ctx.children.forEach(callback);
        ancestors.pop();
      };
      node.children.forEach(callback);
    }
    function find$1(node, callback) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (callback(child)) {
          return child;
        }
        const result = find$1(child, callback);
        if (result) {
          return result;
        }
      }
    }
    function findDeepest(node) {
      let parent;
      while (node.children.length) {
        parent = node;
        node = node.children[node.children.length - 1];
      }
      return { parent, node };
    }
    function isNode(node) {
      return node.type === "AbbreviationNode";
    }
    function resolveSnippets(abbr, config) {
      const stack = [];
      const reversed = config.options["output.reverseAttributes"];
      const { warn } = config;
      const resolve = (child) => {
        const snippet = child.name && config.snippets[child.name];
        if (!snippet || stack.includes(snippet)) {
          return null;
        }
        let snippetAbbr;
        try {
          snippetAbbr = parseAbbreviation(snippet, config);
        } catch (err) {
          warn === null || warn === void 0 ? void 0 : warn(`Unable to parse "${snippet}" snippet`, err);
          return null;
        }
        stack.push(snippet);
        walkResolve(snippetAbbr, resolve);
        stack.pop();
        for (const topNode of snippetAbbr.children) {
          if (child.attributes) {
            const from = topNode.attributes || [];
            const to = child.attributes || [];
            topNode.attributes = reversed ? to.concat(from) : from.concat(to);
          }
          mergeNodes(child, topNode);
        }
        return snippetAbbr;
      };
      walkResolve(abbr, resolve);
      return abbr;
    }
    function walkResolve(node, resolve, config) {
      let children = [];
      for (const child of node.children) {
        const resolved = resolve(child);
        if (resolved) {
          children = children.concat(resolved.children);
          const deepest = findDeepest(resolved);
          if (isNode(deepest.node)) {
            deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));
          }
        } else {
          children.push(child);
          child.children = walkResolve(child, resolve);
        }
      }
      return node.children = children;
    }
    function mergeNodes(from, to) {
      if (from.selfClosing) {
        to.selfClosing = true;
      }
      if (from.value != null) {
        to.value = from.value;
      }
      if (from.repeat) {
        to.repeat = from.repeat;
      }
    }
    var expressionStart = "{";
    var expressionEnd = "}";
    function createOutputStream(options, level = 0) {
      return {
        options,
        value: "",
        level,
        offset: 0,
        line: 0,
        column: 0
      };
    }
    function push(stream, text2) {
      const processText = stream.options["output.text"];
      _push(stream, processText(text2, stream.offset, stream.line, stream.column));
    }
    function pushString(stream, value) {
      const lines = splitByLines$1(value);
      for (let i = 0, il = lines.length - 1; i <= il; i++) {
        push(stream, lines[i]);
        if (i !== il) {
          pushNewline(stream, true);
        }
      }
    }
    function pushNewline(stream, indent) {
      const baseIndent = stream.options["output.baseIndent"];
      const newline = stream.options["output.newline"];
      push(stream, newline + baseIndent);
      stream.line++;
      stream.column = baseIndent.length;
      if (indent) {
        pushIndent(stream, indent === true ? stream.level : indent);
      }
    }
    function pushIndent(stream, size = stream.level) {
      const indent = stream.options["output.indent"];
      push(stream, indent.repeat(Math.max(size, 0)));
    }
    function pushField(stream, index, placeholder) {
      const field2 = stream.options["output.field"];
      _push(stream, field2(index, placeholder, stream.offset, stream.line, stream.column));
    }
    function tagName(name, config) {
      return strCase(name, config.options["output.tagCase"]);
    }
    function attrName(name, config) {
      return strCase(name, config.options["output.attributeCase"]);
    }
    function attrQuote(attr, config, isOpen) {
      if (attr.valueType === "expression") {
        return isOpen ? expressionStart : expressionEnd;
      }
      return config.options["output.attributeQuotes"] === "single" ? "'" : '"';
    }
    function isBooleanAttribute(attr, config) {
      return attr.boolean || config.options["output.booleanAttributes"].includes((attr.name || "").toLowerCase());
    }
    function selfClose(config) {
      switch (config.options["output.selfClosingStyle"]) {
        case "xhtml":
          return " /";
        case "xml":
          return "/";
        default:
          return "";
      }
    }
    function isInline(node, config) {
      if (typeof node === "string") {
        return config.options.inlineElements.includes(node.toLowerCase());
      }
      return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);
    }
    function splitByLines$1(text2) {
      return text2.split(/\r\n|\r|\n/g);
    }
    function _push(stream, text2) {
      stream.value += text2;
      stream.offset += text2.length;
      stream.column += text2.length;
    }
    function strCase(str, type) {
      if (type) {
        return type === "upper" ? str.toUpperCase() : str.toLowerCase();
      }
      return str;
    }
    var elementMap = {
      p: "span",
      ul: "li",
      ol: "li",
      table: "tr",
      tr: "td",
      tbody: "tr",
      thead: "tr",
      tfoot: "tr",
      colgroup: "col",
      select: "option",
      optgroup: "option",
      audio: "source",
      video: "source",
      object: "param",
      map: "area"
    };
    function implicitTag(node, ancestors, config) {
      if (!node.name && node.attributes) {
        resolveImplicitTag(node, ancestors, config);
      }
    }
    function resolveImplicitTag(node, ancestors, config) {
      const parent = getParentElement(ancestors);
      const contextName = config.context ? config.context.name : "";
      const parentName = lowercase(parent ? parent.name : contextName);
      node.name = elementMap[parentName] || (isInline(parentName, config) ? "span" : "div");
    }
    function lowercase(str) {
      return (str || "").toLowerCase();
    }
    function getParentElement(ancestors) {
      for (let i = ancestors.length - 1; i >= 0; i--) {
        const elem = ancestors[i];
        if (isNode(elem)) {
          return elem;
        }
      }
    }
    var latin = {
      "common": ["lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipisicing", "elit"],
      "words": [
        "exercitationem",
        "perferendis",
        "perspiciatis",
        "laborum",
        "eveniet",
        "sunt",
        "iure",
        "nam",
        "nobis",
        "eum",
        "cum",
        "officiis",
        "excepturi",
        "odio",
        "consectetur",
        "quasi",
        "aut",
        "quisquam",
        "vel",
        "eligendi",
        "itaque",
        "non",
        "odit",
        "tempore",
        "quaerat",
        "dignissimos",
        "facilis",
        "neque",
        "nihil",
        "expedita",
        "vitae",
        "vero",
        "ipsum",
        "nisi",
        "animi",
        "cumque",
        "pariatur",
        "velit",
        "modi",
        "natus",
        "iusto",
        "eaque",
        "sequi",
        "illo",
        "sed",
        "ex",
        "et",
        "voluptatibus",
        "tempora",
        "veritatis",
        "ratione",
        "assumenda",
        "incidunt",
        "nostrum",
        "placeat",
        "aliquid",
        "fuga",
        "provident",
        "praesentium",
        "rem",
        "necessitatibus",
        "suscipit",
        "adipisci",
        "quidem",
        "possimus",
        "voluptas",
        "debitis",
        "sint",
        "accusantium",
        "unde",
        "sapiente",
        "voluptate",
        "qui",
        "aspernatur",
        "laudantium",
        "soluta",
        "amet",
        "quo",
        "aliquam",
        "saepe",
        "culpa",
        "libero",
        "ipsa",
        "dicta",
        "reiciendis",
        "nesciunt",
        "doloribus",
        "autem",
        "impedit",
        "minima",
        "maiores",
        "repudiandae",
        "ipsam",
        "obcaecati",
        "ullam",
        "enim",
        "totam",
        "delectus",
        "ducimus",
        "quis",
        "voluptates",
        "dolores",
        "molestiae",
        "harum",
        "dolorem",
        "quia",
        "voluptatem",
        "molestias",
        "magni",
        "distinctio",
        "omnis",
        "illum",
        "dolorum",
        "voluptatum",
        "ea",
        "quas",
        "quam",
        "corporis",
        "quae",
        "blanditiis",
        "atque",
        "deserunt",
        "laboriosam",
        "earum",
        "consequuntur",
        "hic",
        "cupiditate",
        "quibusdam",
        "accusamus",
        "ut",
        "rerum",
        "error",
        "minus",
        "eius",
        "ab",
        "ad",
        "nemo",
        "fugit",
        "officia",
        "at",
        "in",
        "id",
        "quos",
        "reprehenderit",
        "numquam",
        "iste",
        "fugiat",
        "sit",
        "inventore",
        "beatae",
        "repellendus",
        "magnam",
        "recusandae",
        "quod",
        "explicabo",
        "doloremque",
        "aperiam",
        "consequatur",
        "asperiores",
        "commodi",
        "optio",
        "dolor",
        "labore",
        "temporibus",
        "repellat",
        "veniam",
        "architecto",
        "est",
        "esse",
        "mollitia",
        "nulla",
        "a",
        "similique",
        "eos",
        "alias",
        "dolore",
        "tenetur",
        "deleniti",
        "porro",
        "facere",
        "maxime",
        "corrupti"
      ]
    };
    var ru = {
      "common": ["\u0434\u0430\u043B\u0435\u043A\u043E-\u0434\u0430\u043B\u0435\u043A\u043E", "\u0437\u0430", "\u0441\u043B\u043E\u0432\u0435\u0441\u043D\u044B\u043C\u0438", "\u0433\u043E\u0440\u0430\u043C\u0438", "\u0432 \u0441\u0442\u0440\u0430\u043D\u0435", "\u0433\u043B\u0430\u0441\u043D\u044B\u0445", "\u0438 \u0441\u043E\u0433\u043B\u0430\u0441\u043D\u044B\u0445", "\u0436\u0438\u0432\u0443\u0442", "\u0440\u044B\u0431\u043D\u044B\u0435", "\u0442\u0435\u043A\u0441\u0442\u044B"],
      "words": [
        "\u0432\u0434\u0430\u043B\u0438",
        "\u043E\u0442 \u0432\u0441\u0435\u0445",
        "\u043E\u043D\u0438",
        "\u0431\u0443\u043A\u0432\u0435\u043D\u043D\u044B\u0445",
        "\u0434\u043E\u043C\u0430\u0445",
        "\u043D\u0430 \u0431\u0435\u0440\u0435\u0433\u0443",
        "\u0441\u0435\u043C\u0430\u043D\u0442\u0438\u043A\u0430",
        "\u0431\u043E\u043B\u044C\u0448\u043E\u0433\u043E",
        "\u044F\u0437\u044B\u043A\u043E\u0432\u043E\u0433\u043E",
        "\u043E\u043A\u0435\u0430\u043D\u0430",
        "\u043C\u0430\u043B\u0435\u043D\u044C\u043A\u0438\u0439",
        "\u0440\u0443\u0447\u0435\u0435\u043A",
        "\u0434\u0430\u043B\u044C",
        "\u0436\u0443\u0440\u0447\u0438\u0442",
        "\u043F\u043E \u0432\u0441\u0435\u0439",
        "\u043E\u0431\u0435\u0441\u043F\u0435\u0447\u0438\u0432\u0430\u0435\u0442",
        "\u0435\u0435",
        "\u0432\u0441\u0435\u043C\u0438",
        "\u043D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u044B\u043C\u0438",
        "\u043F\u0440\u0430\u0432\u0438\u043B\u0430\u043C\u0438",
        "\u044D\u0442\u0430",
        "\u043F\u0430\u0440\u0430\u0434\u0438\u0433\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0430\u044F",
        "\u0441\u0442\u0440\u0430\u043D\u0430",
        "\u043A\u043E\u0442\u043E\u0440\u043E\u0439",
        "\u0436\u0430\u0440\u0435\u043D\u043D\u044B\u0435",
        "\u043F\u0440\u0435\u0434\u043B\u043E\u0436\u0435\u043D\u0438\u044F",
        "\u0437\u0430\u043B\u0435\u0442\u0430\u044E\u0442",
        "\u043F\u0440\u044F\u043C\u043E",
        "\u0440\u043E\u0442",
        "\u0434\u0430\u0436\u0435",
        "\u0432\u0441\u0435\u043C\u043E\u0433\u0443\u0449\u0430\u044F",
        "\u043F\u0443\u043D\u043A\u0442\u0443\u0430\u0446\u0438\u044F",
        "\u043D\u0435",
        "\u0438\u043C\u0435\u0435\u0442",
        "\u0432\u043B\u0430\u0441\u0442\u0438",
        "\u043D\u0430\u0434",
        "\u0440\u044B\u0431\u043D\u044B\u043C\u0438",
        "\u0442\u0435\u043A\u0441\u0442\u0430\u043C\u0438",
        "\u0432\u0435\u0434\u0443\u0449\u0438\u043C\u0438",
        "\u0431\u0435\u0437\u043E\u0440\u0444\u043E\u0433\u0440\u0430\u0444\u0438\u0447\u043D\u044B\u0439",
        "\u043E\u0431\u0440\u0430\u0437",
        "\u0436\u0438\u0437\u043D\u0438",
        "\u043E\u0434\u043D\u0430\u0436\u0434\u044B",
        "\u043E\u0434\u043D\u0430",
        "\u043C\u0430\u043B\u0435\u043D\u044C\u043A\u0430\u044F",
        "\u0441\u0442\u0440\u043E\u0447\u043A\u0430",
        "\u0440\u044B\u0431\u043D\u043E\u0433\u043E",
        "\u0442\u0435\u043A\u0441\u0442\u0430",
        "\u0438\u043C\u0435\u043D\u0438",
        "lorem",
        "ipsum",
        "\u0440\u0435\u0448\u0438\u043B\u0430",
        "\u0432\u044B\u0439\u0442\u0438",
        "\u0431\u043E\u043B\u044C\u0448\u043E\u0439",
        "\u043C\u0438\u0440",
        "\u0433\u0440\u0430\u043C\u043C\u0430\u0442\u0438\u043A\u0438",
        "\u0432\u0435\u043B\u0438\u043A\u0438\u0439",
        "\u043E\u043A\u0441\u043C\u043E\u043A\u0441",
        "\u043F\u0440\u0435\u0434\u0443\u043F\u0440\u0435\u0436\u0434\u0430\u043B",
        "\u043E",
        "\u0437\u043B\u044B\u0445",
        "\u0437\u0430\u043F\u044F\u0442\u044B\u0445",
        "\u0434\u0438\u043A\u0438\u0445",
        "\u0437\u043D\u0430\u043A\u0430\u0445",
        "\u0432\u043E\u043F\u0440\u043E\u0441\u0430",
        "\u043A\u043E\u0432\u0430\u0440\u043D\u044B\u0445",
        "\u0442\u043E\u0447\u043A\u0430\u0445",
        "\u0437\u0430\u043F\u044F\u0442\u043E\u0439",
        "\u043D\u043E",
        "\u0442\u0435\u043A\u0441\u0442",
        "\u0434\u0430\u043B",
        "\u0441\u0431\u0438\u0442\u044C",
        "\u0441\u0435\u0431\u044F",
        "\u0442\u043E\u043B\u043A\u0443",
        "\u043E\u043D",
        "\u0441\u043E\u0431\u0440\u0430\u043B",
        "\u0441\u0435\u043C\u044C",
        "\u0441\u0432\u043E\u0438\u0445",
        "\u0437\u0430\u0433\u043B\u0430\u0432\u043D\u044B\u0445",
        "\u0431\u0443\u043A\u0432",
        "\u043F\u043E\u0434\u043F\u043E\u044F\u0441\u0430\u043B",
        "\u0438\u043D\u0438\u0446\u0438\u0430\u043B",
        "\u0437\u0430",
        "\u043F\u043E\u044F\u0441",
        "\u043F\u0443\u0441\u0442\u0438\u043B\u0441\u044F",
        "\u0434\u043E\u0440\u043E\u0433\u0443",
        "\u0432\u0437\u043E\u0431\u0440\u0430\u0432\u0448\u0438\u0441\u044C",
        "\u043F\u0435\u0440\u0432\u0443\u044E",
        "\u0432\u0435\u0440\u0448\u0438\u043D\u0443",
        "\u043A\u0443\u0440\u0441\u0438\u0432\u043D\u044B\u0445",
        "\u0433\u043E\u0440",
        "\u0431\u0440\u043E\u0441\u0438\u043B",
        "\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0439",
        "\u0432\u0437\u0433\u043B\u044F\u0434",
        "\u043D\u0430\u0437\u0430\u0434",
        "\u0441\u0438\u043B\u0443\u044D\u0442",
        "\u0441\u0432\u043E\u0435\u0433\u043E",
        "\u0440\u043E\u0434\u043D\u043E\u0433\u043E",
        "\u0433\u043E\u0440\u043E\u0434\u0430",
        "\u0431\u0443\u043A\u0432\u043E\u0433\u0440\u0430\u0434",
        "\u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A",
        "\u0434\u0435\u0440\u0435\u0432\u043D\u0438",
        "\u0430\u043B\u0444\u0430\u0432\u0438\u0442",
        "\u043F\u043E\u0434\u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A",
        "\u0441\u0432\u043E\u0435\u0433\u043E",
        "\u043F\u0435\u0440\u0435\u0443\u043B\u043A\u0430",
        "\u0433\u0440\u0443\u0441\u0442\u043D\u044B\u0439",
        "\u0440\u0435\u0442\u043E\u0440\u0438\u0447\u0435\u0441\u043A\u0438\u0439",
        "\u0432\u043E\u043F\u0440\u043E\u0441",
        "\u0441\u043A\u0430\u0442\u0438\u043B\u0441\u044F",
        "\u0435\u0433\u043E",
        "\u0449\u0435\u043A\u0435",
        "\u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u043B",
        "\u0441\u0432\u043E\u0439",
        "\u043F\u0443\u0442\u044C",
        "\u0434\u043E\u0440\u043E\u0433\u0435",
        "\u0432\u0441\u0442\u0440\u0435\u0442\u0438\u043B",
        "\u0440\u0443\u043A\u043E\u043F\u0438\u0441\u044C",
        "\u043E\u043D\u0430",
        "\u043F\u0440\u0435\u0434\u0443\u043F\u0440\u0435\u0434\u0438\u043B\u0430",
        "\u043C\u043E\u0435\u0439",
        "\u0432\u0441\u0435",
        "\u043F\u0435\u0440\u0435\u043F\u0438\u0441\u044B\u0432\u0430\u0435\u0442\u0441\u044F",
        "\u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E",
        "\u0440\u0430\u0437",
        "\u0435\u0434\u0438\u043D\u0441\u0442\u0432\u0435\u043D\u043D\u043E\u0435",
        "\u0447\u0442\u043E",
        "\u043C\u0435\u043D\u044F",
        "\u043E\u0441\u0442\u0430\u043B\u043E\u0441\u044C",
        "\u044D\u0442\u043E",
        "\u043F\u0440\u0438\u0441\u0442\u0430\u0432\u043A\u0430",
        "\u0432\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0439\u0441\u044F",
        "\u0442\u044B",
        "\u043B\u0443\u0447\u0448\u0435",
        "\u0441\u0432\u043E\u044E",
        "\u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u0443\u044E",
        "\u0441\u0442\u0440\u0430\u043D\u0443",
        "\u043F\u043E\u0441\u043B\u0443\u0448\u0430\u0432\u0448\u0438\u0441\u044C",
        "\u0440\u0443\u043A\u043E\u043F\u0438\u0441\u0438",
        "\u043D\u0430\u0448",
        "\u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u043B",
        "\u0441\u0432\u043E\u0439",
        "\u043F\u0443\u0442\u044C",
        "\u0432\u0441\u043A\u043E\u0440\u0435",
        "\u0435\u043C\u0443",
        "\u043F\u043E\u0432\u0441\u0442\u0440\u0435\u0447\u0430\u043B\u0441\u044F",
        "\u043A\u043E\u0432\u0430\u0440\u043D\u044B\u0439",
        "\u0441\u043E\u0441\u0442\u0430\u0432\u0438\u0442\u0435\u043B\u044C",
        "\u0440\u0435\u043A\u043B\u0430\u043C\u043D\u044B\u0445",
        "\u0442\u0435\u043A\u0441\u0442\u043E\u0432",
        "\u043D\u0430\u043F\u043E\u0438\u0432\u0448\u0438\u0439",
        "\u044F\u0437\u044B\u043A\u043E\u043C",
        "\u0440\u0435\u0447\u044C\u044E",
        "\u0437\u0430\u043C\u0430\u043D\u0438\u0432\u0448\u0438\u0439",
        "\u0441\u0432\u043E\u0435",
        "\u0430\u0433\u0435\u043D\u0442\u0441\u0442\u0432\u043E",
        "\u043A\u043E\u0442\u043E\u0440\u043E\u0435",
        "\u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043B\u043E",
        "\u0441\u043D\u043E\u0432\u0430",
        "\u0441\u043D\u043E\u0432\u0430",
        "\u0441\u0432\u043E\u0438\u0445",
        "\u043F\u0440\u043E\u0435\u043A\u0442\u0430\u0445",
        "\u0435\u0441\u043B\u0438",
        "\u043F\u0435\u0440\u0435\u043F\u0438\u0441\u0430\u043B\u0438",
        "\u0442\u043E",
        "\u0436\u0438\u0432\u0435\u0442",
        "\u0442\u0430\u043C",
        "\u0434\u043E",
        "\u0441\u0438\u0445",
        "\u043F\u043E\u0440"
      ]
    };
    var sp = {
      "common": ["mujer", "uno", "dolor", "m\xE1s", "de", "poder", "mismo", "si"],
      "words": [
        "ejercicio",
        "preferencia",
        "perspicacia",
        "laboral",
        "pa\xF1o",
        "suntuoso",
        "molde",
        "namibia",
        "planeador",
        "mirar",
        "dem\xE1s",
        "oficinista",
        "excepci\xF3n",
        "odio",
        "consecuencia",
        "casi",
        "auto",
        "chicharra",
        "velo",
        "elixir",
        "ataque",
        "no",
        "odio",
        "temporal",
        "cu\xF3rum",
        "dign\xEDsimo",
        "facilismo",
        "letra",
        "nihilista",
        "expedici\xF3n",
        "alma",
        "alveolar",
        "aparte",
        "le\xF3n",
        "animal",
        "como",
        "paria",
        "belleza",
        "modo",
        "natividad",
        "justo",
        "ataque",
        "s\xE9quito",
        "pillo",
        "sed",
        "ex",
        "y",
        "voluminoso",
        "temporalidad",
        "verdades",
        "racional",
        "asunci\xF3n",
        "incidente",
        "marejada",
        "placenta",
        "amanecer",
        "fuga",
        "previsor",
        "presentaci\xF3n",
        "lejos",
        "necesariamente",
        "sospechoso",
        "adiposidad",
        "quind\xEDo",
        "p\xF3cima",
        "voluble",
        "d\xE9bito",
        "sinti\xF3",
        "accesorio",
        "falda",
        "sapiencia",
        "volutas",
        "queso",
        "permacultura",
        "laudo",
        "soluciones",
        "entero",
        "pan",
        "litro",
        "tonelada",
        "culpa",
        "libertario",
        "mosca",
        "dictado",
        "reincidente",
        "nascimiento",
        "dolor",
        "escolar",
        "impedimento",
        "m\xEDnima",
        "mayores",
        "repugnante",
        "dulce",
        "obcecado",
        "monta\xF1a",
        "enigma",
        "total",
        "delet\xE9reo",
        "d\xE9cima",
        "c\xE1bala",
        "fotograf\xEDa",
        "dolores",
        "molesto",
        "olvido",
        "paciencia",
        "resiliencia",
        "voluntad",
        "molestias",
        "magn\xEDfico",
        "distinci\xF3n",
        "ovni",
        "marejada",
        "cerro",
        "torre",
        "y",
        "abogada",
        "manantial",
        "corporal",
        "agua",
        "crep\xFAsculo",
        "ataque",
        "desierto",
        "laboriosamente",
        "angustia",
        "afortunado",
        "alma",
        "encefalograma",
        "materialidad",
        "cosas",
        "o",
        "renuncia",
        "error",
        "menos",
        "conejo",
        "abad\xEDa",
        "analfabeto",
        "remo",
        "fugacidad",
        "oficio",
        "en",
        "alm\xE1cigo",
        "vos",
        "pan",
        "represi\xF3n",
        "n\xFAmeros",
        "triste",
        "refugiado",
        "trote",
        "inventor",
        "corchea",
        "repelente",
        "magma",
        "recusado",
        "patr\xF3n",
        "expl\xEDcito",
        "paloma",
        "s\xEDndrome",
        "inmune",
        "autoinmune",
        "comodidad",
        "ley",
        "vietnamita",
        "demonio",
        "tasmania",
        "repeler",
        "ap\xE9ndice",
        "arquitecto",
        "columna",
        "yugo",
        "computador",
        "mula",
        "a",
        "prop\xF3sito",
        "fantas\xEDa",
        "alias",
        "rayo",
        "tenedor",
        "deleznable",
        "ventana",
        "cara",
        "anemia",
        "corrupto"
      ]
    };
    var vocabularies = { ru, sp, latin };
    var reLorem = /^lorem([a-z]*)(\d*)(-\d*)?$/i;
    function lorem(node, ancestors, config) {
      let m;
      if (node.name && (m = node.name.match(reLorem))) {
        const db = vocabularies[m[1]] || vocabularies.latin;
        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;
        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;
        const wordCount = rand(minWordCount, maxWordCount);
        const repeat = node.repeat || findRepeater(ancestors);
        node.name = node.attributes = void 0;
        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];
        if (node.repeat && ancestors.length > 1) {
          resolveImplicitTag(node, ancestors, config);
        }
      }
    }
    function rand(from, to) {
      return Math.floor(Math.random() * (to - from) + from);
    }
    function sample(arr, count) {
      const len = arr.length;
      const iterations = Math.min(len, count);
      const result = [];
      while (result.length < iterations) {
        const str = arr[rand(0, len)];
        if (!result.includes(str)) {
          result.push(str);
        }
      }
      return result;
    }
    function choice(val) {
      return val[rand(0, val.length - 1)];
    }
    function sentence(words, end) {
      if (words.length) {
        words = [capitalize(words[0])].concat(words.slice(1));
      }
      return words.join(" ") + (end || choice("?!..."));
    }
    function capitalize(word) {
      return word[0].toUpperCase() + word.slice(1);
    }
    function insertCommas(words) {
      if (words.length < 2) {
        return words;
      }
      words = words.slice();
      const len = words.length;
      const hasComma = /,$/;
      let totalCommas = 0;
      if (len > 3 && len <= 6) {
        totalCommas = rand(0, 1);
      } else if (len > 6 && len <= 12) {
        totalCommas = rand(0, 2);
      } else {
        totalCommas = rand(1, 4);
      }
      for (let i = 0, pos; i < totalCommas; i++) {
        pos = rand(0, len - 2);
        if (!hasComma.test(words[pos])) {
          words[pos] += ",";
        }
      }
      return words;
    }
    function paragraph(dict, wordCount, startWithCommon) {
      const result = [];
      let totalWords = 0;
      let words;
      if (startWithCommon && dict.common) {
        words = dict.common.slice(0, wordCount);
        totalWords += words.length;
        result.push(sentence(insertCommas(words), "."));
      }
      while (totalWords < wordCount) {
        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));
        totalWords += words.length;
        result.push(sentence(insertCommas(words)));
      }
      return result.join(" ");
    }
    function findRepeater(ancestors) {
      for (let i = ancestors.length - 1; i >= 0; i--) {
        const element2 = ancestors[i];
        if (element2.type === "AbbreviationNode" && element2.repeat) {
          return element2.repeat;
        }
      }
    }
    function xsl(node) {
      if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {
        node.attributes = node.attributes.filter(isAllowed);
      }
    }
    function isAllowed(attr) {
      return attr.name !== "select";
    }
    function matchesName(name) {
      return name === "xsl:variable" || name === "xsl:with-param";
    }
    var reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;
    var reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;
    var blockCandidates1 = (className) => /^[a-z]\-/i.test(className);
    var blockCandidates2 = (className) => /^[a-z]/i.test(className);
    function bem(node, ancestors, config) {
      expandClassNames(node);
      expandShortNotation(node, ancestors, config);
    }
    function expandClassNames(node) {
      const data = getBEMData(node);
      const classNames = [];
      for (const cl of data.classNames) {
        const ix = cl.indexOf("_");
        if (ix > 0 && !cl.startsWith("-")) {
          classNames.push(cl.slice(0, ix));
          classNames.push(cl.slice(ix));
        } else {
          classNames.push(cl);
        }
      }
      if (classNames.length) {
        data.classNames = classNames.filter(uniqueClass);
        data.block = findBlockName(data.classNames);
        updateClass(node, data.classNames.join(" "));
      }
    }
    function expandShortNotation(node, ancestors, config) {
      const data = getBEMData(node);
      const classNames = [];
      const { options } = config;
      const path3 = ancestors.slice(1).concat(node);
      for (let cl of data.classNames) {
        let prefix = "";
        let m;
        const originalClass = cl;
        if (m = cl.match(reElement)) {
          prefix = getBlockName(path3, m[1].length, config.context) + options["bem.element"] + m[2];
          classNames.push(prefix);
          cl = cl.slice(m[0].length);
        }
        if (m = cl.match(reModifier)) {
          if (!prefix) {
            prefix = getBlockName(path3, m[1].length);
            classNames.push(prefix);
          }
          classNames.push(`${prefix}${options["bem.modifier"]}${m[2]}`);
          cl = cl.slice(m[0].length);
        }
        if (cl === originalClass) {
          classNames.push(originalClass);
        }
      }
      const arrClassNames = classNames.filter(uniqueClass);
      if (arrClassNames.length) {
        updateClass(node, arrClassNames.join(" "));
      }
    }
    function getBEMData(node) {
      if (!node._bem) {
        let classValue = "";
        if (node.attributes) {
          for (const attr of node.attributes) {
            if (attr.name === "class" && attr.value) {
              classValue = stringifyValue(attr.value);
              break;
            }
          }
        }
        node._bem = parseBEM(classValue);
      }
      return node._bem;
    }
    function getBEMDataFromContext(context) {
      if (!context._bem) {
        context._bem = parseBEM(context.attributes && context.attributes.class || "");
      }
      return context._bem;
    }
    function parseBEM(classValue) {
      const classNames = classValue ? classValue.split(/\s+/) : [];
      return {
        classNames,
        block: findBlockName(classNames)
      };
    }
    function getBlockName(ancestors, depth = 0, context) {
      const maxParentIx = 0;
      let parentIx = Math.max(ancestors.length - depth, maxParentIx);
      do {
        const parent = ancestors[parentIx];
        if (parent) {
          const data = getBEMData(parent);
          if (data.block) {
            return data.block;
          }
        }
      } while (maxParentIx < parentIx--);
      if (context) {
        const data = getBEMDataFromContext(context);
        if (data.block) {
          return data.block;
        }
      }
      return "";
    }
    function findBlockName(classNames) {
      return find(classNames, blockCandidates1) || find(classNames, blockCandidates2) || void 0;
    }
    function find(classNames, filter) {
      for (const cl of classNames) {
        if (reElement.test(cl) || reModifier.test(cl)) {
          break;
        }
        if (filter(cl)) {
          return cl;
        }
      }
    }
    function updateClass(node, value) {
      for (const attr of node.attributes) {
        if (attr.name === "class") {
          attr.value = [value];
          break;
        }
      }
    }
    function stringifyValue(value) {
      let result = "";
      for (const t of value) {
        result += typeof t === "string" ? t : t.name;
      }
      return result;
    }
    function uniqueClass(item, ix, arr) {
      return !!item && arr.indexOf(item) === ix;
    }
    function label(node) {
      if (node.name === "label") {
        const input = find$1(node, (n) => n.name === "input" || n.name === "textarea");
        if (input) {
          if (node.attributes) {
            node.attributes = node.attributes.filter((attr) => {
              return !(attr.name === "for" && isEmptyAttribute(attr));
            });
          }
          if (input.attributes) {
            input.attributes = input.attributes.filter((attr) => {
              return !(attr.name === "id" && isEmptyAttribute(attr));
            });
          }
        }
      }
    }
    function isEmptyAttribute(attr) {
      if (!attr.value) {
        return true;
      }
      if (attr.value.length === 1) {
        const token = attr.value[0];
        if (token && typeof token !== "string" && !token.name) {
          return true;
        }
      }
      return false;
    }
    function walk(abbr, visitor, state) {
      const callback = (ctx, index, items) => {
        const { parent, current } = state;
        state.parent = current;
        state.current = ctx;
        visitor(ctx, index, items, state, next2);
        state.current = current;
        state.parent = parent;
      };
      const next2 = (node, index, items) => {
        state.ancestors.push(state.current);
        callback(node, index, items);
        state.ancestors.pop();
      };
      abbr.children.forEach(callback);
    }
    function createWalkState(config) {
      return {
        // @ts-ignore: Will set value in iterator
        current: null,
        parent: void 0,
        ancestors: [],
        config,
        field: 1,
        out: createOutputStream(config.options)
      };
    }
    var caret = [{ type: "Field", index: 0, name: "" }];
    function isSnippet(node) {
      return node ? !node.name && !node.attributes : false;
    }
    function isInlineElement(node, config) {
      return node ? isInline(node, config) : false;
    }
    function isField(token) {
      return typeof token === "object" && token.type === "Field";
    }
    function pushTokens(tokens, state) {
      const { out } = state;
      let largestIndex = -1;
      for (const t of tokens) {
        if (typeof t === "string") {
          pushString(out, t);
        } else {
          pushField(out, state.field + t.index, t.name);
          if (t.index > largestIndex) {
            largestIndex = t.index;
          }
        }
      }
      if (largestIndex !== -1) {
        state.field += largestIndex + 1;
      }
    }
    function splitByLines(tokens) {
      const result = [];
      let line = [];
      for (const t of tokens) {
        if (typeof t === "string") {
          const lines = t.split(/\r\n?|\n/g);
          line.push(lines.shift() || "");
          while (lines.length) {
            result.push(line);
            line = [lines.shift() || ""];
          }
        } else {
          line.push(t);
        }
      }
      line.length && result.push(line);
      return result;
    }
    function shouldOutputAttribute(attr) {
      return !attr.implied || attr.valueType !== "raw" || !!attr.value && attr.value.length > 0;
    }
    var TemplateChars;
    (function(TemplateChars2) {
      TemplateChars2[TemplateChars2["Start"] = 91] = "Start";
      TemplateChars2[TemplateChars2["End"] = 93] = "End";
      TemplateChars2[TemplateChars2["Underscore"] = 95] = "Underscore";
      TemplateChars2[TemplateChars2["Dash"] = 45] = "Dash";
    })(TemplateChars || (TemplateChars = {}));
    function template(text2) {
      const tokens = [];
      const scanner = { pos: 0, text: text2 };
      let placeholder;
      let offset = scanner.pos;
      let pos = scanner.pos;
      while (scanner.pos < scanner.text.length) {
        pos = scanner.pos;
        if (placeholder = consumePlaceholder(scanner)) {
          if (offset !== scanner.pos) {
            tokens.push(text2.slice(offset, pos));
          }
          tokens.push(placeholder);
          offset = scanner.pos;
        } else {
          scanner.pos++;
        }
      }
      if (offset !== scanner.pos) {
        tokens.push(text2.slice(offset));
      }
      return tokens;
    }
    function consumePlaceholder(scanner) {
      if (peek$1(scanner) === TemplateChars.Start) {
        const start = ++scanner.pos;
        let namePos = start;
        let afterPos = start;
        let stack = 1;
        while (scanner.pos < scanner.text.length) {
          const code2 = peek$1(scanner);
          if (isTokenStart(code2)) {
            namePos = scanner.pos;
            while (isToken(peek$1(scanner))) {
              scanner.pos++;
            }
            afterPos = scanner.pos;
          } else {
            if (code2 === TemplateChars.Start) {
              stack++;
            } else if (code2 === TemplateChars.End) {
              if (--stack === 0) {
                return {
                  before: scanner.text.slice(start, namePos),
                  after: scanner.text.slice(afterPos, scanner.pos++),
                  name: scanner.text.slice(namePos, afterPos)
                };
              }
            }
            scanner.pos++;
          }
        }
      }
    }
    function peek$1(scanner, pos = scanner.pos) {
      return scanner.text.charCodeAt(pos);
    }
    function isTokenStart(code2) {
      return code2 >= 65 && code2 <= 90;
    }
    function isToken(code2) {
      return isTokenStart(code2) || code2 > 47 && code2 < 58 || code2 === TemplateChars.Underscore || code2 === TemplateChars.Dash;
    }
    function createCommentState(config) {
      const { options } = config;
      return {
        enabled: options["comment.enabled"],
        trigger: options["comment.trigger"],
        before: options["comment.before"] ? template(options["comment.before"]) : void 0,
        after: options["comment.after"] ? template(options["comment.after"]) : void 0
      };
    }
    function commentNodeBefore(node, state) {
      if (shouldComment(node, state) && state.comment.before) {
        output(node, state.comment.before, state);
      }
    }
    function commentNodeAfter(node, state) {
      if (shouldComment(node, state) && state.comment.after) {
        output(node, state.comment.after, state);
      }
    }
    function shouldComment(node, state) {
      const { comment } = state;
      if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {
        return false;
      }
      for (const attr of node.attributes) {
        if (attr.name && comment.trigger.includes(attr.name)) {
          return true;
        }
      }
      return false;
    }
    function output(node, tokens, state) {
      const attrs = {};
      const { out } = state;
      for (const attr of node.attributes) {
        if (attr.name && attr.value) {
          attrs[attr.name.toUpperCase()] = attr.value;
        }
      }
      for (const token of tokens) {
        if (typeof token === "string") {
          pushString(out, token);
        } else if (attrs[token.name]) {
          pushString(out, token.before);
          pushTokens(attrs[token.name], state);
          pushString(out, token.after);
        }
      }
    }
    var htmlTagRegex = /^<([\w\-:]+)[\s>]/;
    var reservedKeywords = /* @__PURE__ */ new Set([
      "for",
      "while",
      "of",
      "async",
      "await",
      "const",
      "let",
      "var",
      "continue",
      "break",
      "debugger",
      "do",
      "export",
      "import",
      "in",
      "instanceof",
      "new",
      "return",
      "switch",
      "this",
      "throw",
      "try",
      "catch",
      "typeof",
      "void",
      "with",
      "yield"
    ]);
    function html(abbr, config) {
      const state = createWalkState(config);
      state.comment = createCommentState(config);
      walk(abbr, element$1, state);
      return state.out.value;
    }
    function element$1(node, index, items, state, next2) {
      const { out, config } = state;
      const format = shouldFormat$1(node, index, items, state);
      const level = getIndent(state);
      out.level += level;
      format && pushNewline(out, true);
      if (node.name) {
        const name = tagName(node.name, config);
        commentNodeBefore(node, state);
        pushString(out, `<${name}`);
        if (node.attributes) {
          for (const attr of node.attributes) {
            if (shouldOutputAttribute(attr)) {
              pushAttribute(attr, state);
            }
          }
        }
        if (node.selfClosing && !node.children.length && !node.value) {
          pushString(out, `${selfClose(config)}>`);
        } else {
          pushString(out, ">");
          if (!pushSnippet(node, state, next2)) {
            if (node.value) {
              const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);
              innerFormat && pushNewline(state.out, ++out.level);
              pushTokens(node.value, state);
              innerFormat && pushNewline(state.out, --out.level);
            }
            node.children.forEach(next2);
            if (!node.value && !node.children.length) {
              const innerFormat = config.options["output.formatLeafNode"] || config.options["output.formatForce"].includes(node.name);
              innerFormat && pushNewline(state.out, ++out.level);
              pushTokens(caret, state);
              innerFormat && pushNewline(state.out, --out.level);
            }
          }
          pushString(out, `</${name}>`);
          commentNodeAfter(node, state);
        }
      } else if (!pushSnippet(node, state, next2) && node.value) {
        pushTokens(node.value, state);
        node.children.forEach(next2);
      }
      if (format && index === items.length - 1 && state.parent) {
        const offset = isSnippet(state.parent) ? 0 : 1;
        pushNewline(out, out.level - offset);
      }
      out.level -= level;
    }
    function pushAttribute(attr, state) {
      const { out, config } = state;
      if (attr.name) {
        const attributes = config.options["markup.attributes"];
        const valuePrefix = config.options["markup.valuePrefix"];
        let { name, value } = attr;
        let lQuote = attrQuote(attr, config, true);
        let rQuote = attrQuote(attr, config);
        if (attributes) {
          name = getMultiValue(name, attributes, attr.multiple) || name;
        }
        name = attrName(name, config);
        if (config.options["jsx.enabled"] && attr.multiple) {
          lQuote = expressionStart;
          rQuote = expressionEnd;
        }
        const prefix = valuePrefix ? getMultiValue(attr.name, valuePrefix, attr.multiple) : null;
        if (prefix && (value === null || value === void 0 ? void 0 : value.length) === 1 && typeof value[0] === "string") {
          const val = value[0];
          value = [isPropKey(val) ? `${prefix}.${val}` : `${prefix}['${val}']`];
          if (config.options["jsx.enabled"]) {
            lQuote = expressionStart;
            rQuote = expressionEnd;
          }
        }
        if (isBooleanAttribute(attr, config) && !value) {
          if (!config.options["output.compactBoolean"]) {
            value = [name];
          }
        } else if (!value) {
          value = caret;
        }
        pushString(out, " " + name);
        if (value) {
          pushString(out, "=" + lQuote);
          pushTokens(value, state);
          pushString(out, rQuote);
        } else if (config.options["output.selfClosingStyle"] !== "html") {
          pushString(out, "=" + lQuote + rQuote);
        }
      }
    }
    function pushSnippet(node, state, next2) {
      if (node.value && node.children.length) {
        const fieldIx = node.value.findIndex(isField);
        if (fieldIx !== -1) {
          pushTokens(node.value.slice(0, fieldIx), state);
          const line = state.out.line;
          let pos = fieldIx + 1;
          node.children.forEach(next2);
          if (state.out.line !== line && typeof node.value[pos] === "string") {
            pushString(state.out, node.value[pos++].trimLeft());
          }
          pushTokens(node.value.slice(pos), state);
          return true;
        }
      }
      return false;
    }
    function shouldFormat$1(node, index, items, state) {
      const { config, parent } = state;
      if (!config.options["output.format"]) {
        return false;
      }
      if (index === 0 && !parent) {
        return false;
      }
      if (parent && isSnippet(parent) && items.length === 1) {
        return false;
      }
      if (isSnippet(node)) {
        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1]) || node.value.some(hasNewline) || node.value.some(isField) && node.children.length;
        if (format) {
          return true;
        }
      }
      if (isInline(node, config)) {
        if (index === 0) {
          for (let i = 0; i < items.length; i++) {
            if (!isInline(items[i], config)) {
              return true;
            }
          }
        } else if (!isInline(items[index - 1], config)) {
          return true;
        }
        if (config.options["output.inlineBreak"]) {
          let adjacentInline = 1;
          let before = index;
          let after = index;
          while (isInlineElement(items[--before], config)) {
            adjacentInline++;
          }
          while (isInlineElement(items[++after], config)) {
            adjacentInline++;
          }
          if (adjacentInline >= config.options["output.inlineBreak"]) {
            return true;
          }
        }
        for (let i = 0, il = node.children.length; i < il; i++) {
          if (shouldFormat$1(node.children[i], i, node.children, state)) {
            return true;
          }
        }
        return false;
      }
      return true;
    }
    function getIndent(state) {
      const { config, parent } = state;
      if (!parent || isSnippet(parent) || parent.name && config.options["output.formatSkip"].includes(parent.name)) {
        return 0;
      }
      return 1;
    }
    function hasNewline(value) {
      return typeof value === "string" && /\r|\n/.test(value);
    }
    function startsWithBlockTag(value, config) {
      if (value.length && typeof value[0] === "string") {
        const matches = htmlTagRegex.exec(value[0]);
        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options["inlineElements"].includes(matches[1].toLowerCase())) {
          return true;
        }
      }
      return false;
    }
    function getMultiValue(key, data, multiple) {
      return multiple && data[`${key}*`] || data[key];
    }
    function isPropKey(name) {
      return !reservedKeywords.has(name) && /^[a-zA-Z_$][\w_$]*$/.test(name);
    }
    function indentFormat(abbr, config, options) {
      const state = createWalkState(config);
      state.options = options || {};
      walk(abbr, element, state);
      return state.out.value;
    }
    function element(node, index, items, state, next2) {
      const { out, options } = state;
      const { primary, secondary } = collectAttributes(node);
      const level = state.parent ? 1 : 0;
      out.level += level;
      if (shouldFormat(node, index, items, state)) {
        pushNewline(out, true);
      }
      if (node.name && (node.name !== "div" || !primary.length)) {
        pushString(out, (options.beforeName || "") + node.name + (options.afterName || ""));
      }
      pushPrimaryAttributes(primary, state);
      pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);
      if (node.selfClosing && !node.value && !node.children.length) {
        if (state.options.selfClose) {
          pushString(out, state.options.selfClose);
        }
      } else {
        pushValue(node, state);
        node.children.forEach(next2);
      }
      out.level -= level;
    }
    function collectAttributes(node) {
      const primary = [];
      const secondary = [];
      if (node.attributes) {
        for (const attr of node.attributes) {
          if (isPrimaryAttribute(attr)) {
            primary.push(attr);
          } else {
            secondary.push(attr);
          }
        }
      }
      return { primary, secondary };
    }
    function pushPrimaryAttributes(attrs, state) {
      for (const attr of attrs) {
        if (attr.value) {
          if (attr.name === "class") {
            pushString(state.out, ".");
            const tokens = attr.value.map((t) => typeof t === "string" ? t.replace(/\s+/g, ".") : t);
            pushTokens(tokens, state);
          } else {
            pushString(state.out, "#");
            pushTokens(attr.value, state);
          }
        }
      }
    }
    function pushSecondaryAttributes(attrs, state) {
      if (attrs.length) {
        const { out, config, options } = state;
        options.beforeAttribute && pushString(out, options.beforeAttribute);
        for (let i = 0; i < attrs.length; i++) {
          const attr = attrs[i];
          pushString(out, attrName(attr.name || "", config));
          if (isBooleanAttribute(attr, config) && !attr.value) {
            if (!config.options["output.compactBoolean"] && options.booleanValue) {
              pushString(out, "=" + options.booleanValue);
            }
          } else {
            pushString(out, "=" + attrQuote(attr, config, true));
            pushTokens(attr.value || caret, state);
            pushString(out, attrQuote(attr, config));
          }
          if (i !== attrs.length - 1 && options.glueAttribute) {
            pushString(out, options.glueAttribute);
          }
        }
        options.afterAttribute && pushString(out, options.afterAttribute);
      }
    }
    function pushValue(node, state) {
      if (!node.value && node.children.length) {
        return;
      }
      const value = node.value || caret;
      const lines = splitByLines(value);
      const { out, options } = state;
      if (lines.length === 1) {
        if (node.name || node.attributes) {
          push(out, " ");
        }
        pushTokens(value, state);
      } else {
        const lineLengths = [];
        let maxLength = 0;
        for (const line of lines) {
          const len = valueLength(line);
          lineLengths.push(len);
          if (len > maxLength) {
            maxLength = len;
          }
        }
        out.level++;
        for (let i = 0; i < lines.length; i++) {
          pushNewline(out, true);
          options.beforeTextLine && push(out, options.beforeTextLine);
          pushTokens(lines[i], state);
          if (options.afterTextLine) {
            push(out, " ".repeat(maxLength - lineLengths[i]));
            push(out, options.afterTextLine);
          }
        }
        out.level--;
      }
    }
    function isPrimaryAttribute(attr) {
      return attr.name === "class" || attr.name === "id";
    }
    function valueLength(tokens) {
      let len = 0;
      for (const token of tokens) {
        len += typeof token === "string" ? token.length : token.name.length;
      }
      return len;
    }
    function shouldFormat(node, index, items, state) {
      if (!state.parent && index === 0) {
        return false;
      }
      return !isSnippet(node);
    }
    function haml(abbr, config) {
      return indentFormat(abbr, config, {
        beforeName: "%",
        beforeAttribute: "(",
        afterAttribute: ")",
        glueAttribute: " ",
        afterTextLine: " |",
        booleanValue: "true",
        selfClose: "/"
      });
    }
    function slim(abbr, config) {
      return indentFormat(abbr, config, {
        beforeAttribute: " ",
        glueAttribute: " ",
        beforeTextLine: "| ",
        selfClose: "/"
      });
    }
    function pug(abbr, config) {
      return indentFormat(abbr, config, {
        beforeAttribute: "(",
        afterAttribute: ")",
        glueAttribute: ", ",
        beforeTextLine: "| ",
        selfClose: config.options["output.selfClosingStyle"] === "xml" ? "/" : ""
      });
    }
    var formatters = { html, haml, slim, pug };
    function parse$1(abbr, config) {
      let oldTextValue;
      if (typeof abbr === "string") {
        const parseOpt = Object.assign({}, config);
        if (config.options["jsx.enabled"]) {
          parseOpt.jsx = true;
        }
        if (config.options["markup.href"]) {
          parseOpt.href = true;
        }
        abbr = parseAbbreviation(abbr, parseOpt);
        oldTextValue = config.text;
        config.text = void 0;
      }
      abbr = resolveSnippets(abbr, config);
      walk$1(abbr, transform, config);
      config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;
      return abbr;
    }
    function stringify(abbr, config) {
      const formatter = formatters[config.syntax] || html;
      return formatter(abbr, config);
    }
    function transform(node, ancestors, config) {
      implicitTag(node, ancestors, config);
      mergeAttributes(node, config);
      lorem(node, ancestors, config);
      if (config.syntax === "xsl") {
        xsl(node);
      }
      if (config.type === "markup") {
        label(node);
      }
      if (config.options["bem.enabled"]) {
        bem(node, ancestors, config);
      }
    }
    var CSSSnippetType;
    (function(CSSSnippetType2) {
      CSSSnippetType2["Raw"] = "Raw";
      CSSSnippetType2["Property"] = "Property";
    })(CSSSnippetType || (CSSSnippetType = {}));
    var reProperty = /^([a-z-]+)(?:\s*:\s*([^\n\r;]+?);*)?$/;
    var opt = { value: true };
    function createSnippet(key, value) {
      const m = value.match(reProperty);
      if (m) {
        const keywords = {};
        const parsed = m[2] ? m[2].split("|").map(parseValue) : [];
        for (const item of parsed) {
          for (const cssVal of item) {
            collectKeywords(cssVal, keywords);
          }
        }
        return {
          type: CSSSnippetType.Property,
          key,
          property: m[1],
          value: parsed,
          keywords,
          dependencies: []
        };
      }
      return { type: CSSSnippetType.Raw, key, value };
    }
    function nest(snippets) {
      snippets = snippets.slice().sort(snippetsSort);
      const stack = [];
      let prev;
      for (const cur of snippets.filter(isProperty)) {
        while (stack.length) {
          prev = stack[stack.length - 1];
          if (cur.property.startsWith(prev.property) && cur.property.charCodeAt(prev.property.length) === 45) {
            prev.dependencies.push(cur);
            stack.push(cur);
            break;
          }
          stack.pop();
        }
        if (!stack.length) {
          stack.push(cur);
        }
      }
      return snippets;
    }
    function snippetsSort(a, b) {
      if (a.key === b.key) {
        return 0;
      }
      return a.key < b.key ? -1 : 1;
    }
    function parseValue(value) {
      return parse$2(value.trim(), opt)[0].value;
    }
    function isProperty(snippet) {
      return snippet.type === CSSSnippetType.Property;
    }
    function collectKeywords(cssVal, dest) {
      for (const v of cssVal.value) {
        if (v.type === "Literal") {
          dest[v.value] = v;
        } else if (v.type === "FunctionCall") {
          dest[v.name] = v;
        } else if (v.type === "Field") {
          const value = v.name.trim();
          if (value) {
            dest[value] = { type: "Literal", value };
          }
        }
      }
    }
    function scoreMatch(str1, str2, partialMatch = false) {
      str1 = str1.toLowerCase();
      str2 = str2.toLowerCase();
      if (str1 === str2) {
        return 1;
      }
      if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {
        return 0;
      }
      const str1Len = str1.length;
      const str2Len = str2.length;
      if (!partialMatch && str1Len > str2Len) {
        return 0;
      }
      const minLength = Math.min(str1Len, str2Len);
      const maxLength = Math.max(str1Len, str2Len);
      let i = 1;
      let j = 1;
      let score = maxLength;
      let ch1 = 0;
      let ch2 = 0;
      let found = false;
      let acronym = false;
      while (i < str1Len) {
        ch1 = str1.charCodeAt(i);
        found = false;
        acronym = false;
        while (j < str2Len) {
          ch2 = str2.charCodeAt(j);
          if (ch1 === ch2) {
            found = true;
            score += maxLength - (acronym ? i : j);
            break;
          }
          acronym = ch2 === 45;
          j++;
        }
        if (!found) {
          if (!partialMatch) {
            return 0;
          }
          break;
        }
        i++;
      }
      const matchRatio = i / maxLength;
      const delta = maxLength - minLength;
      const maxScore = sum(maxLength) - sum(delta);
      return score * matchRatio / maxScore;
    }
    function sum(n) {
      return n * (n + 1) / 2;
    }
    function color(token, shortHex) {
      if (!token.r && !token.g && !token.b && !token.a) {
        return "transparent";
      } else if (token.a === 1) {
        return asHex(token, shortHex);
      }
      return asRGB(token);
    }
    function asHex(token, short) {
      const fn = short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b) ? toShortHex : toHex;
      return "#" + fn(token.r) + fn(token.g) + fn(token.b);
    }
    function asRGB(token) {
      const values = [token.r, token.g, token.b];
      if (token.a !== 1) {
        values.push(frac(token.a, 8));
      }
      return `${values.length === 3 ? "rgb" : "rgba"}(${values.join(", ")})`;
    }
    function frac(num, digits = 4) {
      return num.toFixed(digits).replace(/\.?0+$/, "");
    }
    function isShortHex(hex) {
      return !(hex % 17);
    }
    function toShortHex(num) {
      return (num >> 4).toString(16);
    }
    function toHex(num) {
      return pad(num.toString(16), 2);
    }
    function pad(value, len) {
      while (value.length < len) {
        value = "0" + value;
      }
      return value;
    }
    var CSSAbbreviationScope = {
      /** Include all possible snippets in match */
      Global: "@@global",
      /** Include raw snippets only (e.g. no properties) in abbreviation match */
      Section: "@@section",
      /** Include properties only in abbreviation match */
      Property: "@@property",
      /** Resolve abbreviation in context of CSS property value */
      Value: "@@value"
    };
    function css(abbr, config) {
      var _a;
      const out = createOutputStream(config.options);
      const format = config.options["output.format"];
      if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === CSSAbbreviationScope.Section) {
        abbr = abbr.filter((node) => node.snippet);
      }
      for (let i = 0; i < abbr.length; i++) {
        if (format && i !== 0) {
          pushNewline(out, true);
        }
        property(abbr[i], out, config);
      }
      return out.value;
    }
    function property(node, out, config) {
      const isJSON = config.options["stylesheet.json"];
      if (node.name) {
        const name = isJSON ? toCamelCase(node.name) : node.name;
        pushString(out, name + config.options["stylesheet.between"]);
        if (node.value.length) {
          propertyValue(node, out, config);
        } else {
          pushField(out, 0, "");
        }
        if (isJSON) {
          push(out, ",");
        } else {
          outputImportant(node, out, true);
          push(out, config.options["stylesheet.after"]);
        }
      } else {
        for (const cssVal of node.value) {
          for (const v of cssVal.value) {
            outputToken(v, out, config);
          }
        }
        outputImportant(node, out, node.value.length > 0);
      }
    }
    function propertyValue(node, out, config) {
      const isJSON = config.options["stylesheet.json"];
      const num = isJSON ? getSingleNumeric(node) : null;
      if (num && (!num.unit || num.unit === "px")) {
        push(out, String(num.value));
      } else {
        const quote2 = getQuote(config);
        isJSON && push(out, quote2);
        for (let i = 0; i < node.value.length; i++) {
          if (i !== 0) {
            push(out, ", ");
          }
          outputValue(node.value[i], out, config);
        }
        isJSON && push(out, quote2);
      }
    }
    function outputImportant(node, out, separator) {
      if (node.important) {
        if (separator) {
          push(out, " ");
        }
        push(out, "!important");
      }
    }
    function outputValue(value, out, config) {
      for (let i = 0, prevEnd = -1; i < value.value.length; i++) {
        const token = value.value[i];
        if (i !== 0 && (token.type !== "Field" || token.start !== prevEnd)) {
          push(out, " ");
        }
        outputToken(token, out, config);
        prevEnd = token["end"];
      }
    }
    function outputToken(token, out, config) {
      if (token.type === "ColorValue") {
        push(out, color(token, config.options["stylesheet.shortHex"]));
      } else if (token.type === "Literal" || token.type === "CustomProperty") {
        pushString(out, token.value);
      } else if (token.type === "NumberValue") {
        pushString(out, frac(token.value, 4) + token.unit);
      } else if (token.type === "StringValue") {
        const quote2 = token.quote === "double" ? '"' : "'";
        pushString(out, quote2 + token.value + quote2);
      } else if (token.type === "Field") {
        pushField(out, token.index, token.name);
      } else if (token.type === "FunctionCall") {
        push(out, token.name + "(");
        for (let i = 0; i < token.arguments.length; i++) {
          if (i) {
            push(out, ", ");
          }
          outputValue(token.arguments[i], out, config);
        }
        push(out, ")");
      }
    }
    function getSingleNumeric(node) {
      if (node.value.length === 1) {
        const cssVal = node.value[0];
        if (cssVal.value.length === 1 && cssVal.value[0].type === "NumberValue") {
          return cssVal.value[0];
        }
      }
    }
    function toCamelCase(str) {
      return str.replace(/\-(\w)/g, (_, letter) => letter.toUpperCase());
    }
    function getQuote(config) {
      return config.options["stylesheet.jsonDoubleQuotes"] ? '"' : "'";
    }
    var gradientName = "lg";
    function parse(abbr, config) {
      var _a;
      const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);
      const result = [];
      if (config.cache) {
        config.cache.stylesheetSnippets = snippets;
      }
      if (typeof abbr === "string") {
        abbr = parse$2(abbr, { value: isValueScope(config) });
      }
      const filteredSnippets = getSnippetsForScope(snippets, config);
      for (const node of abbr) {
        const resolved = resolveNode(node, filteredSnippets, config);
        if (resolved) {
          result.push(resolved);
        }
      }
      return result;
    }
    function convertSnippets(snippets) {
      const result = [];
      for (const key of Object.keys(snippets)) {
        result.push(createSnippet(key, snippets[key]));
      }
      return nest(result);
    }
    function resolveNode(node, snippets, config) {
      if (!resolveGradient(node, config)) {
        const score = config.options["stylesheet.fuzzySearchMinScore"];
        if (isValueScope(config)) {
          const propName = config.context.name;
          const snippet = snippets.find((s) => s.type === CSSSnippetType.Property && s.property === propName);
          resolveValueKeywords(node, config, snippet, score);
          node.snippet = snippet;
        } else if (node.name) {
          const snippet = findBestMatch(node.name, snippets, score, true);
          node.snippet = snippet;
          if (snippet) {
            const resolved = snippet.type === CSSSnippetType.Property ? resolveAsProperty(node, snippet, config) : resolveAsSnippet(node, snippet);
            if (resolved) {
              node = resolved;
            } else if (config.options["stylesheet.strictMatch"]) {
              return null;
            }
          }
        }
      }
      if (node.name || config.context) {
        resolveNumericValue(node, config);
      }
      return node;
    }
    function resolveGradient(node, config) {
      let gradientFn = null;
      const cssVal = node.value.length === 1 ? node.value[0] : null;
      if (cssVal && cssVal.value.length === 1) {
        const v = cssVal.value[0];
        if (v.type === "FunctionCall" && v.name === gradientName) {
          gradientFn = v;
        }
      }
      if (gradientFn || node.name === gradientName) {
        if (!gradientFn) {
          gradientFn = {
            type: "FunctionCall",
            name: "linear-gradient",
            arguments: [cssValue(field(0, ""))]
          };
        } else {
          gradientFn = Object.assign(Object.assign({}, gradientFn), { name: "linear-gradient" });
        }
        if (!config.context) {
          node.name = "background-image";
        }
        node.value = [cssValue(gradientFn)];
        return true;
      }
      return false;
    }
    function resolveAsProperty(node, snippet, config) {
      const abbr = node.name;
      const inlineValue = getUnmatchedPart(abbr, snippet.key);
      if (inlineValue) {
        if (node.value.length) {
          return null;
        }
        const kw = resolveKeyword(inlineValue, config, snippet);
        if (!kw) {
          return null;
        }
        node.value.push(cssValue(kw));
      }
      node.name = snippet.property;
      if (node.value.length) {
        resolveValueKeywords(node, config, snippet);
      } else if (snippet.value.length) {
        const defaultValue = snippet.value[0];
        node.value = snippet.value.length === 1 || defaultValue.some(hasField) ? defaultValue : defaultValue.map((n) => wrapWithField(n, config));
      }
      return node;
    }
    function resolveValueKeywords(node, config, snippet, minScore) {
      for (const cssVal of node.value) {
        const value = [];
        for (const token of cssVal.value) {
          if (token.type === "Literal") {
            value.push(resolveKeyword(token.value, config, snippet, minScore) || token);
          } else if (token.type === "FunctionCall") {
            const match = resolveKeyword(token.name, config, snippet, minScore);
            if (match && match.type === "FunctionCall") {
              value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));
            } else {
              value.push(token);
            }
          } else {
            value.push(token);
          }
        }
        cssVal.value = value;
      }
    }
    function resolveAsSnippet(node, snippet) {
      let offset = 0;
      let m;
      const reField = /\$\{(\d+)(:[^}]+)?\}/g;
      const inputValue = node.value[0];
      const outputValue2 = [];
      while (m = reField.exec(snippet.value)) {
        if (offset !== m.index) {
          outputValue2.push(literal(snippet.value.slice(offset, m.index)));
        }
        offset = m.index + m[0].length;
        if (inputValue && inputValue.value.length) {
          outputValue2.push(inputValue.value.shift());
        } else {
          outputValue2.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ""));
        }
      }
      const tail = snippet.value.slice(offset);
      if (tail) {
        outputValue2.push(literal(tail));
      }
      node.name = void 0;
      node.value = [cssValue(...outputValue2)];
      return node;
    }
    function findBestMatch(abbr, items, minScore = 0, partialMatch = false) {
      let matchedItem = null;
      let maxScore = 0;
      for (const item of items) {
        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);
        if (score === 1) {
          return item;
        }
        if (score && score >= maxScore) {
          maxScore = score;
          matchedItem = item;
        }
      }
      return maxScore >= minScore ? matchedItem : null;
    }
    function getScoringPart(item) {
      return typeof item === "string" ? item : item.key;
    }
    function getUnmatchedPart(abbr, str) {
      for (let i = 0, lastPos = 0; i < abbr.length; i++) {
        lastPos = str.indexOf(abbr[i], lastPos);
        if (lastPos === -1) {
          return abbr.slice(i);
        }
        lastPos++;
      }
      return "";
    }
    function resolveKeyword(kw, config, snippet, minScore) {
      let ref;
      if (snippet) {
        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {
          return snippet.keywords[ref];
        }
        for (const dep of snippet.dependencies) {
          if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {
            return dep.keywords[ref];
          }
        }
      }
      if (ref = findBestMatch(kw, config.options["stylesheet.keywords"], minScore)) {
        return literal(ref);
      }
      return null;
    }
    function resolveNumericValue(node, config) {
      const aliases = config.options["stylesheet.unitAliases"];
      const unitless = config.options["stylesheet.unitless"];
      for (const v of node.value) {
        for (const t of v.value) {
          if (t.type === "NumberValue") {
            if (t.unit) {
              t.unit = aliases[t.unit] || t.unit;
            } else if (t.value !== 0 && !unitless.includes(node.name)) {
              t.unit = t.rawValue.includes(".") ? config.options["stylesheet.floatUnit"] : config.options["stylesheet.intUnit"];
            }
          }
        }
      }
    }
    function cssValue(...args) {
      return {
        type: "CSSValue",
        value: args
      };
    }
    function literal(value) {
      return { type: "Literal", value };
    }
    function field(index, name) {
      return { type: "Field", index, name };
    }
    function hasField(value) {
      for (const v of value.value) {
        if (v.type === "Field" || v.type === "FunctionCall" && v.arguments.some(hasField)) {
          return true;
        }
      }
      return false;
    }
    function wrapWithField(node, config, state = { index: 1 }) {
      let value = [];
      for (const v of node.value) {
        switch (v.type) {
          case "ColorValue":
            value.push(field(state.index++, color(v, config.options["stylesheet.shortHex"])));
            break;
          case "Literal":
            value.push(field(state.index++, v.value));
            break;
          case "NumberValue":
            value.push(field(state.index++, `${v.value}${v.unit}`));
            break;
          case "StringValue":
            const q = v.quote === "single" ? "'" : '"';
            value.push(field(state.index++, q + v.value + q));
            break;
          case "FunctionCall":
            value.push(field(state.index++, v.name), literal("("));
            for (let i = 0, il = v.arguments.length; i < il; i++) {
              value = value.concat(wrapWithField(v.arguments[i], config, state).value);
              if (i !== il - 1) {
                value.push(literal(", "));
              }
            }
            value.push(literal(")"));
            break;
          default:
            value.push(v);
        }
      }
      return Object.assign(Object.assign({}, node), { value });
    }
    function isValueScope(config) {
      if (config.context) {
        return config.context.name === CSSAbbreviationScope.Value || !config.context.name.startsWith("@@");
      }
      return false;
    }
    function getSnippetsForScope(snippets, config) {
      if (config.context) {
        if (config.context.name === CSSAbbreviationScope.Section) {
          return snippets.filter((s) => s.type === CSSSnippetType.Raw);
        }
        if (config.context.name === CSSAbbreviationScope.Property) {
          return snippets.filter((s) => s.type === CSSSnippetType.Property);
        }
      }
      return snippets;
    }
    var markupSnippets = {
      "a": "a[href]",
      "a:blank": "a[href='http://${0}' target='_blank' rel='noopener noreferrer']",
      "a:link": "a[href='http://${0}']",
      "a:mail": "a[href='mailto:${0}']",
      "a:tel": "a[href='tel:+${0}']",
      "abbr": "abbr[title]",
      "acr|acronym": "acronym[title]",
      "base": "base[href]/",
      "basefont": "basefont/",
      "br": "br/",
      "frame": "frame/",
      "hr": "hr/",
      "bdo": "bdo[dir]",
      "bdo:r": "bdo[dir=rtl]",
      "bdo:l": "bdo[dir=ltr]",
      "col": "col/",
      "link": "link[rel=stylesheet href]/",
      "link:css": "link[href='${1:style}.css']",
      "link:print": "link[href='${1:print}.css' media=print]",
      "link:favicon": "link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']",
      "link:mf|link:manifest": "link[rel='manifest' href='${1:manifest.json}']",
      "link:touch": "link[rel=apple-touch-icon href='${1:favicon.png}']",
      "link:rss": "link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']",
      "link:atom": "link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']",
      "link:im|link:import": "link[rel=import href='${1:component}.html']",
      "meta": "meta/",
      "meta:utf": "meta[http-equiv=Content-Type content='text/html;charset=UTF-8']",
      "meta:vp": "meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']",
      "meta:compat": "meta[http-equiv=X-UA-Compatible content='${1:IE=7}']",
      "meta:edge": "meta:compat[content='${1:ie=edge}']",
      "meta:redirect": "meta[http-equiv=refresh content='0; url=${1:http://example.com}']",
      "meta:refresh": "meta[http-equiv=refresh content='${1:5}']",
      "meta:kw": "meta[name=keywords content]",
      "meta:desc": "meta[name=description content]",
      "style": "style",
      "script": "script",
      "script:src": "script[src]",
      "script:module": "script[type=module src]",
      "img": "img[src alt]/",
      "img:s|img:srcset": "img[srcset src alt]",
      "img:z|img:sizes": "img[sizes srcset src alt]",
      "picture": "picture",
      "src|source": "source/",
      "src:sc|source:src": "source[src type]",
      "src:s|source:srcset": "source[srcset]",
      "src:t|source:type": "source[srcset type='${1:image/}']",
      "src:z|source:sizes": "source[sizes srcset]",
      "src:m|source:media": "source[media='(${1:min-width: })' srcset]",
      "src:mt|source:media:type": "source:media[type='${2:image/}']",
      "src:mz|source:media:sizes": "source:media[sizes srcset]",
      "src:zt|source:sizes:type": "source[sizes srcset type='${1:image/}']",
      "iframe": "iframe[src frameborder=0]",
      "embed": "embed[src type]/",
      "object": "object[data type]",
      "param": "param[name value]/",
      "map": "map[name]",
      "area": "area[shape coords href alt]/",
      "area:d": "area[shape=default]",
      "area:c": "area[shape=circle]",
      "area:r": "area[shape=rect]",
      "area:p": "area[shape=poly]",
      "form": "form[action]",
      "form:get": "form[method=get]",
      "form:post": "form[method=post]",
      "label": "label[for]",
      "input": "input[type=${1:text}]/",
      "inp": "input[name=${1} id=${1}]",
      "input:h|input:hidden": "input[type=hidden name]",
      "input:t|input:text": "inp[type=text]",
      "input:search": "inp[type=search]",
      "input:email": "inp[type=email]",
      "input:url": "inp[type=url]",
      "input:p|input:password": "inp[type=password]",
      "input:datetime": "inp[type=datetime]",
      "input:date": "inp[type=date]",
      "input:datetime-local": "inp[type=datetime-local]",
      "input:month": "inp[type=month]",
      "input:week": "inp[type=week]",
      "input:time": "inp[type=time]",
      "input:tel": "inp[type=tel]",
      "input:number": "inp[type=number]",
      "input:color": "inp[type=color]",
      "input:c|input:checkbox": "inp[type=checkbox]",
      "input:r|input:radio": "inp[type=radio]",
      "input:range": "inp[type=range]",
      "input:f|input:file": "inp[type=file]",
      "input:s|input:submit": "input[type=submit value]",
      "input:i|input:image": "input[type=image src alt]",
      "input:b|input:btn|input:button": "input[type=button value]",
      "input:reset": "input:button[type=reset]",
      "isindex": "isindex/",
      "select": "select[name=${1} id=${1}]",
      "select:d|select:disabled": "select[disabled.]",
      "opt|option": "option[value]",
      "textarea": "textarea[name=${1} id=${1}]",
      "tarea:c|textarea:cols": "textarea[name=${1} id=${1} cols=${2:30}]",
      "tarea:r|textarea:rows": "textarea[name=${1} id=${1} rows=${3:10}]",
      "tarea:cr|textarea:cols:rows": "textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]",
      "marquee": "marquee[behavior direction]",
      "menu:c|menu:context": "menu[type=context]",
      "menu:t|menu:toolbar": "menu[type=toolbar]",
      "video": "video[src]",
      "audio": "audio[src]",
      "html:xml": "html[xmlns=http://www.w3.org/1999/xhtml]",
      "keygen": "keygen/",
      "command": "command/",
      "btn:s|button:s|button:submit": "button[type=submit]",
      "btn:r|button:r|button:reset": "button[type=reset]",
      "btn:b|button:b|button:button": "button[type=button]",
      "btn:d|button:d|button:disabled": "button[disabled.]",
      "fst:d|fset:d|fieldset:d|fieldset:disabled": "fieldset[disabled.]",
      "bq": "blockquote",
      "fig": "figure",
      "figc": "figcaption",
      "pic": "picture",
      "ifr": "iframe",
      "emb": "embed",
      "obj": "object",
      "cap": "caption",
      "colg": "colgroup",
      "fst": "fieldset",
      "btn": "button",
      "optg": "optgroup",
      "tarea": "textarea",
      "leg": "legend",
      "sect": "section",
      "art": "article",
      "hdr": "header",
      "ftr": "footer",
      "adr": "address",
      "dlg": "dialog",
      "str": "strong",
      "prog": "progress",
      "mn": "main",
      "tem": "template",
      "fset": "fieldset",
      "datal": "datalist",
      "kg": "keygen",
      "out": "output",
      "det": "details",
      "sum": "summary",
      "cmd": "command",
      "data": "data[value]",
      "meter": "meter[value]",
      "time": "time[datetime]",
      "ri:d|ri:dpr": "img:s",
      "ri:v|ri:viewport": "img:z",
      "ri:a|ri:art": "pic>src:m+img",
      "ri:t|ri:type": "pic>src:t+img",
      "!!!": "{<!DOCTYPE html>}",
      "doc": "html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body",
      "!|html:5": "!!!+doc",
      "c": "{<!-- ${0} -->}",
      "cc:ie": "{<!--[if IE]>${0}<![endif]-->}",
      "cc:noie": "{<!--[if !IE]><!-->${0}<!--<![endif]-->}"
    };
    var stylesheetSnippets = {
      "@f": "@font-face {\n	font-family: ${1};\n	src: url(${2});\n}",
      "@ff": "@font-face {\n	font-family: '${1:FontName}';\n	src: url('${2:FileName}.eot');\n	src: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\n		 url('${2:FileName}.woff') format('woff'),\n		 url('${2:FileName}.ttf') format('truetype'),\n		 url('${2:FileName}.svg#${1:FontName}') format('svg');\n	font-style: ${3:normal};\n	font-weight: ${4:normal};\n}",
      "@i|@import": "@import url(${0});",
      "@kf": "@keyframes ${1:identifier} {\n	${2}\n}",
      "@m|@media": "@media ${1:screen} {\n	${0}\n}",
      "ac": "align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly",
      "ai": "align-items:start|end|flex-start|flex-end|center|baseline|stretch",
      "anim": "animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}",
      "animdel": "animation-delay:time",
      "animdir": "animation-direction:normal|reverse|alternate|alternate-reverse",
      "animdur": "animation-duration:${1:0}s",
      "animfm": "animation-fill-mode:both|forwards|backwards",
      "animic": "animation-iteration-count:1|infinite",
      "animn": "animation-name",
      "animps": "animation-play-state:running|paused",
      "animtf": "animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})",
      "ap": "appearance:none",
      "as": "align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch",
      "b": "bottom",
      "bd": "border:${1:1px} ${2:solid} ${3:#000}",
      "bdb": "border-bottom:${1:1px} ${2:solid} ${3:#000}",
      "bdbc": "border-bottom-color:${1:#000}",
      "bdbi": "border-bottom-image:url(${0})",
      "bdbk": "border-break:close",
      "bdbli": "border-bottom-left-image:url(${0})|continue",
      "bdblrs": "border-bottom-left-radius",
      "bdbri": "border-bottom-right-image:url(${0})|continue",
      "bdbrrs": "border-bottom-right-radius",
      "bdbs": "border-bottom-style",
      "bdbw": "border-bottom-width",
      "bdc": "border-color:${1:#000}",
      "bdci": "border-corner-image:url(${0})|continue",
      "bdcl": "border-collapse:collapse|separate",
      "bdf": "border-fit:repeat|clip|scale|stretch|overwrite|overflow|space",
      "bdi": "border-image:url(${0})",
      "bdl": "border-left:${1:1px} ${2:solid} ${3:#000}",
      "bdlc": "border-left-color:${1:#000}",
      "bdlen": "border-length",
      "bdli": "border-left-image:url(${0})",
      "bdls": "border-left-style",
      "bdlw": "border-left-width",
      "bdr": "border-right:${1:1px} ${2:solid} ${3:#000}",
      "bdrc": "border-right-color:${1:#000}",
      "bdri": "border-right-image:url(${0})",
      "bdrs": "border-radius",
      "bdrst": "border-right-style",
      "bdrw": "border-right-width",
      "bds": "border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset",
      "bdsp": "border-spacing",
      "bdt": "border-top:${1:1px} ${2:solid} ${3:#000}",
      "bdtc": "border-top-color:${1:#000}",
      "bdti": "border-top-image:url(${0})",
      "bdtli": "border-top-left-image:url(${0})|continue",
      "bdtlrs": "border-top-left-radius",
      "bdtri": "border-top-right-image:url(${0})|continue",
      "bdtrrs": "border-top-right-radius",
      "bdts": "border-top-style",
      "bdtw": "border-top-width",
      "bdw": "border-width",
      "bbs": "border-block-start",
      "bbe": "border-block-end",
      "bis": "border-inline-start",
      "bie": "border-inline-end",
      "bfv": "backface-visibility:hidden|visible",
      "bg": "background:${1:#000}",
      "bg:n": "background: none",
      "bga": "background-attachment:fixed|scroll",
      "bgbk": "background-break:bounding-box|each-box|continuous",
      "bgc": "background-color:${1:#fff}",
      "bgcp": "background-clip:padding-box|border-box|content-box|no-clip",
      "bgi": "background-image:url(${0})",
      "bgo": "background-origin:padding-box|border-box|content-box",
      "bgp": "background-position:${1:0} ${2:0}",
      "bgpx": "background-position-x",
      "bgpy": "background-position-y",
      "bgr": "background-repeat:no-repeat|repeat-x|repeat-y|space|round",
      "bgsz": "background-size:contain|cover",
      "bs": "block-size",
      "bxsh": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none",
      "bxsz": "box-sizing:border-box|content-box|border-box",
      "c": "color:${1:#000}",
      "cg": "column-gap",
      "cr": "color:rgb(${1:0}, ${2:0}, ${3:0})",
      "cra": "color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})",
      "cl": "clear:both|left|right|none",
      "cm": "/* ${0} */",
      "cnt": "content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})",
      "coi": "counter-increment",
      "colm": "columns",
      "colmc": "column-count",
      "colmf": "column-fill",
      "colmg": "column-gap",
      "colmr": "column-rule",
      "colmrc": "column-rule-color",
      "colmrs": "column-rule-style",
      "colmrw": "column-rule-width",
      "colms": "column-span",
      "colmw": "column-width",
      "cor": "counter-reset",
      "cp": "clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})",
      "cps": "caption-side:top|bottom",
      "cur": "cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text",
      "d": "display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|contents|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group",
      "ec": "empty-cells:show|hide",
      "f": "font:${1:1em} ${2:sans-serif}",
      "fd": "font-display:auto|block|swap|fallback|optional",
      "fef": "font-effect:none|engrave|emboss|outline",
      "fem": "font-emphasize",
      "femp": "font-emphasize-position:before|after",
      "fems": "font-emphasize-style:none|accent|dot|circle|disc",
      "ff": "font-family:serif|sans-serif|cursive|fantasy|monospace",
      "fft": 'font-family:"Times New Roman", Times, Baskerville, Georgia, serif',
      "ffa": 'font-family:Arial, "Helvetica Neue", Helvetica, sans-serif',
      "ffv": "font-family:Verdana, Geneva, sans-serif",
      "fl": "float:left|right|none",
      "fs": "font-style:italic|normal|oblique",
      "fsm": "font-smoothing:antialiased|subpixel-antialiased|none",
      "fst": "font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded",
      "fv": "font-variant:normal|small-caps",
      "fvs": "font-variation-settings:normal|inherit|initial|unset",
      "fw": "font-weight:normal|bold|bolder|lighter",
      "fx": "flex",
      "fxb": "flex-basis:fill|max-content|min-content|fit-content|content",
      "fxd": "flex-direction:row|row-reverse|column|column-reverse",
      "fxf": "flex-flow",
      "fxg": "flex-grow",
      "fxsh": "flex-shrink",
      "fxw": "flex-wrap:nowrap|wrap|wrap-reverse",
      "fsz": "font-size",
      "fsza": "font-size-adjust",
      "g": "gap",
      "gtc": "grid-template-columns:repeat(${0})|minmax()",
      "gtr": "grid-template-rows:repeat(${0})|minmax()",
      "gta": "grid-template-areas",
      "gt": "grid-template",
      "gg": "grid-gap",
      "gcg": "grid-column-gap",
      "grg": "grid-row-gap",
      "gac": "grid-auto-columns:auto|minmax()",
      "gar": "grid-auto-rows:auto|minmax()",
      "gaf": "grid-auto-flow:row|column|dense|inherit|initial|unset",
      "gd": "grid",
      "gc": "grid-column",
      "gcs": "grid-column-start",
      "gce": "grid-column-end",
      "gr": "grid-row",
      "grs": "grid-row-start",
      "gre": "grid-row-end",
      "ga": "grid-area",
      "h": "height",
      "is": "inline-size",
      "jc": "justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly",
      "ji": "justify-items:start|end|center|stretch",
      "js": "justify-self:start|end|center|stretch",
      "l": "left",
      "lg": "background-image:linear-gradient(${1})",
      "lh": "line-height",
      "lis": "list-style",
      "lisi": "list-style-image",
      "lisp": "list-style-position:inside|outside",
      "list": "list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman",
      "lts": "letter-spacing:normal",
      "m": "margin",
      "mah": "max-height",
      "mar": "max-resolution",
      "maw": "max-width",
      "mb": "margin-bottom",
      "mih": "min-height",
      "mir": "min-resolution",
      "miw": "min-width",
      "ml": "margin-left",
      "mr": "margin-right",
      "mt": "margin-top",
      "mbs": "margin-block-start",
      "mbe": "margin-block-end",
      "mis": "margin-inline-start",
      "mie": "margin-inline-end",
      "ol": "outline",
      "olc": "outline-color:${1:#000}|invert",
      "olo": "outline-offset",
      "ols": "outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset",
      "olw": "outline-width:thin|medium|thick",
      "op|opa": "opacity",
      "ord": "order",
      "ori": "orientation:landscape|portrait",
      "orp": "orphans",
      "ov": "overflow:hidden|visible|hidden|scroll|auto",
      "ovs": "overflow-style:scrollbar|auto|scrollbar|panner|move|marquee",
      "ovx": "overflow-x:hidden|visible|hidden|scroll|auto",
      "ovy": "overflow-y:hidden|visible|hidden|scroll|auto",
      "p": "padding",
      "pb": "padding-bottom",
      "pgba": "page-break-after:auto|always|left|right",
      "pgbb": "page-break-before:auto|always|left|right",
      "pgbi": "page-break-inside:auto|avoid",
      "pl": "padding-left",
      "pos": "position:relative|absolute|relative|fixed|static",
      "pr": "padding-right",
      "pt": "padding-top",
      "pbs": "padding-block-start",
      "pbe": "padding-block-end",
      "pis": "padding-inline-start",
      "pie": "padding-inline-end",
      "spbs": "scroll-padding-block-start",
      "spbe": "scroll-padding-block-end",
      "spis": "scroll-padding-inline-start",
      "spie": "scroll-padding-inline-end",
      "q": "quotes",
      "qen": "quotes:'\\201C' '\\201D' '\\2018' '\\2019'",
      "qru": "quotes:'\\00AB' '\\00BB' '\\201E' '\\201C'",
      "r": "right",
      "rg": "row-gap",
      "rsz": "resize:none|both|horizontal|vertical",
      "t": "top",
      "ta": "text-align:left|center|right|justify",
      "tal": "text-align-last:left|center|right",
      "tbl": "table-layout:fixed",
      "td": "text-decoration:none|underline|overline|line-through",
      "te": "text-emphasis:none|accent|dot|circle|disc|before|after",
      "th": "text-height:auto|font-size|text-size|max-size",
      "ti": "text-indent",
      "tj": "text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan",
      "to": "text-outline:${1:0} ${2:0} ${3:#000}",
      "tov": "text-overflow:ellipsis|clip",
      "tr": "text-replace",
      "trf": "transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})",
      "trfo": "transform-origin",
      "trfs": "transform-style:preserve-3d",
      "trs": "transition:${1:prop} ${2:time}",
      "trsde": "transition-delay:${1:time}",
      "trsdu": "transition-duration:${1:time}",
      "trsp": "transition-property:${1:prop}",
      "trstf": "transition-timing-function:${1:fn}",
      "tsh": "text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}",
      "tt": "text-transform:uppercase|lowercase|capitalize|none",
      "tw": "text-wrap:none|normal|unrestricted|suppress",
      "us": "user-select:none",
      "v": "visibility:hidden|visible|collapse",
      "va": "vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub",
      "w|wid": "width",
      "whs": "white-space:nowrap|pre|pre-wrap|pre-line|normal",
      "whsc": "white-space-collapse:normal|keep-all|loose|break-strict|break-all",
      "wido": "widows",
      "wm": "writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl",
      "wob": "word-break:normal|keep-all|break-all",
      "wos": "word-spacing",
      "wow": "word-wrap:none|unrestricted|suppress|break-word|normal",
      "z": "z-index",
      "zom": "zoom:1"
    };
    var xslSnippets = {
      "tm|tmatch": "xsl:template[match mode]",
      "tn|tname": "xsl:template[name]",
      "call": "xsl:call-template[name]",
      "ap": "xsl:apply-templates[select mode]",
      "api": "xsl:apply-imports",
      "imp": "xsl:import[href]",
      "inc": "xsl:include[href]",
      "ch": "xsl:choose",
      "wh|xsl:when": "xsl:when[test]",
      "ot": "xsl:otherwise",
      "if": "xsl:if[test]",
      "par": "xsl:param[name]",
      "pare": "xsl:param[name select]",
      "var": "xsl:variable[name]",
      "vare": "xsl:variable[name select]",
      "wp": "xsl:with-param[name select]",
      "key": "xsl:key[name match use]",
      "elem": "xsl:element[name]",
      "attr": "xsl:attribute[name]",
      "attrs": "xsl:attribute-set[name]",
      "cp": "xsl:copy[select]",
      "co": "xsl:copy-of[select]",
      "val": "xsl:value-of[select]",
      "for|each": "xsl:for-each[select]",
      "tex": "xsl:text",
      "com": "xsl:comment",
      "msg": "xsl:message[terminate=no]",
      "fall": "xsl:fallback",
      "num": "xsl:number[value]",
      "nam": "namespace-alias[stylesheet-prefix result-prefix]",
      "pres": "xsl:preserve-space[elements]",
      "strip": "xsl:strip-space[elements]",
      "proc": "xsl:processing-instruction[name]",
      "sort": "xsl:sort[select order]",
      "choose": "xsl:choose>xsl:when+xsl:otherwise",
      "xsl": "!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\n|}",
      "!!!": '{<?xml version="1.0" encoding="UTF-8"?>}'
    };
    var pugSnippets = {
      "!!!": "{doctype html}"
    };
    var variables = {
      "lang": "en",
      "locale": "en-US",
      "charset": "UTF-8",
      "indentation": "	",
      "newline": "\n"
    };
    var defaultSyntaxes = {
      markup: "html",
      stylesheet: "css"
    };
    var defaultOptions$1 = {
      "inlineElements": [
        "a",
        "abbr",
        "acronym",
        "applet",
        "b",
        "basefont",
        "bdo",
        "big",
        "br",
        "button",
        "cite",
        "code",
        "del",
        "dfn",
        "em",
        "font",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "map",
        "object",
        "q",
        "s",
        "samp",
        "select",
        "small",
        "span",
        "strike",
        "strong",
        "sub",
        "sup",
        "textarea",
        "tt",
        "u",
        "var"
      ],
      "output.indent": "	",
      "output.baseIndent": "",
      "output.newline": "\n",
      "output.tagCase": "",
      "output.attributeCase": "",
      "output.attributeQuotes": "double",
      "output.format": true,
      "output.formatLeafNode": false,
      "output.formatSkip": ["html"],
      "output.formatForce": ["body"],
      "output.inlineBreak": 3,
      "output.compactBoolean": false,
      "output.booleanAttributes": [
        "contenteditable",
        "seamless",
        "async",
        "autofocus",
        "autoplay",
        "checked",
        "controls",
        "defer",
        "disabled",
        "formnovalidate",
        "hidden",
        "ismap",
        "loop",
        "multiple",
        "muted",
        "novalidate",
        "readonly",
        "required",
        "reversed",
        "selected",
        "typemustmatch"
      ],
      "output.reverseAttributes": false,
      "output.selfClosingStyle": "html",
      "output.field": (index, placeholder) => placeholder,
      "output.text": (text2) => text2,
      "markup.href": true,
      "comment.enabled": false,
      "comment.trigger": ["id", "class"],
      "comment.before": "",
      "comment.after": "\n<!-- /[#ID][.CLASS] -->",
      "bem.enabled": false,
      "bem.element": "__",
      "bem.modifier": "_",
      "jsx.enabled": false,
      "stylesheet.keywords": ["auto", "inherit", "unset", "none"],
      "stylesheet.unitless": ["z-index", "line-height", "opacity", "font-weight", "zoom", "flex", "flex-grow", "flex-shrink"],
      "stylesheet.shortHex": true,
      "stylesheet.between": ": ",
      "stylesheet.after": ";",
      "stylesheet.intUnit": "px",
      "stylesheet.floatUnit": "em",
      "stylesheet.unitAliases": { e: "em", p: "%", x: "ex", r: "rem" },
      "stylesheet.json": false,
      "stylesheet.jsonDoubleQuotes": false,
      "stylesheet.fuzzySearchMinScore": 0,
      "stylesheet.strictMatch": false
    };
    var defaultConfig = {
      type: "markup",
      syntax: "html",
      variables,
      snippets: {},
      options: defaultOptions$1
    };
    var syntaxConfig = {
      markup: {
        snippets: parseSnippets(markupSnippets)
      },
      xhtml: {
        options: {
          "output.selfClosingStyle": "xhtml"
        }
      },
      xml: {
        options: {
          "output.selfClosingStyle": "xml"
        }
      },
      xsl: {
        snippets: parseSnippets(xslSnippets),
        options: {
          "output.selfClosingStyle": "xml"
        }
      },
      jsx: {
        options: {
          "jsx.enabled": true,
          "markup.attributes": {
            "class": "className",
            "class*": "styleName",
            "for": "htmlFor"
          },
          "markup.valuePrefix": {
            "class*": "styles"
          }
        }
      },
      vue: {
        options: {
          "markup.attributes": {
            "class*": ":class"
          }
        }
      },
      svelte: {
        options: {
          "jsx.enabled": true
        }
      },
      pug: {
        snippets: parseSnippets(pugSnippets)
      },
      stylesheet: {
        snippets: parseSnippets(stylesheetSnippets)
      },
      sass: {
        options: {
          "stylesheet.after": ""
        }
      },
      stylus: {
        options: {
          "stylesheet.between": " ",
          "stylesheet.after": ""
        }
      }
    };
    function parseSnippets(snippets) {
      const result = {};
      Object.keys(snippets).forEach((k) => {
        for (const name of k.split("|")) {
          result[name] = snippets[k];
        }
      });
      return result;
    }
    function resolveConfig(config = {}, globals = {}) {
      const type = config.type || "markup";
      const syntax = config.syntax || defaultSyntaxes[type];
      return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), {
        type,
        syntax,
        variables: mergedData(type, syntax, "variables", config, globals),
        snippets: mergedData(type, syntax, "snippets", config, globals),
        options: mergedData(type, syntax, "options", config, globals)
      });
    }
    function mergedData(type, syntax, key, config, globals = {}) {
      const typeDefaults = syntaxConfig[type];
      const typeOverride = globals[type];
      const syntaxDefaults = syntaxConfig[syntax];
      const syntaxOverride = globals[syntax];
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), typeDefaults && typeDefaults[key]), syntaxDefaults && syntaxDefaults[key]), typeOverride && typeOverride[key]), syntaxOverride && syntaxOverride[key]), config[key]);
    }
    function backwardScanner(text2, start = 0) {
      return { text: text2, start, pos: text2.length };
    }
    function sol(scanner) {
      return scanner.pos === scanner.start;
    }
    function peek(scanner, offset = 0) {
      return scanner.text.charCodeAt(scanner.pos - 1 + offset);
    }
    function previous(scanner) {
      if (!sol(scanner)) {
        return scanner.text.charCodeAt(--scanner.pos);
      }
    }
    function consume(scanner, match) {
      if (sol(scanner)) {
        return false;
      }
      const ok = typeof match === "function" ? match(peek(scanner)) : match === peek(scanner);
      if (ok) {
        scanner.pos--;
      }
      return !!ok;
    }
    function consumeWhile(scanner, match) {
      const start = scanner.pos;
      while (consume(scanner, match)) {
      }
      return scanner.pos < start;
    }
    var Chars$1;
    (function(Chars2) {
      Chars2[Chars2["SingleQuote"] = 39] = "SingleQuote";
      Chars2[Chars2["DoubleQuote"] = 34] = "DoubleQuote";
      Chars2[Chars2["Escape"] = 92] = "Escape";
    })(Chars$1 || (Chars$1 = {}));
    function isQuote(c) {
      return c === Chars$1.SingleQuote || c === Chars$1.DoubleQuote;
    }
    function consumeQuoted(scanner) {
      const start = scanner.pos;
      const quote2 = previous(scanner);
      if (isQuote(quote2)) {
        while (!sol(scanner)) {
          if (previous(scanner) === quote2 && peek(scanner) !== Chars$1.Escape) {
            return true;
          }
        }
      }
      scanner.pos = start;
      return false;
    }
    var Brackets;
    (function(Brackets2) {
      Brackets2[Brackets2["SquareL"] = 91] = "SquareL";
      Brackets2[Brackets2["SquareR"] = 93] = "SquareR";
      Brackets2[Brackets2["RoundL"] = 40] = "RoundL";
      Brackets2[Brackets2["RoundR"] = 41] = "RoundR";
      Brackets2[Brackets2["CurlyL"] = 123] = "CurlyL";
      Brackets2[Brackets2["CurlyR"] = 125] = "CurlyR";
    })(Brackets || (Brackets = {}));
    var bracePairs = {
      [Brackets.SquareL]: Brackets.SquareR,
      [Brackets.RoundL]: Brackets.RoundR,
      [Brackets.CurlyL]: Brackets.CurlyR
    };
    var Chars;
    (function(Chars2) {
      Chars2[Chars2["Tab"] = 9] = "Tab";
      Chars2[Chars2["Space"] = 32] = "Space";
      Chars2[Chars2["Dash"] = 45] = "Dash";
      Chars2[Chars2["Slash"] = 47] = "Slash";
      Chars2[Chars2["Colon"] = 58] = "Colon";
      Chars2[Chars2["Equals"] = 61] = "Equals";
      Chars2[Chars2["AngleLeft"] = 60] = "AngleLeft";
      Chars2[Chars2["AngleRight"] = 62] = "AngleRight";
    })(Chars || (Chars = {}));
    function isHtml(scanner) {
      const start = scanner.pos;
      if (!consume(scanner, Chars.AngleRight)) {
        return false;
      }
      let ok = false;
      consume(scanner, Chars.Slash);
      while (!sol(scanner)) {
        consumeWhile(scanner, isWhiteSpace);
        if (consumeIdent(scanner)) {
          if (consume(scanner, Chars.Slash)) {
            ok = consume(scanner, Chars.AngleLeft);
            break;
          } else if (consume(scanner, Chars.AngleLeft)) {
            ok = true;
            break;
          } else if (consume(scanner, isWhiteSpace)) {
            continue;
          } else if (consume(scanner, Chars.Equals)) {
            if (consumeIdent(scanner)) {
              continue;
            }
            break;
          } else if (consumeAttributeWithUnquotedValue(scanner)) {
            ok = true;
            break;
          }
          break;
        }
        if (consumeAttribute(scanner)) {
          continue;
        }
        break;
      }
      scanner.pos = start;
      return ok;
    }
    function consumeAttribute(scanner) {
      return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);
    }
    function consumeAttributeWithQuotedValue(scanner) {
      const start = scanner.pos;
      if (consumeQuoted(scanner) && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {
        return true;
      }
      scanner.pos = start;
      return false;
    }
    function consumeAttributeWithUnquotedValue(scanner) {
      const start = scanner.pos;
      const stack = [];
      while (!sol(scanner)) {
        const ch = peek(scanner);
        if (isCloseBracket(ch)) {
          stack.push(ch);
        } else if (isOpenBracket(ch)) {
          if (stack.pop() !== bracePairs[ch]) {
            break;
          }
        } else if (!isUnquotedValue(ch)) {
          break;
        }
        scanner.pos--;
      }
      if (start !== scanner.pos && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {
        return true;
      }
      scanner.pos = start;
      return false;
    }
    function consumeIdent(scanner) {
      return consumeWhile(scanner, isIdent);
    }
    function isIdent(ch) {
      return ch === Chars.Colon || ch === Chars.Dash || isAlpha(ch) || isNumber(ch);
    }
    function isAlpha(ch) {
      ch &= ~32;
      return ch >= 65 && ch <= 90;
    }
    function isNumber(ch) {
      return ch > 47 && ch < 58;
    }
    function isWhiteSpace(ch) {
      return ch === Chars.Space || ch === Chars.Tab;
    }
    function isUnquotedValue(ch) {
      return !isNaN(ch) && ch !== Chars.Equals && !isWhiteSpace(ch) && !isQuote(ch);
    }
    function isOpenBracket(ch) {
      return ch === Brackets.CurlyL || ch === Brackets.RoundL || ch === Brackets.SquareL;
    }
    function isCloseBracket(ch) {
      return ch === Brackets.CurlyR || ch === Brackets.RoundR || ch === Brackets.SquareR;
    }
    var code = (ch) => ch.charCodeAt(0);
    var specialChars = "#.*:$-_!@%^+>/".split("").map(code);
    var defaultOptions = {
      type: "markup",
      lookAhead: true,
      prefix: ""
    };
    function extractAbbreviation(line, pos = line.length, options = {}) {
      const opt2 = Object.assign(Object.assign({}, defaultOptions), options);
      pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));
      if (opt2.lookAhead) {
        pos = offsetPastAutoClosed(line, pos, opt2);
      }
      let ch;
      const start = getStartOffset(line, pos, opt2.prefix || "");
      if (start === -1) {
        return void 0;
      }
      const scanner = backwardScanner(line, start);
      scanner.pos = pos;
      const stack = [];
      while (!sol(scanner)) {
        ch = peek(scanner);
        if (stack.includes(Brackets.CurlyR)) {
          if (ch === Brackets.CurlyR) {
            stack.push(ch);
            scanner.pos--;
            continue;
          }
          if (ch !== Brackets.CurlyL) {
            scanner.pos--;
            continue;
          }
        }
        if (isCloseBrace(ch, opt2.type)) {
          stack.push(ch);
        } else if (isOpenBrace(ch, opt2.type)) {
          if (stack.pop() !== bracePairs[ch]) {
            break;
          }
        } else if (stack.includes(Brackets.SquareR) || stack.includes(Brackets.CurlyR)) {
          scanner.pos--;
          continue;
        } else if (isHtml(scanner) || !isAbbreviation(ch)) {
          break;
        }
        scanner.pos--;
      }
      if (!stack.length && scanner.pos !== pos) {
        const abbreviation2 = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, "");
        return {
          abbreviation: abbreviation2,
          location: pos - abbreviation2.length,
          start: options.prefix ? start - options.prefix.length : pos - abbreviation2.length,
          end: pos
        };
      }
    }
    function offsetPastAutoClosed(line, pos, options) {
      if (isQuote(line.charCodeAt(pos))) {
        pos++;
      }
      while (isCloseBrace(line.charCodeAt(pos), options.type)) {
        pos++;
      }
      return pos;
    }
    function getStartOffset(line, pos, prefix) {
      if (!prefix) {
        return 0;
      }
      const scanner = backwardScanner(line);
      const compiledPrefix = prefix.split("").map(code);
      scanner.pos = pos;
      let result;
      while (!sol(scanner)) {
        if (consumePair(scanner, Brackets.SquareR, Brackets.SquareL) || consumePair(scanner, Brackets.CurlyR, Brackets.CurlyL)) {
          continue;
        }
        result = scanner.pos;
        if (consumeArray(scanner, compiledPrefix)) {
          return result;
        }
        scanner.pos--;
      }
      return -1;
    }
    function consumePair(scanner, close, open) {
      const start = scanner.pos;
      if (consume(scanner, close)) {
        while (!sol(scanner)) {
          if (consume(scanner, open)) {
            return true;
          }
          scanner.pos--;
        }
      }
      scanner.pos = start;
      return false;
    }
    function consumeArray(scanner, arr) {
      const start = scanner.pos;
      let consumed = false;
      for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {
        if (!consume(scanner, arr[i])) {
          break;
        }
        consumed = i === 0;
      }
      if (!consumed) {
        scanner.pos = start;
      }
      return consumed;
    }
    function isAbbreviation(ch) {
      return ch > 64 && ch < 91 || ch > 96 && ch < 123 || ch > 47 && ch < 58 || specialChars.includes(ch);
    }
    function isOpenBrace(ch, syntax) {
      return ch === Brackets.RoundL || syntax === "markup" && (ch === Brackets.SquareL || ch === Brackets.CurlyL);
    }
    function isCloseBrace(ch, syntax) {
      return ch === Brackets.RoundR || syntax === "markup" && (ch === Brackets.SquareR || ch === Brackets.CurlyR);
    }
    function expandAbbreviation(abbr, config) {
      const resolvedConfig = resolveConfig(config);
      return resolvedConfig.type === "stylesheet" ? stylesheet(abbr, resolvedConfig) : markup(abbr, resolvedConfig);
    }
    function markup(abbr, config) {
      return stringify(parse$1(abbr, config), config);
    }
    function stylesheet(abbr, config) {
      return css(parse(abbr, config), config);
    }
    exports2.CSSAbbreviationScope = CSSAbbreviationScope;
    exports2.default = expandAbbreviation;
    exports2.extract = extractAbbreviation;
    exports2.markup = markup;
    exports2.markupAbbreviation = parseAbbreviation;
    exports2.parseMarkup = parse$1;
    exports2.parseStylesheet = parse;
    exports2.parseStylesheetSnippets = convertSnippets;
    exports2.resolveConfig = resolveConfig;
    exports2.stringifyMarkup = stringify;
    exports2.stringifyStylesheet = css;
    exports2.stylesheet = stylesheet;
    exports2.stylesheetAbbreviation = parse$2;
  }
});

// node_modules/.pnpm/@vscode+emmet-helper@2.11.0/node_modules/@vscode/emmet-helper/lib/cjs/configCompat.js
var require_configCompat = __commonJS({
  "node_modules/.pnpm/@vscode+emmet-helper@2.11.0/node_modules/@vscode/emmet-helper/lib/cjs/configCompat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.syntaxes = void 0;
    exports2.parseSnippets = parseSnippets;
    function parseSnippets(snippets) {
      const result = {};
      Object.keys(snippets).forEach((k) => {
        for (const name of k.split("|")) {
          result[name] = snippets[k];
        }
      });
      return result;
    }
    exports2.syntaxes = {
      markup: ["html", "xml", "xsl", "jsx", "js", "pug", "slim", "haml", "vue"],
      stylesheet: ["css", "sass", "scss", "less", "sss", "stylus"]
    };
  }
});

// node_modules/.pnpm/@vscode+emmet-helper@2.11.0/node_modules/@vscode/emmet-helper/lib/cjs/emmetHelper.js
var require_emmetHelper = __commonJS({
  "node_modules/.pnpm/@vscode+emmet-helper@2.11.0/node_modules/@vscode/emmet-helper/lib/cjs/emmetHelper.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.emmetSnippetField = exports2.FileType = void 0;
    exports2.doComplete = doComplete;
    exports2.isStyleSheet = isStyleSheet;
    exports2.getSyntaxType = getSyntaxType;
    exports2.getDefaultSyntax = getDefaultSyntax;
    exports2.getDefaultSnippets = getDefaultSnippets;
    exports2.extractAbbreviation = extractAbbreviation;
    exports2.extractAbbreviationFromText = extractAbbreviationFromText;
    exports2.isAbbreviationValid = isAbbreviationValid;
    exports2.getExpandOptions = getExpandOptions;
    exports2.parseAbbreviation = parseAbbreviation;
    exports2.expandAbbreviation = expandAbbreviation;
    exports2.updateExtensionsPath = updateExtensionsPath;
    exports2.getEmmetMode = getEmmetMode;
    var JSONC = __importStar(require_main7());
    var util_1 = require("util");
    var vscode_languageserver_types_1 = require_main2();
    var vscode_uri_1 = require_umd();
    var data_1 = require_data();
    var fileService_1 = require_fileService();
    Object.defineProperty(exports2, "FileType", { enumerable: true, get: function() {
      return fileService_1.FileType;
    } });
    var emmet_1 = __importStar(require_emmet());
    var configCompat_1 = require_configCompat();
    var l10n;
    try {
      l10n = require("vscode").l10n;
    } catch (_a) {
      l10n = {
        t: (message) => message
      };
    }
    var snippetKeyCache = /* @__PURE__ */ new Map();
    var markupSnippetKeys;
    var stylesheetCustomSnippetsKeyCache = /* @__PURE__ */ new Map();
    var htmlAbbreviationStartRegex = /^[a-z,A-Z,!,(,[,#,\.\{]/;
    var jsxAbbreviationStartRegex = /^[a-z,A-Z,!,(,[,#,\.]/;
    var cssAbbreviationRegex = /^-?[a-z,A-Z,!,@,#]/;
    var htmlAbbreviationRegex = /[a-z,A-Z\.]/;
    var commonlyUsedTags = [...data_1.htmlData.tags, "lorem"];
    var bemFilterSuffix = "bem";
    var filterDelimitor = "|";
    var trimFilterSuffix = "t";
    var commentFilterSuffix = "c";
    var maxFilters = 3;
    function doComplete(document, position, syntax, emmetConfig) {
      var _a, _b;
      if (emmetConfig.showExpandedAbbreviation === "never" || !getEmmetMode(syntax, emmetConfig.excludeLanguages)) {
        return;
      }
      const isStyleSheetRes = isStyleSheet(syntax);
      if (!isStyleSheetRes) {
        if (!snippetKeyCache.has(syntax)) {
          const registry = Object.assign(Object.assign({}, getDefaultSnippets(syntax)), customSnippetsRegistry[syntax]);
          snippetKeyCache.set(syntax, Object.keys(registry));
        }
        markupSnippetKeys = (_a = snippetKeyCache.get(syntax)) !== null && _a !== void 0 ? _a : [];
      }
      const extractOptions = { lookAhead: !isStyleSheetRes, type: isStyleSheetRes ? "stylesheet" : "markup" };
      const extractedValue = extractAbbreviation(document, position, extractOptions);
      if (!extractedValue) {
        return;
      }
      const { abbreviationRange, abbreviation, filter } = extractedValue;
      const currentLineTillPosition = getCurrentLine(document, position).substr(0, position.character);
      const currentWord = getCurrentWord(currentLineTillPosition);
      if (currentWord === abbreviation && currentLineTillPosition.endsWith(`<${abbreviation}`) && configCompat_1.syntaxes.markup.includes(syntax)) {
        return;
      }
      const expandOptions = getExpandOptions(syntax, emmetConfig, filter);
      let expandedText = "";
      let expandedAbbr;
      let completionItems = [];
      const createExpandedAbbr = (syntax2, abbr) => {
        if (!isAbbreviationValid(syntax2, abbreviation)) {
          return;
        }
        try {
          expandedText = (0, emmet_1.default)(abbr, expandOptions);
          if (isStyleSheetRes && "!important".startsWith(abbr)) {
            expandedText = "!important";
          }
        } catch (e) {
        }
        if (!expandedText || isExpandedTextNoise(syntax2, abbr, expandedText, expandOptions.options)) {
          return;
        }
        expandedAbbr = vscode_languageserver_types_1.CompletionItem.create(abbr);
        expandedAbbr.textEdit = vscode_languageserver_types_1.TextEdit.replace(abbreviationRange, escapeNonTabStopDollar(addFinalTabStop(expandedText)));
        expandedAbbr.documentation = replaceTabStopsWithCursors(expandedText);
        expandedAbbr.insertTextFormat = vscode_languageserver_types_1.InsertTextFormat.Snippet;
        expandedAbbr.detail = l10n.t("Emmet Abbreviation");
        expandedAbbr.label = abbreviation;
        expandedAbbr.label += filter ? "|" + filter.replace(",", "|") : "";
        completionItems = [expandedAbbr];
      };
      if (isStyleSheet(syntax)) {
        createExpandedAbbr(syntax, abbreviation);
        if (abbreviation.length > 4 && data_1.cssData.properties.find((x) => x.startsWith(abbreviation))) {
          return vscode_languageserver_types_1.CompletionList.create([], true);
        }
        if (expandedAbbr && expandedText.length) {
          expandedAbbr.textEdit = vscode_languageserver_types_1.TextEdit.replace(abbreviationRange, escapeNonTabStopDollar(addFinalTabStop(expandedText)));
          expandedAbbr.documentation = replaceTabStopsWithCursors(expandedText);
          expandedAbbr.label = removeTabStops(expandedText);
          expandedAbbr.filterText = abbreviation;
          const stylesheetCustomSnippetsKeys = stylesheetCustomSnippetsKeyCache.has(syntax) ? stylesheetCustomSnippetsKeyCache.get(syntax) : stylesheetCustomSnippetsKeyCache.get("css");
          completionItems = makeSnippetSuggestion(stylesheetCustomSnippetsKeys !== null && stylesheetCustomSnippetsKeys !== void 0 ? stylesheetCustomSnippetsKeys : [], abbreviation, abbreviation, abbreviationRange, expandOptions, "Emmet Custom Snippet", false);
          if (!completionItems.find((x) => {
            var _a2, _b2, _c;
            return ((_a2 = x.textEdit) === null || _a2 === void 0 ? void 0 : _a2.newText) && ((_b2 = x.textEdit) === null || _b2 === void 0 ? void 0 : _b2.newText) === ((_c = expandedAbbr === null || expandedAbbr === void 0 ? void 0 : expandedAbbr.textEdit) === null || _c === void 0 ? void 0 : _c.newText);
          })) {
            const abbrRegex = new RegExp(".*" + abbreviation.split("").map((x) => x === "$" || x === "+" ? "\\" + x : x).join(".*") + ".*", "i");
            if (/\d/.test(abbreviation) || abbrRegex.test(expandedAbbr.label)) {
              completionItems.push(expandedAbbr);
            }
          }
        }
      } else {
        createExpandedAbbr(syntax, abbreviation);
        let tagToFindMoreSuggestionsFor = abbreviation;
        const newTagMatches = abbreviation.match(/(>|\+)([\w:-]+)$/);
        if (newTagMatches && newTagMatches.length === 3) {
          tagToFindMoreSuggestionsFor = newTagMatches[2];
        }
        if (syntax !== "xml") {
          const commonlyUsedTagSuggestions = makeSnippetSuggestion(commonlyUsedTags, tagToFindMoreSuggestionsFor, abbreviation, abbreviationRange, expandOptions, "Emmet Abbreviation");
          completionItems = completionItems.concat(commonlyUsedTagSuggestions);
        }
        if (emmetConfig.showAbbreviationSuggestions === true) {
          const abbreviationSuggestions = makeSnippetSuggestion(markupSnippetKeys.filter((x) => !commonlyUsedTags.includes(x)), tagToFindMoreSuggestionsFor, abbreviation, abbreviationRange, expandOptions, "Emmet Abbreviation");
          if (expandedAbbr && abbreviationSuggestions.length > 0 && tagToFindMoreSuggestionsFor !== abbreviation) {
            expandedAbbr.sortText = "0" + expandedAbbr.label;
            abbreviationSuggestions.forEach((item) => {
              item.filterText = abbreviation;
              item.sortText = "9" + abbreviation;
            });
          }
          completionItems = completionItems.concat(abbreviationSuggestions);
        }
        if (syntax === "html" && completionItems.length >= 2 && abbreviation.includes(":") && ((_b = expandedAbbr === null || expandedAbbr === void 0 ? void 0 : expandedAbbr.textEdit) === null || _b === void 0 ? void 0 : _b.newText) === `<${abbreviation}>\${0}</${abbreviation}>`) {
          completionItems = completionItems.filter((item) => item.label !== abbreviation);
        }
      }
      if (emmetConfig.showSuggestionsAsSnippets === true) {
        completionItems.forEach((x) => x.kind = vscode_languageserver_types_1.CompletionItemKind.Snippet);
      }
      return completionItems.length ? vscode_languageserver_types_1.CompletionList.create(completionItems, true) : void 0;
    }
    function makeSnippetSuggestion(snippetKeys, prefix, abbreviation, abbreviationRange, expandOptions, snippetDetail, skipFullMatch = true) {
      if (!prefix || !snippetKeys) {
        return [];
      }
      const snippetCompletions = [];
      snippetKeys.forEach((snippetKey) => {
        if (!snippetKey.startsWith(prefix.toLowerCase()) || skipFullMatch && snippetKey === prefix.toLowerCase()) {
          return;
        }
        const currentAbbr = abbreviation + snippetKey.substr(prefix.length);
        let expandedAbbr;
        try {
          expandedAbbr = (0, emmet_1.default)(currentAbbr, expandOptions);
        } catch (e) {
        }
        if (!expandedAbbr) {
          return;
        }
        const item = vscode_languageserver_types_1.CompletionItem.create(prefix + snippetKey.substr(prefix.length));
        item.documentation = replaceTabStopsWithCursors(expandedAbbr);
        item.detail = snippetDetail;
        item.textEdit = vscode_languageserver_types_1.TextEdit.replace(abbreviationRange, escapeNonTabStopDollar(addFinalTabStop(expandedAbbr)));
        item.insertTextFormat = vscode_languageserver_types_1.InsertTextFormat.Snippet;
        snippetCompletions.push(item);
      });
      return snippetCompletions;
    }
    function getCurrentWord(currentLineTillPosition) {
      if (currentLineTillPosition) {
        const matches = currentLineTillPosition.match(/[\w,:,-,\.]*$/);
        if (matches) {
          return matches[0];
        }
      }
    }
    function replaceTabStopsWithCursors(expandedWord) {
      return expandedWord.replace(/([^\\])\$\{\d+\}/g, "$1|").replace(/\$\{\d+:([^\}]+)\}/g, "$1");
    }
    function removeTabStops(expandedWord) {
      return expandedWord.replace(/([^\\])\$\{\d+\}/g, "$1").replace(/\$\{\d+:([^\}]+)\}/g, "$1");
    }
    function escapeNonTabStopDollar(text) {
      return text ? text.replace(/([^\\])(\$)([^\{])/g, "$1\\$2$3") : text;
    }
    function addFinalTabStop(text) {
      if (!text || !text.trim()) {
        return text;
      }
      let maxTabStop = -1;
      let maxTabStopRanges = [];
      let foundLastStop = false;
      let replaceWithLastStop = false;
      let i = 0;
      const n = text.length;
      try {
        while (i < n && !foundLastStop) {
          if (text[i++] != "$" || text[i++] != "{") {
            continue;
          }
          let numberStart = -1;
          let numberEnd = -1;
          while (i < n && /\d/.test(text[i])) {
            numberStart = numberStart < 0 ? i : numberStart;
            numberEnd = i + 1;
            i++;
          }
          if (numberStart === -1 || numberEnd === -1 || i >= n || text[i] != "}" && text[i] != ":") {
            continue;
          }
          const currentTabStop = text.substring(numberStart, numberEnd);
          foundLastStop = currentTabStop === "0";
          if (foundLastStop) {
            break;
          }
          let foundPlaceholder = false;
          if (text[i++] == ":") {
            while (i < n) {
              if (text[i] == "}") {
                foundPlaceholder = true;
                break;
              }
              i++;
            }
          }
          if (Number(currentTabStop) > Number(maxTabStop)) {
            maxTabStop = Number(currentTabStop);
            maxTabStopRanges = [{ numberStart, numberEnd }];
            replaceWithLastStop = !foundPlaceholder;
          } else if (Number(currentTabStop) === maxTabStop) {
            maxTabStopRanges.push({ numberStart, numberEnd });
          }
        }
      } catch (e) {
      }
      if (replaceWithLastStop && !foundLastStop) {
        for (let i2 = 0; i2 < maxTabStopRanges.length; i2++) {
          const rangeStart = maxTabStopRanges[i2].numberStart;
          const rangeEnd = maxTabStopRanges[i2].numberEnd;
          text = text.substr(0, rangeStart) + "0" + text.substr(rangeEnd);
        }
      }
      return text;
    }
    function getCurrentLine(document, position) {
      const offset = document.offsetAt(position);
      const text = document.getText();
      let start = 0;
      let end = text.length;
      for (let i = offset - 1; i >= 0; i--) {
        if (text[i] === "\n") {
          start = i + 1;
          break;
        }
      }
      for (let i = offset; i < text.length; i++) {
        if (text[i] === "\n") {
          end = i;
          break;
        }
      }
      return text.substring(start, end);
    }
    var customSnippetsRegistry = {};
    var variablesFromFile = {};
    var profilesFromFile = {};
    var emmetSnippetField = (index, placeholder) => `\${${index}${placeholder ? ":" + placeholder : ""}}`;
    exports2.emmetSnippetField = emmetSnippetField;
    function isStyleSheet(syntax) {
      return configCompat_1.syntaxes.stylesheet.includes(syntax);
    }
    function getSyntaxType(syntax) {
      return isStyleSheet(syntax) ? "stylesheet" : "markup";
    }
    function getDefaultSyntax(syntax) {
      return isStyleSheet(syntax) ? "css" : "html";
    }
    function getDefaultSnippets(syntax) {
      const syntaxType = getSyntaxType(syntax);
      const emptyUserConfig = { type: syntaxType, syntax };
      const resolvedConfig = (0, emmet_1.resolveConfig)(emptyUserConfig);
      return syntax === "xml" ? {} : resolvedConfig.snippets;
    }
    function getFilters(text, pos) {
      let filter;
      for (let i = 0; i < maxFilters; i++) {
        if (text.endsWith(`${filterDelimitor}${bemFilterSuffix}`, pos)) {
          pos -= bemFilterSuffix.length + 1;
          filter = filter ? bemFilterSuffix + "," + filter : bemFilterSuffix;
        } else if (text.endsWith(`${filterDelimitor}${commentFilterSuffix}`, pos)) {
          pos -= commentFilterSuffix.length + 1;
          filter = filter ? commentFilterSuffix + "," + filter : commentFilterSuffix;
        } else if (text.endsWith(`${filterDelimitor}${trimFilterSuffix}`, pos)) {
          pos -= trimFilterSuffix.length + 1;
          filter = filter ? trimFilterSuffix + "," + filter : trimFilterSuffix;
        } else {
          break;
        }
      }
      return {
        pos,
        filter
      };
    }
    function extractAbbreviation(document, position, options) {
      const currentLine = getCurrentLine(document, position);
      const currentLineTillPosition = currentLine.substr(0, position.character);
      const { pos, filter } = getFilters(currentLineTillPosition, position.character);
      const lengthOccupiedByFilter = filter ? filter.length + 1 : 0;
      const result = (0, emmet_1.extract)(currentLine, pos, options);
      if (!result) {
        return;
      }
      const rangeToReplace = vscode_languageserver_types_1.Range.create(position.line, result.location, position.line, result.location + result.abbreviation.length + lengthOccupiedByFilter);
      return {
        abbreviationRange: rangeToReplace,
        abbreviation: result.abbreviation,
        filter
      };
    }
    function extractAbbreviationFromText(text, syntax) {
      if (!text) {
        return;
      }
      const { pos, filter } = getFilters(text, text.length);
      const extractOptions = isStyleSheet(syntax) || syntax === "stylesheet" ? { syntax: "stylesheet", lookAhead: false } : { lookAhead: true };
      const result = (0, emmet_1.extract)(text, pos, extractOptions);
      if (!result) {
        return;
      }
      return {
        abbreviation: result.abbreviation,
        filter
      };
    }
    function isAbbreviationValid(syntax, abbreviation) {
      if (!abbreviation) {
        return false;
      }
      if (isStyleSheet(syntax)) {
        if (abbreviation.includes("#")) {
          if (abbreviation.startsWith("#")) {
            const hexColorRegex = /^#[\d,a-f,A-F]{1,6}$/;
            return hexColorRegex.test(abbreviation);
          } else if (commonlyUsedTags.includes(abbreviation.substring(0, abbreviation.indexOf("#")))) {
            return false;
          }
        }
        return cssAbbreviationRegex.test(abbreviation);
      }
      if (abbreviation.startsWith("!")) {
        return !/[^!]/.test(abbreviation);
      }
      if ((/\(/.test(abbreviation) || /\)/.test(abbreviation)) && !/\{[^\}\{]*[\(\)]+[^\}\{]*\}(?:[>\+\*\^]|$)/.test(abbreviation) && !/\(.*\)[>\+\*\^]/.test(abbreviation) && !/\[[^\[\]\(\)]+=".*"\]/.test(abbreviation) && !/[>\+\*\^]\(.*\)/.test(abbreviation)) {
        return false;
      }
      if (syntax === "jsx") {
        return jsxAbbreviationStartRegex.test(abbreviation) && htmlAbbreviationRegex.test(abbreviation);
      }
      if (/^{%|{#|{{/.test(abbreviation)) {
        return false;
      }
      return htmlAbbreviationStartRegex.test(abbreviation) && htmlAbbreviationRegex.test(abbreviation);
    }
    function isExpandedTextNoise(syntax, abbreviation, expandedText, options) {
      var _a, _b;
      if (isStyleSheet(syntax) && options) {
        const between = (_a = options["stylesheet.between"]) !== null && _a !== void 0 ? _a : ": ";
        const after = (_b = options["stylesheet.after"]) !== null && _b !== void 0 ? _b : ";";
        let endPrefixIndex = abbreviation.indexOf(between[0], Math.max(abbreviation.length - between.length, 0));
        endPrefixIndex = endPrefixIndex >= 0 ? endPrefixIndex : abbreviation.length;
        const abbr = abbreviation.substring(0, endPrefixIndex);
        return expandedText === `${abbr}${between}\${0}${after}` || expandedText.replace(/\s/g, "") === abbreviation.replace(/\s/g, "") + after;
      }
      if (syntax === "xml" && commonlyUsedTags.some((tag) => tag.startsWith(abbreviation.toLowerCase()))) {
        return true;
      }
      if (commonlyUsedTags.includes(abbreviation.toLowerCase()) || markupSnippetKeys.includes(abbreviation)) {
        return false;
      }
      if (/[-,:]/.test(abbreviation) && !/--|::/.test(abbreviation) && !abbreviation.endsWith(":")) {
        return false;
      }
      if (/^\.{2,}$/.test(abbreviation)) {
        return true;
      }
      if (abbreviation === ".") {
        return false;
      }
      const dotMatches = abbreviation.match(/^([a-z,A-Z,\d]*)\.$/);
      if (dotMatches) {
        if (dotMatches[1] && data_1.htmlData.tags.includes(dotMatches[1])) {
          return false;
        }
        return true;
      }
      if (syntax === "jsx" && /^([A-Z][A-Za-z0-9]*)+$/.test(abbreviation)) {
        return false;
      }
      return expandedText.toLowerCase() === `<${abbreviation.toLowerCase()}>\${1}</${abbreviation.toLowerCase()}>`;
    }
    function getExpandOptions(syntax, emmetConfig, filter) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      emmetConfig = emmetConfig !== null && emmetConfig !== void 0 ? emmetConfig : {};
      emmetConfig["preferences"] = (_a = emmetConfig["preferences"]) !== null && _a !== void 0 ? _a : {};
      const preferences = emmetConfig["preferences"];
      const stylesheetSyntax = isStyleSheet(syntax) ? syntax : "css";
      const profile = getProfile(syntax, (_b = emmetConfig["syntaxProfiles"]) !== null && _b !== void 0 ? _b : {});
      const filtersFromProfile = profile && profile["filters"] ? profile["filters"].split(",") : [];
      const trimmedFilters = filtersFromProfile.map((filterFromProfile) => filterFromProfile.trim());
      const bemEnabled = filter && filter.split(",").some((x) => x.trim() === "bem") || trimmedFilters.includes("bem");
      const commentEnabled = filter && filter.split(",").some((x) => x.trim() === "c") || trimmedFilters.includes("c");
      const formatters = getFormatters(syntax, emmetConfig["preferences"]);
      const unitAliases = (formatters === null || formatters === void 0 ? void 0 : formatters.stylesheet) && formatters.stylesheet["unitAliases"] || {};
      const defaultVSCodeOptions = {
        // inlineElements: string[],
        // 'output.indent': string,
        // 'output.baseIndent': string,
        // 'output.newline': string,
        // 'output.tagCase': profile['tagCase'],
        // 'output.attributeCase': profile['attributeCase'],
        // 'output.attributeQuotes': profile['attributeQuotes'],
        // 'output.format': profile['format'] ?? true,
        // 'output.formatLeafNode': boolean,
        "output.formatSkip": ["html"],
        "output.formatForce": ["body"],
        "output.inlineBreak": 0,
        "output.compactBoolean": false,
        // 'output.booleanAttributes': string[],
        "output.reverseAttributes": false,
        // 'output.selfClosingStyle': profile['selfClosingStyle'],
        "output.field": exports2.emmetSnippetField,
        // 'output.text': TextOutput,
        "markup.href": true,
        "comment.enabled": false,
        "comment.trigger": ["id", "class"],
        "comment.before": "",
        "comment.after": "\n<!-- /[#ID][.CLASS] -->",
        "bem.enabled": false,
        "bem.element": "__",
        "bem.modifier": "_",
        "jsx.enabled": syntax === "jsx",
        // 'stylesheet.keywords': string[],
        // 'stylesheet.unitless': string[],
        "stylesheet.shortHex": true,
        "stylesheet.between": syntax === "stylus" ? " " : ": ",
        "stylesheet.after": syntax === "sass" || syntax === "stylus" ? "" : ";",
        "stylesheet.intUnit": "px",
        "stylesheet.floatUnit": "em",
        "stylesheet.unitAliases": { e: "em", p: "%", x: "ex", r: "rem" },
        // 'stylesheet.json': boolean,
        // 'stylesheet.jsonDoubleQuotes': boolean,
        "stylesheet.fuzzySearchMinScore": 0.3
      };
      let userPreferenceOptions = {
        // inlineElements: string[],
        // 'output.indent': string,
        // 'output.baseIndent': string,
        // 'output.newline': string,
        "output.tagCase": profile["tagCase"],
        "output.attributeCase": profile["attributeCase"],
        "output.attributeQuotes": profile["attributeQuotes"],
        "output.format": (_c = profile["format"]) !== null && _c !== void 0 ? _c : true,
        // 'output.formatLeafNode': boolean,
        "output.formatSkip": preferences["format.noIndentTags"],
        "output.formatForce": preferences["format.forceIndentationForTags"],
        "output.inlineBreak": (_d = profile["inlineBreak"]) !== null && _d !== void 0 ? _d : preferences["output.inlineBreak"],
        "output.compactBoolean": (_e = profile["compactBooleanAttributes"]) !== null && _e !== void 0 ? _e : preferences["profile.allowCompactBoolean"],
        // 'output.booleanAttributes': string[],
        "output.reverseAttributes": preferences["output.reverseAttributes"],
        "output.selfClosingStyle": (_g = (_f = profile["selfClosingStyle"]) !== null && _f !== void 0 ? _f : preferences["output.selfClosingStyle"]) !== null && _g !== void 0 ? _g : getClosingStyle(syntax),
        "output.field": exports2.emmetSnippetField,
        // 'output.text': TextOutput,
        // 'markup.href': boolean,
        "comment.enabled": commentEnabled,
        "comment.trigger": preferences["filter.commentTrigger"],
        "comment.before": preferences["filter.commentBefore"],
        "comment.after": preferences["filter.commentAfter"],
        "bem.enabled": bemEnabled,
        "bem.element": (_h = preferences["bem.elementSeparator"]) !== null && _h !== void 0 ? _h : "__",
        "bem.modifier": (_j = preferences["bem.modifierSeparator"]) !== null && _j !== void 0 ? _j : "_",
        "jsx.enabled": syntax === "jsx",
        // 'stylesheet.keywords': string[],
        // 'stylesheet.unitless': string[],
        "stylesheet.shortHex": preferences["css.color.short"],
        "stylesheet.between": preferences[`${stylesheetSyntax}.valueSeparator`],
        "stylesheet.after": preferences[`${stylesheetSyntax}.propertyEnd`],
        "stylesheet.intUnit": preferences["css.intUnit"],
        "stylesheet.floatUnit": preferences["css.floatUnit"],
        "stylesheet.unitAliases": unitAliases,
        // 'stylesheet.json': boolean,
        // 'stylesheet.jsonDoubleQuotes': boolean,
        "stylesheet.fuzzySearchMinScore": preferences["css.fuzzySearchMinScore"]
      };
      if (syntax === "jsx") {
        const defaultMarkupAttributeOptions = {
          "class": "className",
          "class*": "styleName",
          "for": "htmlFor"
        };
        const defaultMarkupValuePrefixOptions = {
          "class*": "styles"
        };
        if (profile["markup.attributes"]) {
          userPreferenceOptions["markup.attributes"] = Object.assign(Object.assign({}, defaultMarkupAttributeOptions), profile["markup.attributes"]);
        }
        if (profile["markup.valuePrefix"]) {
          userPreferenceOptions["markup.valuePrefix"] = Object.assign(Object.assign({}, defaultMarkupValuePrefixOptions), profile["markup.valuePrefix"]);
        }
      }
      if (syntax === "vue") {
        const defaultMarkupAttributeOptions = {
          "class*": ":class"
        };
        const defaultMarkupValuePrefixOptions = {
          "class*": "$style"
        };
        if (profile["markup.attributes"]) {
          userPreferenceOptions["markup.attributes"] = Object.assign(Object.assign({}, defaultMarkupAttributeOptions), profile["markup.attributes"]);
        }
        if (profile["markup.valuePrefix"]) {
          userPreferenceOptions["markup.valuePrefix"] = Object.assign(Object.assign({}, defaultMarkupValuePrefixOptions), profile["markup.valuePrefix"]);
        }
      }
      const combinedOptions = {};
      [...Object.keys(defaultVSCodeOptions), ...Object.keys(userPreferenceOptions)].forEach((key) => {
        var _a2;
        const castKey = key;
        combinedOptions[castKey] = (_a2 = userPreferenceOptions[castKey]) !== null && _a2 !== void 0 ? _a2 : defaultVSCodeOptions[castKey];
      });
      const mergedAliases = Object.assign(Object.assign({}, defaultVSCodeOptions["stylesheet.unitAliases"]), userPreferenceOptions["stylesheet.unitAliases"]);
      combinedOptions["stylesheet.unitAliases"] = mergedAliases;
      const type = getSyntaxType(syntax);
      const variables = getVariables(emmetConfig["variables"]);
      const baseSyntax = getDefaultSyntax(syntax);
      const snippets = type === "stylesheet" ? (_k = customSnippetsRegistry[syntax]) !== null && _k !== void 0 ? _k : customSnippetsRegistry[baseSyntax] : customSnippetsRegistry[syntax];
      return {
        type,
        options: combinedOptions,
        variables,
        snippets,
        syntax,
        // context: null,
        text: void 0,
        maxRepeat: 1e3
        // cache: null
      };
    }
    function getClosingStyle(syntax) {
      switch (syntax) {
        case "xhtml":
          return "xhtml";
        case "xml":
          return "xml";
        case "xsl":
          return "xml";
        case "jsx":
          return "xhtml";
        default:
          return "html";
      }
    }
    function parseAbbreviation(abbreviation, options) {
      const resolvedOptions = (0, emmet_1.resolveConfig)(options);
      return options.type === "stylesheet" ? (0, emmet_1.parseStylesheet)(abbreviation, resolvedOptions) : (0, emmet_1.parseMarkup)(abbreviation, resolvedOptions);
    }
    function expandAbbreviation(abbreviation, config) {
      let expandedText;
      const resolvedConfig = (0, emmet_1.resolveConfig)(config);
      if (config.type === "stylesheet") {
        if (typeof abbreviation === "string") {
          expandedText = (0, emmet_1.default)(abbreviation, resolvedConfig);
        } else {
          expandedText = (0, emmet_1.stringifyStylesheet)(abbreviation, resolvedConfig);
        }
      } else {
        if (typeof abbreviation === "string") {
          expandedText = (0, emmet_1.default)(abbreviation, resolvedConfig);
        } else {
          expandedText = (0, emmet_1.stringifyMarkup)(abbreviation, resolvedConfig);
        }
      }
      return escapeNonTabStopDollar(addFinalTabStop(expandedText));
    }
    function getProfile(syntax, profilesFromSettings) {
      if (!profilesFromSettings) {
        profilesFromSettings = {};
      }
      const profilesConfig = Object.assign({}, profilesFromFile, profilesFromSettings);
      const options = profilesConfig[syntax];
      if (!options || typeof options === "string") {
        if (options === "xhtml") {
          return {
            selfClosingStyle: "xhtml"
          };
        }
        return {};
      }
      const newOptions = {};
      for (const key in options) {
        switch (key) {
          case "tag_case":
            newOptions["tagCase"] = options[key] === "lower" || options[key] === "upper" ? options[key] : "";
            break;
          case "attr_case":
            newOptions["attributeCase"] = options[key] === "lower" || options[key] === "upper" ? options[key] : "";
            break;
          case "attr_quotes":
            newOptions["attributeQuotes"] = options[key];
            break;
          case "tag_nl":
            newOptions["format"] = options[key] === true || options[key] === false ? options[key] : true;
            break;
          case "inline_break":
            newOptions["inlineBreak"] = options[key];
            break;
          case "self_closing_tag":
            if (options[key] === true) {
              newOptions["selfClosingStyle"] = "xml";
              break;
            }
            if (options[key] === false) {
              newOptions["selfClosingStyle"] = "html";
              break;
            }
            newOptions["selfClosingStyle"] = options[key];
            break;
          case "compact_bool":
            newOptions["compactBooleanAttributes"] = options[key];
            break;
          default:
            newOptions[key] = options[key];
            break;
        }
      }
      return newOptions;
    }
    function getVariables(variablesFromSettings) {
      if (!variablesFromSettings) {
        return variablesFromFile;
      }
      return Object.assign({}, variablesFromFile, variablesFromSettings);
    }
    function getFormatters(syntax, preferences) {
      if (!preferences || typeof preferences !== "object") {
        return {};
      }
      if (!isStyleSheet(syntax)) {
        const commentFormatter = {};
        for (const key in preferences) {
          switch (key) {
            case "filter.commentAfter":
              commentFormatter["after"] = preferences[key];
              break;
            case "filter.commentBefore":
              commentFormatter["before"] = preferences[key];
              break;
            case "filter.commentTrigger":
              commentFormatter["trigger"] = preferences[key];
              break;
            default:
              break;
          }
        }
        return {
          comment: commentFormatter
        };
      }
      let fuzzySearchMinScore = typeof (preferences === null || preferences === void 0 ? void 0 : preferences["css.fuzzySearchMinScore"]) === "number" ? preferences["css.fuzzySearchMinScore"] : 0.3;
      if (fuzzySearchMinScore > 1) {
        fuzzySearchMinScore = 1;
      } else if (fuzzySearchMinScore < 0) {
        fuzzySearchMinScore = 0;
      }
      const stylesheetFormatter = {
        "fuzzySearchMinScore": fuzzySearchMinScore
      };
      for (const key in preferences) {
        switch (key) {
          case "css.floatUnit":
            stylesheetFormatter["floatUnit"] = preferences[key];
            break;
          case "css.intUnit":
            stylesheetFormatter["intUnit"] = preferences[key];
            break;
          case "css.unitAliases":
            const unitAliases = {};
            preferences[key].split(",").forEach((alias) => {
              if (!alias || !alias.trim() || !alias.includes(":")) {
                return;
              }
              const aliasName = alias.substr(0, alias.indexOf(":"));
              const aliasValue = alias.substr(aliasName.length + 1);
              if (!aliasName.trim() || !aliasValue) {
                return;
              }
              unitAliases[aliasName.trim()] = aliasValue;
            });
            stylesheetFormatter["unitAliases"] = unitAliases;
            break;
          case `${syntax}.valueSeparator`:
            stylesheetFormatter["between"] = preferences[key];
            break;
          case `${syntax}.propertyEnd`:
            stylesheetFormatter["after"] = preferences[key];
            break;
          default:
            break;
        }
      }
      return {
        stylesheet: stylesheetFormatter
      };
    }
    function updateExtensionsPath(emmetExtensionsPathSetting, fs2, workspaceFolderPaths, homeDir) {
      return __awaiter(this, void 0, void 0, function* () {
        resetSettingsFromFile();
        if (!emmetExtensionsPathSetting.length) {
          return;
        }
        const emmetExtensionsPathUri = [];
        for (let emmetExtensionsPath of emmetExtensionsPathSetting) {
          if (typeof emmetExtensionsPath !== "string") {
            console.warn("The following emmetExtensionsPath isn't a string: " + JSON.stringify(emmetExtensionsPath));
            continue;
          }
          emmetExtensionsPath = emmetExtensionsPath.trim();
          if (emmetExtensionsPath.length && emmetExtensionsPath[0] === "~") {
            if (homeDir) {
              emmetExtensionsPathUri.push((0, fileService_1.joinPath)(homeDir, emmetExtensionsPath.substring(1)));
            }
          } else if (!(0, fileService_1.isAbsolutePath)(emmetExtensionsPath)) {
            if (workspaceFolderPaths) {
              for (const workspacePath of workspaceFolderPaths) {
                emmetExtensionsPathUri.push((0, fileService_1.joinPath)(workspacePath, emmetExtensionsPath));
              }
            }
          } else {
            emmetExtensionsPathUri.push(vscode_uri_1.URI.file(emmetExtensionsPath));
          }
        }
        for (const uri of emmetExtensionsPathUri) {
          try {
            if ((yield fs2.stat(uri)).type !== fileService_1.FileType.Directory) {
              continue;
            }
          } catch (e) {
            continue;
          }
          const snippetsPath = (0, fileService_1.joinPath)(uri, "snippets.json");
          const profilesPath = (0, fileService_1.joinPath)(uri, "syntaxProfiles.json");
          let decoder;
          if (typeof globalThis.TextDecoder === "function") {
            decoder = new globalThis.TextDecoder();
          } else {
            decoder = new util_1.TextDecoder();
          }
          let snippetsDataStr = "";
          try {
            const snippetsData = yield fs2.readFile(snippetsPath);
            snippetsDataStr = decoder.decode(snippetsData);
          } catch (e) {
          }
          if (snippetsDataStr.length) {
            try {
              const snippetsJson = tryParseFile(snippetsPath, snippetsDataStr);
              if (snippetsJson["variables"]) {
                updateVariables(snippetsJson["variables"]);
              }
              updateSnippets(snippetsJson);
            } catch (e) {
              resetSettingsFromFile();
              throw e;
            }
          }
          let profilesDataStr = "";
          try {
            const profilesData = yield fs2.readFile(profilesPath);
            profilesDataStr = decoder.decode(profilesData);
          } catch (e) {
          }
          if (profilesDataStr.length) {
            try {
              const profilesJson = tryParseFile(profilesPath, profilesDataStr);
              updateProfiles(profilesJson);
            } catch (e) {
              resetSettingsFromFile();
              throw e;
            }
          }
        }
      });
    }
    function tryParseFile(strPath, dataStr) {
      let errors = [];
      const json = JSONC.parse(dataStr, errors);
      if (errors.length) {
        throw new Error(`Found error ${JSONC.printParseErrorCode(errors[0].error)} while parsing the file ${strPath} at offset ${errors[0].offset}`);
      }
      return json;
    }
    function updateVariables(varsJson) {
      if (typeof varsJson === "object" && varsJson) {
        variablesFromFile = Object.assign({}, variablesFromFile, varsJson);
      } else {
        throw new Error(l10n.t("Invalid emmet.variables field. See https://code.visualstudio.com/docs/editor/emmet#_emmet-configuration for a valid example."));
      }
    }
    function updateProfiles(profileJson) {
      if (typeof profileJson === "object" && profileJson) {
        profilesFromFile = Object.assign({}, profilesFromFile, profileJson);
      } else {
        throw new Error(l10n.t("Invalid syntax profile. See https://code.visualstudio.com/docs/editor/emmet#_emmet-configuration for a valid example."));
      }
    }
    function updateSnippets(snippetsJson) {
      if (typeof snippetsJson === "object" && snippetsJson) {
        Object.keys(snippetsJson).forEach((syntax) => {
          if (!snippetsJson[syntax]["snippets"]) {
            return;
          }
          const baseSyntax = getDefaultSyntax(syntax);
          let customSnippets = snippetsJson[syntax]["snippets"];
          if (snippetsJson[baseSyntax] && snippetsJson[baseSyntax]["snippets"] && baseSyntax !== syntax) {
            customSnippets = Object.assign({}, snippetsJson[baseSyntax]["snippets"], snippetsJson[syntax]["snippets"]);
          }
          if (!isStyleSheet(syntax)) {
            for (const snippetKey in customSnippets) {
              if (customSnippets.hasOwnProperty(snippetKey) && customSnippets[snippetKey].startsWith("<") && customSnippets[snippetKey].endsWith(">")) {
                customSnippets[snippetKey] = `{${customSnippets[snippetKey]}}`;
              }
            }
          } else {
            const prevSnippetKeys = stylesheetCustomSnippetsKeyCache.get(syntax);
            const mergedSnippetKeys = Object.assign([], prevSnippetKeys, Object.keys(customSnippets));
            stylesheetCustomSnippetsKeyCache.set(syntax, mergedSnippetKeys);
          }
          const prevSnippetsRegistry = customSnippetsRegistry[syntax];
          const newSnippets = (0, configCompat_1.parseSnippets)(customSnippets);
          const mergedSnippets = Object.assign({}, prevSnippetsRegistry, newSnippets);
          customSnippetsRegistry[syntax] = mergedSnippets;
        });
      } else {
        throw new Error(l10n.t("Invalid snippets file. See https://code.visualstudio.com/docs/editor/emmet#_using-custom-emmet-snippets for a valid example."));
      }
    }
    function resetSettingsFromFile() {
      customSnippetsRegistry = {};
      snippetKeyCache.clear();
      stylesheetCustomSnippetsKeyCache.clear();
      profilesFromFile = {};
      variablesFromFile = {};
    }
    function getEmmetMode(language, excludedLanguages = []) {
      if (!language || excludedLanguages.includes(language)) {
        return;
      }
      if (/\b(typescriptreact|javascriptreact|jsx-tags)\b/.test(language)) {
        return "jsx";
      }
      if (language === "sass-indented") {
        return "sass";
      }
      if (language === "jade") {
        return "pug";
      }
      if (configCompat_1.syntaxes.markup.includes(language) || configCompat_1.syntaxes.stylesheet.includes(language)) {
        return language;
      }
    }
  }
});

// node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/lib/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/lib/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.allowedMimeTypesInScriptTag = void 0;
    exports2.getEmmetHelper = getEmmetHelper;
    exports2.isStyleSheet = isStyleSheet;
    exports2.getMappingForIncludedLanguages = getMappingForIncludedLanguages;
    exports2.getEmmetMode = getEmmetMode;
    exports2.parsePartialStylesheet = parsePartialStylesheet;
    exports2.getFlatNode = getFlatNode;
    exports2.getHtmlFlatNode = getHtmlFlatNode;
    exports2.getEmmetConfiguration = getEmmetConfiguration;
    exports2.getEmbeddedCssNodeIfAny = getEmbeddedCssNodeIfAny;
    var css_parser_1 = require_css_parser_cjs();
    var html_matcher_1 = require_html_matcher_cjs();
    var bufferStream_1 = require_bufferStream();
    var _emmetHelper;
    function getEmmetHelper() {
      if (!_emmetHelper) {
        _emmetHelper = require_emmetHelper();
      }
      return _emmetHelper;
    }
    var LANGUAGE_MODES = {
      "html": ["!", ".", "}", ":", "*", "$", "]", "/", ">", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "jade": ["!", ".", "}", ":", "*", "$", "]", "/", ">", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "slim": ["!", ".", "}", ":", "*", "$", "]", "/", ">", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "haml": ["!", ".", "}", ":", "*", "$", "]", "/", ">", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "xml": [".", "}", "*", "$", "]", "/", ">", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "xsl": ["!", ".", "}", "*", "$", "/", "]", ">", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "css": [":", "!", "-", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "scss": [":", "!", "-", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "sass": [":", "!", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "less": [":", "!", "-", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "stylus": [":", "!", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "javascriptreact": ["!", ".", "}", "*", "$", "]", "/", ">", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "typescriptreact": ["!", ".", "}", "*", "$", "]", "/", ">", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    };
    function isStyleSheet(syntax) {
      const stylesheetSyntaxes = ["css", "scss", "sass", "less", "stylus"];
      return stylesheetSyntaxes.includes(syntax);
    }
    async function getMappingForIncludedLanguages(context) {
      const MAPPED_MODES = {
        "handlebars": "html",
        "php": "html"
      };
      const finalMappedModes = {};
      const includeLanguagesConfig = await context.env.getConfiguration?.("emmet.includeLanguages");
      const includeLanguages = Object.assign({}, MAPPED_MODES, includeLanguagesConfig ?? {});
      Object.keys(includeLanguages).forEach((syntax) => {
        if (typeof includeLanguages[syntax] === "string" && LANGUAGE_MODES[includeLanguages[syntax]]) {
          finalMappedModes[syntax] = includeLanguages[syntax];
        }
      });
      return finalMappedModes;
    }
    function getEmmetMode(language, mappedModes, excludedLanguages) {
      if (!language || excludedLanguages.includes(language)) {
        return;
      }
      if (language === "jsx-tags") {
        language = "javascriptreact";
      }
      if (mappedModes[language]) {
        language = mappedModes[language];
      }
      if (/\b(typescriptreact|javascriptreact|jsx-tags)\b/.test(language)) {
        language = "jsx";
      } else if (language === "sass-indented") {
        language = "sass";
      } else if (language === "jade" || language === "pug") {
        language = "pug";
      }
      const syntaxes = getSyntaxes();
      if (syntaxes.markup.includes(language) || syntaxes.stylesheet.includes(language)) {
        return language;
      }
      return;
    }
    var closeBrace = 125;
    var openBrace = 123;
    var slash = 47;
    var star = 42;
    function parsePartialStylesheet(document, position) {
      const isCSS = document.languageId === "css";
      const positionOffset = document.offsetAt(position);
      let startOffset = 0;
      let endOffset = document.getText().length;
      const limitCharacter = positionOffset - 5e3;
      const limitOffset = limitCharacter > 0 ? limitCharacter : startOffset;
      const stream = new bufferStream_1.DocumentStreamReader(document, positionOffset);
      function findOpeningCommentBeforePosition(pos) {
        const text = document.getText().substring(0, pos);
        const offset = text.lastIndexOf("/*");
        if (offset === -1) {
          return;
        }
        return offset;
      }
      function findClosingCommentAfterPosition(pos) {
        const text = document.getText().substring(pos);
        let offset = text.indexOf("*/");
        if (offset === -1) {
          return;
        }
        offset += 2 + pos;
        return offset;
      }
      function consumeLineCommentBackwards() {
        const posLineNumber = document.positionAt(stream.pos).line;
        if (!isCSS && currentLine !== posLineNumber) {
          currentLine = posLineNumber;
          const startLineComment = document.getText({
            start: { line: currentLine, character: 0 },
            end: { line: currentLine + 1, character: 0 }
          }).indexOf("//");
          if (startLineComment > -1) {
            stream.pos = document.offsetAt({ line: currentLine, character: startLineComment });
          }
        }
      }
      function consumeBlockCommentBackwards() {
        if (!stream.sof() && stream.peek() === slash) {
          if (stream.backUp(1) === star) {
            stream.pos = findOpeningCommentBeforePosition(stream.pos) ?? startOffset;
          } else {
            stream.next();
          }
        }
      }
      function consumeCommentForwards() {
        if (stream.eat(slash)) {
          if (stream.eat(slash) && !isCSS) {
            const posLineNumber = document.positionAt(stream.pos).line;
            stream.pos = document.offsetAt({ line: posLineNumber + 1, character: 0 });
          } else if (stream.eat(star)) {
            stream.pos = findClosingCommentAfterPosition(stream.pos) ?? endOffset;
          }
        }
      }
      while (!stream.eof() && !stream.eat(closeBrace)) {
        if (stream.peek() === slash) {
          consumeCommentForwards();
        } else {
          stream.next();
        }
      }
      if (!stream.eof()) {
        endOffset = stream.pos;
      }
      stream.pos = positionOffset;
      let openBracesToFind = 1;
      let currentLine = position.line;
      let exit = false;
      while (!exit && openBracesToFind > 0 && !stream.sof()) {
        consumeLineCommentBackwards();
        switch (stream.backUp(1)) {
          case openBrace:
            openBracesToFind--;
            break;
          case closeBrace:
            if (isCSS) {
              stream.next();
              startOffset = stream.pos;
              exit = true;
            } else {
              openBracesToFind++;
            }
            break;
          case slash:
            consumeBlockCommentBackwards();
            break;
          default:
            break;
        }
        if (position.line - document.positionAt(stream.pos).line > 100 || stream.pos <= limitOffset) {
          exit = true;
        }
      }
      currentLine = document.positionAt(stream.pos).line;
      openBracesToFind = 0;
      let foundSelector = false;
      while (!exit && !stream.sof() && !foundSelector && openBracesToFind >= 0) {
        consumeLineCommentBackwards();
        const ch = stream.backUp(1);
        if (/\s/.test(String.fromCharCode(ch))) {
          continue;
        }
        switch (ch) {
          case slash:
            consumeBlockCommentBackwards();
            break;
          case closeBrace:
            openBracesToFind++;
            break;
          case openBrace:
            openBracesToFind--;
            break;
          default:
            if (!openBracesToFind) {
              foundSelector = true;
            }
            break;
        }
        if (!stream.sof() && foundSelector) {
          startOffset = stream.pos;
        }
      }
      try {
        const buffer = " ".repeat(startOffset) + document.getText().substring(startOffset, endOffset);
        return (0, css_parser_1.default)(buffer);
      } catch (e) {
        return;
      }
    }
    function getFlatNode(root, offset, includeNodeBoundary) {
      if (!root) {
        return;
      }
      function getFlatNodeChild(child) {
        if (!child) {
          return;
        }
        const nodeStart = child.start;
        const nodeEnd = child.end;
        if (nodeStart < offset && nodeEnd > offset || includeNodeBoundary && nodeStart <= offset && nodeEnd >= offset) {
          return getFlatNodeChildren(child.children) ?? child;
        } else if ("close" in child) {
          const htmlChild = child;
          if (htmlChild.open && !htmlChild.close) {
            return getFlatNodeChildren(htmlChild.children);
          }
        }
        return;
      }
      function getFlatNodeChildren(children) {
        for (let i = 0; i < children.length; i++) {
          const foundChild = getFlatNodeChild(children[i]);
          if (foundChild) {
            return foundChild;
          }
        }
        return;
      }
      return getFlatNodeChildren(root.children);
    }
    exports2.allowedMimeTypesInScriptTag = [
      "text/html",
      "text/plain",
      "text/x-template",
      "text/template",
      "text/ng-template"
    ];
    function getHtmlFlatNode(documentText, root, offset, includeNodeBoundary) {
      let currentNode = getFlatNode(root, offset, includeNodeBoundary);
      if (!currentNode)
        return;
      if (currentNode.name === "script" && currentNode.children.length === 0) {
        const scriptNodeBody = setupScriptNodeSubtree(documentText, currentNode);
        if (scriptNodeBody) {
          currentNode = getHtmlFlatNode(scriptNodeBody, currentNode, offset, includeNodeBoundary) ?? currentNode;
        }
      } else if (currentNode.type === "cdata") {
        const cdataBody = setupCdataNodeSubtree(documentText, currentNode);
        currentNode = getHtmlFlatNode(cdataBody, currentNode, offset, includeNodeBoundary) ?? currentNode;
      }
      return currentNode;
    }
    function setupScriptNodeSubtree(documentText, scriptNode) {
      const isTemplateScript = scriptNode.name === "script" && (scriptNode.attributes && scriptNode.attributes.some((x) => x.name.toString() === "type" && exports2.allowedMimeTypesInScriptTag.includes(x.value.toString())));
      if (isTemplateScript && scriptNode.open) {
        const beforePadding = " ".repeat(scriptNode.open.end);
        const endToUse = scriptNode.close ? scriptNode.close.start : scriptNode.end;
        const scriptBodyText = beforePadding + documentText.substring(scriptNode.open.end, endToUse);
        const innerRoot = (0, html_matcher_1.default)(scriptBodyText);
        innerRoot.children.forEach((child) => {
          scriptNode.children.push(child);
          child.parent = scriptNode;
        });
        return scriptBodyText;
      }
      return "";
    }
    function setupCdataNodeSubtree(documentText, cdataNode) {
      const cdataStart = "<![CDATA[";
      const cdataEnd = "]]>";
      const startToUse = cdataNode.start + cdataStart.length;
      const endToUse = cdataNode.end - cdataEnd.length;
      const beforePadding = " ".repeat(startToUse);
      const cdataBody = beforePadding + documentText.substring(startToUse, endToUse);
      const innerRoot = (0, html_matcher_1.default)(cdataBody);
      innerRoot.children.forEach((child) => {
        cdataNode.children.push(child);
        child.parent = cdataNode;
      });
      return cdataBody;
    }
    async function getEmmetConfiguration(context, syntax) {
      const emmetConfig = await context.env.getConfiguration?.("emmet") ?? {};
      const syntaxProfiles = Object.assign({}, emmetConfig["syntaxProfiles"] || {});
      const preferences = Object.assign({}, emmetConfig["preferences"] || {});
      if (syntax === "jsx" || syntax === "xml" || syntax === "xsl") {
        syntaxProfiles[syntax] = syntaxProfiles[syntax] || {};
        if (typeof syntaxProfiles[syntax] === "object" && !syntaxProfiles[syntax].hasOwnProperty("self_closing_tag") && !syntaxProfiles[syntax].hasOwnProperty("selfClosingStyle")) {
          syntaxProfiles[syntax] = {
            ...syntaxProfiles[syntax],
            selfClosingStyle: syntax === "jsx" ? "xhtml" : "xml"
          };
        }
      }
      return {
        preferences,
        showExpandedAbbreviation: emmetConfig["showExpandedAbbreviation"],
        showAbbreviationSuggestions: emmetConfig["showAbbreviationSuggestions"],
        syntaxProfiles,
        variables: emmetConfig["variables"],
        excludeLanguages: emmetConfig["excludeLanguages"],
        showSuggestionsAsSnippets: emmetConfig["showSuggestionsAsSnippets"]
      };
    }
    function getEmbeddedCssNodeIfAny(document, currentNode, position) {
      if (!currentNode) {
        return;
      }
      const currentHtmlNode = currentNode;
      if (currentHtmlNode && currentHtmlNode.open && currentHtmlNode.close) {
        const offset = document.offsetAt(position);
        if (currentHtmlNode.open.end < offset && offset <= currentHtmlNode.close.start) {
          if (currentHtmlNode.name === "style") {
            const buffer = " ".repeat(currentHtmlNode.open.end) + document.getText().substring(currentHtmlNode.open.end, currentHtmlNode.close.start);
            return (0, css_parser_1.default)(buffer);
          }
        }
      }
      return;
    }
    function getSyntaxes() {
      return {
        markup: ["html", "xml", "xsl", "jsx", "js", "pug", "slim", "haml"],
        stylesheet: ["css", "sass", "scss", "less", "sss", "stylus"]
      };
    }
  }
});

// node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/lib/abbreviationActions.js
var require_abbreviationActions = __commonJS({
  "node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/lib/abbreviationActions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidLocationForEmmetAbbreviation = isValidLocationForEmmetAbbreviation;
    exports2.getSyntaxFromArgs = getSyntaxFromArgs;
    var util_1 = require_util();
    var hexColorRegex = /^#[\da-fA-F]{0,6}$/;
    async function isValidLocationForEmmetAbbreviation(context, document, rootNode, currentNode, syntax, offset, abbreviationRange) {
      if ((0, util_1.isStyleSheet)(syntax)) {
        const stylesheet = rootNode;
        if (stylesheet && (stylesheet.comments || []).some((x) => offset >= x.start && offset <= x.end)) {
          return false;
        }
        if (!currentNode) {
          return true;
        }
        const abbreviation = document.getText(abbreviationRange);
        if (abbreviation.startsWith("@")) {
          return true;
        }
        if (syntax !== "sass" && syntax !== "stylus" && currentNode.type === "property") {
          if (currentNode.parent && currentNode.parent.type !== "rule" && currentNode.parent.type !== "at-rule") {
            return false;
          }
          const propertyNode = currentNode;
          if (propertyNode.terminatorToken && propertyNode.separator && offset >= propertyNode.separatorToken.end && offset <= propertyNode.terminatorToken.start && !abbreviation.includes(":")) {
            return hexColorRegex.test(abbreviation) || abbreviation === "!";
          }
          if (!propertyNode.terminatorToken && propertyNode.separator && offset >= propertyNode.separatorToken.end && !abbreviation.includes(":")) {
            return hexColorRegex.test(abbreviation) || abbreviation === "!";
          }
          if (hexColorRegex.test(abbreviation) || abbreviation === "!") {
            return false;
          }
        }
        if (currentNode.type !== "rule" && currentNode.type !== "at-rule") {
          return true;
        }
        const currentCssNode = currentNode;
        if (offset > currentCssNode.contentStartToken.end) {
          return true;
        }
        if (currentCssNode.parent && (currentCssNode.parent.type === "rule" || currentCssNode.parent.type === "at-rule") && currentCssNode.selectorToken) {
          const position = document.positionAt(offset);
          const tokenStartPos = document.positionAt(currentCssNode.selectorToken.start);
          const tokenEndPos = document.positionAt(currentCssNode.selectorToken.end);
          if (position.line !== tokenEndPos.line && tokenStartPos.character === abbreviationRange.start.character && tokenStartPos.line === abbreviationRange.start.line) {
            return true;
          }
        }
        return false;
      }
      const startAngle = "<";
      const endAngle = ">";
      const escape = "\\";
      const question = "?";
      const currentHtmlNode = currentNode;
      let start = 0;
      if (currentHtmlNode) {
        if (currentHtmlNode.name === "script") {
          const typeAttribute = (currentHtmlNode.attributes || []).filter((x) => x.name.toString() === "type")[0];
          const typeValue = typeAttribute ? typeAttribute.value.toString() : "";
          if (util_1.allowedMimeTypesInScriptTag.includes(typeValue)) {
            return true;
          }
          const isScriptJavascriptType = !typeValue || typeValue === "application/javascript" || typeValue === "text/javascript";
          if (isScriptJavascriptType) {
            return !!await getSyntaxFromArgs(context, { language: "javascript" });
          }
          return false;
        }
        if (!currentHtmlNode.open || !currentHtmlNode.close || !(currentHtmlNode.open.end <= offset && offset <= currentHtmlNode.close.start)) {
          return false;
        }
        start = currentHtmlNode.open.end;
        let lastChildBeforePosition = currentHtmlNode.firstChild;
        while (lastChildBeforePosition) {
          if (lastChildBeforePosition.end > offset) {
            break;
          }
          start = lastChildBeforePosition.end;
          lastChildBeforePosition = lastChildBeforePosition.nextSibling;
        }
      }
      const startPos = document.positionAt(start);
      let textToBackTrack = document.getText({ start: startPos, end: abbreviationRange.start });
      if (textToBackTrack.length > 500) {
        textToBackTrack = textToBackTrack.substr(textToBackTrack.length - 500);
      }
      if (!textToBackTrack.trim()) {
        return true;
      }
      let valid = true;
      let foundSpace = false;
      let i = textToBackTrack.length - 1;
      if (textToBackTrack[i] === startAngle) {
        return false;
      }
      while (i >= 0) {
        const char = textToBackTrack[i];
        i--;
        if (!foundSpace && /\s/.test(char)) {
          foundSpace = true;
          continue;
        }
        if (char === question && textToBackTrack[i] === startAngle) {
          i--;
          continue;
        }
        if (/\s/.test(char) && textToBackTrack[i] === startAngle) {
          i--;
          continue;
        }
        if (char !== startAngle && char !== endAngle) {
          continue;
        }
        if (i >= 0 && textToBackTrack[i] === escape) {
          i--;
          continue;
        }
        if (char === endAngle) {
          if (i >= 0 && textToBackTrack[i] === "=") {
            continue;
          } else {
            break;
          }
        }
        if (char === startAngle) {
          valid = !foundSpace;
          break;
        }
      }
      return valid;
    }
    async function getSyntaxFromArgs(context, args) {
      const mappedModes = await (0, util_1.getMappingForIncludedLanguages)(context);
      const language = args["language"];
      const parentMode = args["parentMode"];
      const excludedLanguages = await context.env.getConfiguration?.("emmet.excludeLanguages") ?? [];
      if (excludedLanguages.includes(language)) {
        return;
      }
      let syntax = (0, util_1.getEmmetMode)(mappedModes[language] ?? language, mappedModes, excludedLanguages);
      if (!syntax) {
        syntax = (0, util_1.getEmmetMode)(mappedModes[parentMode] ?? parentMode, mappedModes, excludedLanguages);
      }
      return syntax;
    }
  }
});

// node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/lib/parseDocument.js
var require_parseDocument = __commonJS({
  "node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/lib/parseDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootNode = getRootNode;
    var css_parser_1 = require_css_parser_cjs();
    var html_matcher_1 = require_html_matcher_cjs();
    var util_1 = require_util();
    var _parseCache = /* @__PURE__ */ new Map();
    function getRootNode(document, useCache) {
      const key = document.uri.toString();
      const result = _parseCache.get(key);
      const documentVersion = document.version;
      if (useCache && result) {
        if (documentVersion === result.key) {
          return result.value;
        }
      }
      const parseContent = (0, util_1.isStyleSheet)(document.languageId) ? css_parser_1.default : html_matcher_1.default;
      const rootNode = parseContent(document.getText());
      if (useCache) {
        _parseCache.set(key, { key: documentVersion, value: rootNode });
      }
      return rootNode;
    }
  }
});

// node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/index.js
var require_volar_service_emmet = __commonJS({
  "node_modules/.pnpm/volar-service-emmet@0.0.67_@volar+language-service@2.4.26/node_modules/volar-service-emmet/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.create = create;
    var vscode_uri_1 = require_umd();
    var abbreviationActions_1 = require_abbreviationActions();
    var parseDocument_1 = require_parseDocument();
    var util_1 = require_util();
    function create({ mappedLanguages = {} } = {}) {
      return {
        name: "emmet",
        capabilities: {
          completionProvider: {
            // https://docs.emmet.io/abbreviations/syntax/
            triggerCharacters: ">+^*()#.[]$@-{}".split("")
          }
        },
        create(context) {
          let lastCompletionType;
          return {
            isAdditionalCompletion: true,
            provideCompletionItems(document, position, completionContext) {
              const completionResult = provideCompletionItemsInternal(document, position, completionContext);
              if (!completionResult) {
                lastCompletionType = void 0;
                return;
              }
              return completionResult.then((completionList) => {
                if (!completionList || !completionList.items.length) {
                  lastCompletionType = void 0;
                  return completionList;
                }
                const item = completionList.items[0];
                const expandedText = typeof item.documentation === "string" ? item.documentation : item.documentation ? item.documentation.value : "";
                if (expandedText.startsWith("<")) {
                  lastCompletionType = "html";
                } else if (expandedText.indexOf(":") > 0 && expandedText.endsWith(";")) {
                  lastCompletionType = "css";
                } else {
                  lastCompletionType = void 0;
                }
                return completionList;
              });
            }
          };
          async function provideCompletionItemsInternal(document, position, completionContext) {
            const emmetConfig = await context.env.getConfiguration?.("emmet") ?? {};
            const excludedLanguages = emmetConfig["excludeLanguages"] ?? [];
            if (excludedLanguages.includes(document.languageId)) {
              return;
            }
            const isSyntaxMapped = mappedLanguages[document.languageId] ? true : false;
            const emmetMode = (0, util_1.getEmmetMode)(mappedLanguages[document.languageId] ?? document.languageId, mappedLanguages, excludedLanguages);
            if (!emmetMode || emmetConfig["showExpandedAbbreviation"] === "never" || (isSyntaxMapped || emmetMode === "jsx") && emmetConfig["showExpandedAbbreviation"] !== "always") {
              return;
            }
            let syntax = emmetMode;
            let validateLocation = syntax === "html" || syntax === "jsx" || syntax === "xml";
            let rootNode;
            let currentNode;
            const lineRange = {
              start: { line: position.line, character: 0 },
              end: position
            };
            if (document.getText(lineRange).trimStart().startsWith("//")) {
              return;
            }
            const helper = (0, util_1.getEmmetHelper)();
            if (syntax === "html") {
              if (completionContext.triggerKind === 3) {
                switch (lastCompletionType) {
                  case "html":
                    validateLocation = false;
                    break;
                  case "css":
                    validateLocation = false;
                    syntax = "css";
                    break;
                  default:
                    break;
                }
              }
              if (validateLocation) {
                const positionOffset = document.offsetAt(position);
                const emmetRootNode = (0, parseDocument_1.getRootNode)(document, true);
                const foundNode = (0, util_1.getHtmlFlatNode)(document.getText(), emmetRootNode, positionOffset, false);
                if (foundNode) {
                  if (foundNode.name === "script") {
                    const typeNode = foundNode.attributes.find((attr) => attr.name.toString() === "type");
                    if (typeNode) {
                      const typeAttrValue = typeNode.value.toString();
                      if (typeAttrValue === "application/javascript" || typeAttrValue === "text/javascript") {
                        if (!await (0, abbreviationActions_1.getSyntaxFromArgs)(context, { language: "javascript" })) {
                          return;
                        } else {
                          validateLocation = false;
                        }
                      } else if (util_1.allowedMimeTypesInScriptTag.includes(typeAttrValue)) {
                        validateLocation = false;
                      }
                    } else {
                      return;
                    }
                  } else if (foundNode.name === "style") {
                    syntax = "css";
                    validateLocation = false;
                  } else {
                    const styleNode = foundNode.attributes.find((attr) => attr.name.toString() === "style");
                    if (styleNode && styleNode.value.start <= positionOffset && positionOffset <= styleNode.value.end) {
                      syntax = "css";
                      validateLocation = false;
                    }
                  }
                }
              }
            }
            const expandOptions = (0, util_1.isStyleSheet)(syntax) ? { lookAhead: false, syntax: "stylesheet" } : { lookAhead: true, syntax: "markup" };
            const extractAbbreviationResults = helper.extractAbbreviation(document, position, expandOptions);
            if (!extractAbbreviationResults || !helper.isAbbreviationValid(syntax, extractAbbreviationResults.abbreviation)) {
              return;
            }
            const offset = document.offsetAt(position);
            if ((0, util_1.isStyleSheet)(document.languageId) && completionContext.triggerKind !== 3) {
              validateLocation = true;
              const usePartialParsing = await context.env.getConfiguration?.("emmet.optimizeStylesheetParsing") === true;
              rootNode = usePartialParsing && document.lineCount > 1e3 ? (0, util_1.parsePartialStylesheet)(document, position) : (0, parseDocument_1.getRootNode)(document, true);
              if (!rootNode) {
                return;
              }
              currentNode = (0, util_1.getFlatNode)(rootNode, offset, true);
            }
            if (!(0, util_1.isStyleSheet)(document.languageId) && (0, util_1.isStyleSheet)(syntax) && completionContext.triggerKind !== 3) {
              validateLocation = true;
              rootNode = (0, parseDocument_1.getRootNode)(document, true);
              if (!rootNode) {
                return;
              }
              const flatNode = (0, util_1.getFlatNode)(rootNode, offset, true);
              const embeddedCssNode = (0, util_1.getEmbeddedCssNodeIfAny)(document, flatNode, position);
              currentNode = (0, util_1.getFlatNode)(embeddedCssNode, offset, true);
            }
            if (validateLocation && !await (0, abbreviationActions_1.isValidLocationForEmmetAbbreviation)(context, document, rootNode, currentNode, syntax, offset, extractAbbreviationResults.abbreviationRange)) {
              return;
            }
            let isNoisePromise = Promise.resolve(false);
            if (!(0, util_1.isStyleSheet)(syntax) && (document.languageId === "javascript" || document.languageId === "javascriptreact" || document.languageId === "typescript" || document.languageId === "typescriptreact")) {
              const abbreviation = extractAbbreviationResults.abbreviation;
              if (abbreviation.startsWith("this.") || /\[[^\]=]*\]/.test(abbreviation)) {
                isNoisePromise = Promise.resolve(true);
              } else {
                const uri = vscode_uri_1.URI.parse(document.uri);
                const documentUri = context.decodeEmbeddedDocumentUri(uri)?.[0] ?? uri;
                isNoisePromise = context.getLanguageService().getDocumentSymbols(documentUri).then((symbols) => {
                  return !!symbols && symbols.some((x) => abbreviation === x.name || abbreviation.startsWith(x.name + ".") && !/>|\*|\+/.test(abbreviation));
                });
              }
            }
            return isNoisePromise.then(async (isNoise) => {
              if (isNoise) {
                return void 0;
              }
              const config = await (0, util_1.getEmmetConfiguration)(context, syntax);
              const result = helper.doComplete(document, position, syntax, config);
              if (result && result.items && result.items.length === 1) {
                if (result.items[0].label === "widows: ;") {
                  return void 0;
                }
              }
              return result;
            });
          }
        }
      };
    }
  }
});

// src/server.ts
var import_node = __toESM(require_node5());
var import_volar_service_html = __toESM(require_volar_service_html());
var import_volar_service_css = __toESM(require_volar_service_css());
var import_volar_service_typescript = __toESM(require_volar_service_typescript());
var import_volar_service_emmet = __toESM(require_volar_service_emmet());

// src/plugin.ts
var import_parser = __toESM(require("tree-sitter-rsx/parser"));

// src/logger.ts
var fs = __toESM(require("node:fs"));
var path = __toESM(require("node:path"));
var os = __toESM(require("node:os"));
var LOG_DIR = path.join(os.homedir(), ".config", "rsx-language-server");
var LOG_FILE = path.join(LOG_DIR, "server.log");
var MAX_LOG_SIZE = 10 * 1024 * 1024;
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  return LogLevel2;
})(LogLevel || {});
var Logger = class {
  level = 1 /* INFO */;
  stream = null;
  initialized = false;
  init(level = 1 /* INFO */) {
    if (this.initialized) return;
    this.level = level;
    try {
      if (!fs.existsSync(LOG_DIR)) {
        fs.mkdirSync(LOG_DIR, { recursive: true });
      }
      this.rotateLogIfNeeded();
      this.stream = fs.createWriteStream(LOG_FILE, { flags: "a" });
      this.initialized = true;
      this.info("Logger initialized", { logDir: LOG_DIR, level: LogLevel[level] });
    } catch (err) {
      console.error("[RSX Logger] Failed to initialize:", err);
    }
  }
  rotateLogIfNeeded() {
    try {
      if (fs.existsSync(LOG_FILE)) {
        const stats = fs.statSync(LOG_FILE);
        if (stats.size > MAX_LOG_SIZE) {
          const backupFile = LOG_FILE + ".old";
          if (fs.existsSync(backupFile)) {
            fs.unlinkSync(backupFile);
          }
          fs.renameSync(LOG_FILE, backupFile);
        }
      }
    } catch (err) {
      console.error("[RSX Logger] Failed to rotate log:", err);
    }
  }
  formatMessage(level, message, data) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    let log = `[${timestamp}] [${level}] ${message}`;
    if (data) {
      log += ` ${JSON.stringify(data)}`;
    }
    return log + "\n";
  }
  write(level, levelName, message, data) {
    if (level < this.level) return;
    const formatted = this.formatMessage(levelName, message, data);
    if (this.stream) {
      this.stream.write(formatted);
    }
    if (level >= 2 /* WARN */) {
      console.error(formatted.trim());
    }
  }
  debug(message, data) {
    this.write(0 /* DEBUG */, "DEBUG", message, data);
  }
  info(message, data) {
    this.write(1 /* INFO */, "INFO", message, data);
  }
  warn(message, data) {
    this.write(2 /* WARN */, "WARN", message, data);
  }
  error(message, data) {
    this.write(3 /* ERROR */, "ERROR", message, data);
  }
  close() {
    if (this.stream) {
      this.stream.end();
      this.stream = null;
    }
    this.initialized = false;
  }
};
var logger = new Logger();

// src/plugin.ts
var FULL_FEATURES = {
  verification: true,
  completion: true,
  semantic: true,
  navigation: true,
  structure: true,
  format: true
};
var rsxLanguagePlugin = {
  getLanguageId(uri) {
    if (uri.path.endsWith(".rsx")) {
      return "rsx";
    }
    return void 0;
  },
  createVirtualCode(uri, languageId, snapshot) {
    if (languageId === "rsx") {
      return new RsxVirtualCode(uri, snapshot);
    }
    return void 0;
  },
  updateVirtualCode(_uri, virtualCode, snapshot) {
    if (virtualCode instanceof RsxVirtualCode) {
      virtualCode.update(snapshot);
    }
    return virtualCode;
  },
  typescript: {
    extraFileExtensions: [
      {
        extension: "rsx",
        isMixedContent: true,
        scriptKind: 7
        // TSX
      }
    ],
    getServiceScript(root) {
      for (const code of root.embeddedCodes ?? []) {
        if (code.id.endsWith("_script_section")) {
          return {
            code,
            extension: ".tsx",
            scriptKind: 4
            // TSX
          };
        }
      }
      return void 0;
    }
  }
};
function createSectionSnapshot(snapshot, start, end) {
  const length = end - start;
  return {
    getText(s, e) {
      const actualStart = start + s;
      const actualEnd = start + Math.min(e, length);
      return snapshot.getText(actualStart, actualEnd);
    },
    getLength() {
      return length;
    },
    getChangeRange() {
      return void 0;
    }
  };
}
var RsxVirtualCode = class {
  constructor(uri, snapshot) {
    this.uri = uri;
    this.snapshot = snapshot;
    this.id = uri.toString();
    this.rsxParser = new import_parser.default();
    logger.debug("Creating virtual code", { uri: this.id });
    this.parse();
  }
  languageId = "rsx";
  id;
  embeddedCodes = [];
  mappings = [];
  rsxParser;
  parseResult = null;
  update(newSnapshot) {
    this.snapshot = newSnapshot;
    this.embeddedCodes = [];
    this.mappings = [];
    logger.debug("Updating virtual code", { uri: this.id });
    this.parse();
  }
  parse() {
    const content = this.snapshot.getText(0, this.snapshot.getLength());
    try {
      this.parseResult = this.rsxParser.parse(content);
      logger.debug("Parsed RSX file", {
        uri: this.id,
        sections: this.parseResult.sections.length,
        errors: this.parseResult.errors.length
      });
      for (const section of this.parseResult.sections) {
        this.processSection(section, content);
      }
      this.addRootMapping(content.length);
    } catch (err) {
      logger.error("Parse error", { uri: this.id, error: String(err) });
    }
  }
  processSection(section, _content) {
    switch (section.type) {
      case "script_section":
        this.addScriptSection(section);
        break;
      case "template_section":
        this.addTemplateSection(section);
        break;
      case "style_section":
        this.addStyleSection(section);
        break;
      case "rust_section":
        this.addRustSection(section);
        break;
    }
  }
  addScriptSection(section) {
    const contentStart = this.findContentStart(section, "<script>");
    const contentEnd = this.findContentEnd(section, "</script>");
    if (contentStart >= contentEnd) return;
    const virtualCode = {
      id: `${this.id}_script_section`,
      languageId: "typescript",
      snapshot: createSectionSnapshot(this.snapshot, contentStart, contentEnd),
      mappings: [
        {
          sourceOffsets: [contentStart],
          generatedOffsets: [0],
          lengths: [contentEnd - contentStart],
          data: FULL_FEATURES
        }
      ]
    };
    this.embeddedCodes.push(virtualCode);
  }
  addTemplateSection(section) {
    const contentStart = this.findContentStart(section, "<template>");
    const contentEnd = this.findContentEnd(section, "</template>");
    if (contentStart >= contentEnd) return;
    const virtualCode = {
      id: `${this.id}_template_section`,
      languageId: "html",
      snapshot: createSectionSnapshot(this.snapshot, contentStart, contentEnd),
      mappings: [
        {
          sourceOffsets: [contentStart],
          generatedOffsets: [0],
          lengths: [contentEnd - contentStart],
          data: {
            completion: true,
            navigation: true,
            structure: true,
            format: true
          }
        }
      ]
    };
    this.embeddedCodes.push(virtualCode);
  }
  addStyleSection(section) {
    const contentStart = this.findContentStart(section, "<style>");
    const contentEnd = this.findContentEnd(section, "</style>");
    if (contentStart >= contentEnd) return;
    const virtualCode = {
      id: `${this.id}_style_section`,
      languageId: "css",
      snapshot: createSectionSnapshot(this.snapshot, contentStart, contentEnd),
      mappings: [
        {
          sourceOffsets: [contentStart],
          generatedOffsets: [0],
          lengths: [contentEnd - contentStart],
          data: FULL_FEATURES
        }
      ]
    };
    this.embeddedCodes.push(virtualCode);
  }
  addRustSection(section) {
    const content = this.snapshot.getText(section.start, section.end);
    const firstDelimiter = content.indexOf("---");
    const secondDelimiter = content.indexOf("---", firstDelimiter + 3);
    if (firstDelimiter === -1 || secondDelimiter === -1) return;
    const contentStart = section.start + firstDelimiter + 3;
    const contentEnd = section.start + secondDelimiter;
    let rustContent = this.snapshot.getText(contentStart, contentEnd);
    if (rustContent.startsWith("\n")) {
      rustContent = rustContent.slice(1);
    }
    const virtualCode = {
      id: `${this.id}_rust_section`,
      languageId: "rust",
      snapshot: {
        getText: (s, e) => rustContent.substring(s, e),
        getLength: () => rustContent.length,
        getChangeRange: () => void 0
      },
      mappings: [
        {
          sourceOffsets: [contentStart],
          generatedOffsets: [0],
          lengths: [rustContent.length],
          data: {
            completion: true,
            navigation: true,
            structure: true
          }
        }
      ]
    };
    this.embeddedCodes.push(virtualCode);
  }
  findContentStart(section, tag) {
    const content = this.snapshot.getText(section.start, section.end);
    const tagIndex = content.indexOf(tag);
    if (tagIndex === -1) return section.start;
    let start = section.start + tagIndex + tag.length;
    const afterTag = this.snapshot.getText(start, start + 1);
    if (afterTag === "\n") {
      start++;
    }
    return start;
  }
  findContentEnd(section, tag) {
    const content = this.snapshot.getText(section.start, section.end);
    const tagIndex = content.lastIndexOf(tag);
    if (tagIndex === -1) return section.end;
    return section.start + tagIndex;
  }
  addRootMapping(length) {
    this.mappings.push({
      sourceOffsets: [0],
      generatedOffsets: [0],
      lengths: [length],
      data: {
        verification: true,
        completion: true,
        semantic: true,
        navigation: true,
        structure: true,
        format: true
      }
    });
  }
  getParseResult() {
    return this.parseResult;
  }
};

// src/service.ts
var import_vscode_languageserver = __toESM(require_main4());
var RSX_DIRECTIVES = [
  {
    label: "{{@if}}",
    detail: "\u6761\u4EF6\u6E32\u67D3",
    insertText: "{{@if ${1:condition}}}\n	$0\n{{/if}}",
    documentation: "\u6839\u636E\u6761\u4EF6\u6E32\u67D3\u5185\u5BB9\n\n```rsx\n{{@if condition}}\n  content\n{{/if}}\n```"
  },
  {
    label: "{{@each}}",
    detail: "\u5217\u8868\u6E32\u67D3",
    insertText: "{{@each ${1:items} as ${2:item}}}\n	$0\n{{/each}}",
    documentation: "\u904D\u5386\u6570\u7EC4\u6E32\u67D3\u5217\u8868\n\n```rsx\n{{@each items as item, index}}\n  {{item}}\n{{/each}}\n```"
  },
  {
    label: "{{@html}}",
    detail: "\u539F\u59CBHTML",
    insertText: "{{@html ${1:content}}}",
    documentation: "\u8F93\u51FA\u539F\u59CBHTML\u5185\u5BB9\n\n\u26A0\uFE0F \u6CE8\u610F\u5B89\u5168\u6027\uFF0C\u907F\u514DXSS\u653B\u51FB\n\n```rsx\n{{@html rawContent}}\n```"
  },
  {
    label: "{{:else}}",
    detail: "else\u5206\u652F",
    insertText: "{{:else}}",
    documentation: "\u6761\u4EF6\u4E0D\u6EE1\u8DB3\u65F6\u7684\u5206\u652F\n\n```rsx\n{{@if condition}}\n  ...\n{{:else}}\n  ...\n{{/if}}\n```"
  },
  {
    label: "{{:else if}}",
    detail: "else if\u5206\u652F",
    insertText: "{{:else if ${1:condition}}}",
    documentation: "else if \u6761\u4EF6\u5206\u652F\n\n```rsx\n{{@if condition1}}\n  ...\n{{:else if condition2}}\n  ...\n{{/if}}\n```"
  },
  {
    label: "{{/if}}",
    detail: "\u7ED3\u675Fif",
    insertText: "{{/if}}",
    documentation: "\u7ED3\u675F\u6761\u4EF6\u6E32\u67D3\u5757"
  },
  {
    label: "{{/each}}",
    detail: "\u7ED3\u675Feach",
    insertText: "{{/each}}",
    documentation: "\u7ED3\u675F\u5217\u8868\u6E32\u67D3\u5757"
  },
  {
    label: "{{}}",
    detail: "\u63D2\u503C\u8868\u8FBE\u5F0F",
    insertText: "{{${1:expression}}}",
    documentation: "\u8F93\u51FA\u8868\u8FBE\u5F0F\u7684\u503C\n\n```rsx\n{{variable}}\n{{obj.property}}\n{{func(arg)}}\n```"
  }
];
var RSX_SECTIONS = [
  {
    label: "---",
    detail: "Rust frontmatter",
    insertText: "---\n${1:// Rust code}\n---",
    documentation: "Rust \u4EE3\u7801\u533A\u5757\n\n```rsx\n---\nuse rsx::prelude::*;\n\npub async fn handler() -> impl IntoResponse {\n    // ...\n}\n---\n```"
  },
  {
    label: "<script>",
    detail: "Script section",
    insertText: "<script>\n${1:// TypeScript code}\n</script>",
    documentation: "TypeScript \u811A\u672C\u533A\u5757\n\n```rsx\n<script>\nexport const data = { ... };\n</script>\n```"
  },
  {
    label: "<template>",
    detail: "Template section",
    insertText: "<template>\n	$0\n</template>",
    documentation: 'HTML \u6A21\u677F\u533A\u5757\n\n```rsx\n<template>\n  <div class="container">\n    ...\n  </div>\n</template>\n```'
  },
  {
    label: "<style>",
    detail: "Style section",
    insertText: "<style>\n${1:/* CSS/SCSS */}\n</style>",
    documentation: "CSS/SCSS \u6837\u5F0F\u533A\u5757\n\n```rsx\n<style>\n.container {\n  display: flex;\n}\n</style>\n```"
  }
];
function createRsxService() {
  return {
    name: "rsx",
    capabilities: {
      completionProvider: {
        triggerCharacters: ["{", "@", "#", ":", "<", "-"]
      },
      hoverProvider: true
    },
    create(_context) {
      return {
        provideCompletionItems(document, position, _completionContext, _token) {
          if (!document.uri.endsWith(".rsx")) {
            return null;
          }
          const text = document.getText();
          const offset = document.offsetAt(position);
          const lineStart = text.lastIndexOf("\n", offset - 1) + 1;
          const lineText = text.substring(lineStart, offset);
          const charBefore = text.charAt(offset - 1);
          const twoCharsBefore = text.substring(Math.max(0, offset - 2), offset);
          const items = [];
          if (twoCharsBefore === "{{" || charBefore === "{") {
            for (const directive of RSX_DIRECTIVES) {
              items.push({
                label: directive.label,
                kind: import_vscode_languageserver.CompletionItemKind.Snippet,
                detail: directive.detail,
                insertText: directive.insertText,
                insertTextFormat: import_vscode_languageserver.InsertTextFormat.Snippet,
                documentation: {
                  kind: import_vscode_languageserver.MarkupKind.Markdown,
                  value: directive.documentation
                }
              });
            }
          }
          const trimmedLine = lineText.trim();
          if (trimmedLine === "" || trimmedLine === "<" || trimmedLine === "-" || trimmedLine === "--") {
            for (const section of RSX_SECTIONS) {
              items.push({
                label: section.label,
                kind: import_vscode_languageserver.CompletionItemKind.Snippet,
                detail: section.detail,
                insertText: section.insertText,
                insertTextFormat: import_vscode_languageserver.InsertTextFormat.Snippet,
                documentation: {
                  kind: import_vscode_languageserver.MarkupKind.Markdown,
                  value: section.documentation
                }
              });
            }
          }
          if (items.length === 0) {
            return null;
          }
          return {
            isIncomplete: false,
            items
          };
        },
        provideHover(document, position, _token) {
          if (!document.uri.endsWith(".rsx")) {
            return null;
          }
          const text = document.getText();
          const offset = document.offsetAt(position);
          const range = 30;
          const start = Math.max(0, offset - range);
          const end = Math.min(text.length, offset + range);
          const context = text.substring(start, end);
          const hoverDocs = {
            "{{@if": "**\u6761\u4EF6\u6E32\u67D3\u6307\u4EE4**\n\n\u6839\u636E\u6761\u4EF6\u51B3\u5B9A\u662F\u5426\u6E32\u67D3\u5185\u5BB9\n\n```rsx\n{{@if condition}}\n  content\n{{:else if otherCondition}}\n  other content\n{{:else}}\n  fallback\n{{/if}}\n```",
            "{{@each": "**\u5217\u8868\u6E32\u67D3\u6307\u4EE4**\n\n\u904D\u5386\u6570\u7EC4\u6E32\u67D3\u5217\u8868\u9879\n\n```rsx\n{{@each items as item, index}}\n  <div>{{index}}: {{item.name}}</div>\n{{/each}}\n```",
            "{{@html": "**\u539F\u59CBHTML\u6307\u4EE4**\n\n\u76F4\u63A5\u8F93\u51FAHTML\u5185\u5BB9\uFF0C\u4E0D\u8FDB\u884C\u8F6C\u4E49\n\n\u26A0\uFE0F **\u5B89\u5168\u8B66\u544A**: \u786E\u4FDD\u5185\u5BB9\u53EF\u4FE1\uFF0C\u907F\u514DXSS\u653B\u51FB\n\n```rsx\n{{@html rawHtmlContent}}\n```",
            "{{:else}}": "**else \u5206\u652F**\n\n\u5F53\u6761\u4EF6\u4E0D\u6EE1\u8DB3\u65F6\u6267\u884C\u7684\u5206\u652F",
            "{{:else if": "**else if \u5206\u652F**\n\n\u989D\u5916\u7684\u6761\u4EF6\u5224\u65AD\u5206\u652F",
            "{{/if}}": "**\u7ED3\u675F if \u5757**",
            "{{/each}}": "**\u7ED3\u675F each \u5757**",
            "<script>": "**Script \u533A\u5757**\n\nTypeScript/JavaScript \u4EE3\u7801\u533A\u57DF\n\n\u652F\u6301\u5BFC\u51FA\u6570\u636E\u4F9B\u6A21\u677F\u4F7F\u7528",
            "</script>": "**Script \u533A\u5757\u7ED3\u675F\u6807\u7B7E**",
            "<template>": "**Template \u533A\u5757**\n\nHTML \u6A21\u677F\u533A\u57DF\n\n\u652F\u6301 RSX \u6307\u4EE4\u548C\u63D2\u503C\u8868\u8FBE\u5F0F",
            "</template>": "**Template \u533A\u5757\u7ED3\u675F\u6807\u7B7E**",
            "<style>": "**Style \u533A\u5757**\n\nCSS/SCSS \u6837\u5F0F\u533A\u57DF",
            "</style>": "**Style \u533A\u5757\u7ED3\u675F\u6807\u7B7E**",
            "---": "**Rust Frontmatter**\n\nRust \u4EE3\u7801\u533A\u57DF\n\n\u7528\u4E8E\u5B9A\u4E49\u670D\u52A1\u7AEF\u903B\u8F91"
          };
          for (const [pattern, doc] of Object.entries(hoverDocs)) {
            if (context.includes(pattern)) {
              return {
                contents: {
                  kind: import_vscode_languageserver.MarkupKind.Markdown,
                  value: doc
                }
              };
            }
          }
          return null;
        }
      };
    }
  };
}

// src/server.ts
var path2 = __toESM(require("node:path"));
logger.init(1 /* INFO */);
var connection = (0, import_node.createConnection)();
var server = (0, import_node.createServer)(connection);
connection.listen();
connection.onInitialize((params) => {
  logger.info("Server initializing", {
    rootUri: params.rootUri,
    capabilities: Object.keys(params.capabilities)
  });
  const tsdk2 = (0, import_node.loadTsdkByPath)(
    params.initializationOptions?.typescript?.tsdk ?? path2.dirname(require.resolve("typescript/lib/typescript.js")),
    params.locale
  );
  logger.debug("TypeScript SDK loaded", { locale: params.locale });
  const tsServices = (0, import_volar_service_typescript.create)(tsdk2.typescript, tsdk2.diagnosticMessages);
  return server.initialize(params, (0, import_node.createSimpleProject)([rsxLanguagePlugin]), [
    (0, import_volar_service_html.create)(),
    (0, import_volar_service_css.create)(),
    ...tsServices,
    (0, import_volar_service_emmet.create)(),
    createRsxService()
  ]);
});
connection.onInitialized(() => {
  server.initialized();
  logger.info("Server initialized with Volar services");
  connection.console.log("[RSX] Language Server initialized");
});
connection.onShutdown(() => {
  logger.info("Server shutting down");
  logger.close();
  server.shutdown();
});
//# sourceMappingURL=server.js.map
